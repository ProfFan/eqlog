use crate::ast::*;
use std::iter::once;

grammar;

pub Unit: Vec<Declaration> = { Declaration* => <>, }

pub Id: String = { r"[A-Za-z][A-Za-z0-9'_]*" => <>.to_string(), }

pub PredicateSignature: PredicateSignature = {
    <name: Id> ":" <head: Id> <tail: ("*" <Id>)*>
        => PredicateSignature { name, arity: once(head).chain(tail).collect() },
}

pub FunctionSignature: FunctionSignature = {
    <name: Id> ":" <head_dom: (<Id>)?> <tail_dom: ("*" <Id>)*> "->" <codomain: Id>
        => FunctionSignature {
            name,
            domain: head_dom.into_iter().chain(tail_dom).collect(),
            codomain,
        },
}

pub Term: Term = {
    <var: Id> => Term::Variable(var),
    "_" => Term::Wildcard(None),
    <function: Id> "(" <head_arg: (<Term>)?> <tail_args: ("," <Term>)*> ")" => {
        Term::Application(
            function, head_arg.into_iter().chain(tail_args).collect()),
}

pub Atom: Atom = {
    <lhs: Term> "=" <rhs: Term> => Atom::Equal(lhs, rhs),
    "!" <t: Term> => Atom::Defined(t),
    <pred: Id> "(" <head_arg: (<Term>)?> <tail_args: ("," <Term>)*> ")"
        => Atom::Predicate(pred, head_arg.into_iter().chain(tail_args).collect()),
}

pub Formula: Formula = {
    <head_atom: (<Atom>)?> <tail_atoms : ("&" <Atom>)*> =>
        Formula(head_atom.into_iter().chain(tail_atoms).collect()),
}

pub Sequent: Sequent = {
    <premise: Formula> "=>" <conclusion: Formula> => Sequent::SurjectiveImplication(premise, conclusion),
    <premise: Formula> "=>!" <conclusion: Formula> => Sequent::Implication(premise, conclusion),
    <s: Term> "~>" <t: Term> => Sequent::Reduction(s, t),
    <premise: Formula> "=>" <s: Term> "~>" <t: Term> => Sequent::ConditionalReduction(premise, s, t),
}

pub Declaration: Declaration = {
    "Sort" <sort: Id> ";" => Declaration::Sort(sort),
    <pred_sig: PredicateSignature> ";" => Declaration::Predicate(pred_sig),
    <func_sig: FunctionSignature> ";" => Declaration::Function(func_sig),
    <seq: Sequent> ";" => Declaration::Axiom(seq),
}
