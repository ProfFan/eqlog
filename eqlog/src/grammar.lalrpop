use crate::ast::*;
use crate::error::*;
use crate::module::*;
use crate::source_display::Location;
use std::iter::once;
use convert_case::{Case, Casing};
use std::mem::swap;

grammar(context: &mut TermContext);

extern {
    type Error = CompileError;
}

Id: String = {
    r"[A-Za-z][A-Za-z0-9'_]*" => <>.to_string(),
}

PairFirst<First, Second>: First = {
    <first: First> <second: Second> => first,
}

NonEmptyIntersperse<Item, Separator>: Vec<Item> = {
    <mut init: PairFirst<Item, Separator>*> <last: Item> => {
        init.push(last);
        init
    },
}

Intersperse<Item, Separator>: Vec<Item> = {
    <non_empty: NonEmptyIntersperse<Item, Separator>> => non_empty,
    () => vec![],
}

Variable: Term = {
    <l: @L> <var: Id> <r: @R> => {
        context.new_term(TermData::Variable(var), Location(l, r))
    },
}
Wildcard: Term = {
    <l: @L> "_" <r: @R> => {
        context.new_term(TermData::Wildcard, Location(l, r))
    },
}
ApplicationTerm: Term = {
    <l: @L> <func: Id> "(" <args: Intersperse<Term, ",">> ")" <r: @R> => {
        context.new_term(TermData::Application { func, args }, Location(l, r))
    },
}

Term: Term = {
    <var: Variable> => var,
    <wildcard: Wildcard> => wildcard,
    <application: ApplicationTerm> => application,
}

ArgList: Vec<Term> = {
    <l: @L> "(" <args: Intersperse<Term, ",">> ")" <r: @R> => {
        args
    },
}

IfAtom: IfAtom = {
    <l: @L> <lhs: Term> "=" <rhs: Term> <r: @R> => {
        IfAtom { data: IfAtomData::Equal(lhs, rhs), loc: Location(l, r) }
    },
    <l: @L> <tm: Term> "!" <r: @R> => {
        IfAtom { data: IfAtomData::Defined(tm), loc: Location(l, r) }
    },
    <l: @L> <pred: Id> <args: ArgList> <r: @R> => {
        IfAtom { data: IfAtomData::Pred { pred, args }, loc: Location(l, r) }
    },
    <l: @L> <term: Term> ":" <typ: Id> <r: @R> => {
        IfAtom { data: IfAtomData::Var { term, typ }, loc: Location(l, r) }
    },
}

ThenAtom: ThenAtom = {
    <l: @L> <lhs: Term> "=" <rhs: Term> <r: @R> => {
        ThenAtom { data: ThenAtomData::Equal(lhs, rhs), loc: Location(l, r) }
    },
    <l: @L> <var: PairFirst<Term, ":=">?> <term: Term> "!" <r: @R> => {
        ThenAtom { data: ThenAtomData::Defined { var, term }, loc: Location(l, r) }
    },
    <l: @L> <pred: Id> <args: ArgList> <r: @R> => {
        ThenAtom { data: ThenAtomData::Pred { pred, args }, loc: Location(l, r) }
    },
}

Stmt: Stmt = {
    <l: @L> "if" <atom: IfAtom> ";" <r: @R> => {
        Stmt { data: StmtData::If(atom), loc: Location(l, r) }
    },
    <l: @L> "then" <atom: ThenAtom> ";" <r: @R> => {
        Stmt { data: StmtData::Then(atom), loc: Location(l, r) }
    },
}

RuleDecl: RuleDecl = {
    <l: @L> "rule" <name: Id?> "{" <body: Stmt*> "}" <r: @R> => {
        let mut term_context = TermContext::new();
        swap(&mut term_context, context);
        RuleDecl { name, body, term_context, loc: Location(l, r) }
    },
}

TypeDecl: TypeDecl = {
    <l: @L>  "type" <name: Id> ";" <r: @R> => {
        TypeDecl{name, loc: Location(l, r)}
    },
}

ArgDecl: ArgDecl = {
    <l: @L> <name: PairFirst<Id, ":">?> <typ: Id> <r: @R> => {
        ArgDecl { name, typ, loc: Location(l, r) }
    },
}

ArgDeclList: Vec<ArgDecl> = {
    "(" <arg_decls: Intersperse<ArgDecl, ",">> ")" => {
        arg_decls
    },
}

PredDecl: PredDecl = {
    <l: @L> "pred" <name: Id> <arg_decls: ArgDeclList> ";" <r: @R> => {
        PredDecl { name, arg_decls, loc: Location(l, r) }
    },
}

FuncDecl: FuncDecl = {
    <l: @L> "func" <name: Id> <arg_decls: ArgDeclList> "->" <result: Id> ";" <r: @R> => {
        FuncDecl { name, arg_decls, result, loc: Location(l, r) }
    },
}

Decl: Decl = {
    <typ: TypeDecl> => Decl::Type(typ),
    <func: FuncDecl> => Decl::Func(func),
    <pred: PredDecl> => Decl::Pred(pred),
    <rule: RuleDecl> => Decl::Rule(rule),
}

pub Module: Module = {
    <decls: Decl*> => Module(decls),
}
