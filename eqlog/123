[0m[0m[1m[32m       Fresh[0m autocfg v1.1.0
[0m[0m[1m[32m       Fresh[0m cfg-if v1.0.0
[0m[0m[1m[32m       Fresh[0m scopeguard v1.1.0
[0m[0m[1m[32m       Fresh[0m smallvec v1.9.0
[0m[0m[1m[32m       Fresh[0m regex-syntax v0.6.27
[0m[0m[1m[32m       Fresh[0m siphasher v0.3.10
[0m[0m[1m[32m       Fresh[0m hashbrown v0.12.3
[0m[0m[1m[32m       Fresh[0m bit-vec v0.6.3
[0m[0m[1m[32m       Fresh[0m once_cell v1.13.0
[0m[0m[1m[32m       Fresh[0m either v1.7.0
[0m[0m[1m[32m       Fresh[0m fixedbitset v0.4.2
[0m[0m[1m[32m       Fresh[0m new_debug_unreachable v1.0.4
[0m[0m[1m[32m       Fresh[0m precomputed-hash v0.1.1
[0m[0m[1m[32m       Fresh[0m unicode-xid v0.2.3
[0m[0m[1m[32m       Fresh[0m pico-args v0.4.2
[0m[0m[1m[32m       Fresh[0m unicode-ident v1.0.2
[0m[0m[1m[32m       Fresh[0m diff v0.1.13
[0m[0m[1m[32m       Fresh[0m maplit v1.0.2
[0m[0m[1m[32m       Fresh[0m convert_case v0.5.0
[0m[0m[1m[32m       Fresh[0m unicode-width v0.1.9
[0m[0m[1m[32m       Fresh[0m indoc v1.0.6
[0m[0m[1m[32m       Fresh[0m phf_shared v0.10.0
[0m[0m[1m[32m       Fresh[0m bit-set v0.5.3
[0m[0m[1m[32m       Fresh[0m itertools v0.10.3
[0m[0m[1m[32m       Fresh[0m libc v0.2.126
[0m[0m[1m[32m       Fresh[0m memchr v2.5.0
[0m[0m[1m[32m       Fresh[0m papergrid v0.4.0
[0m[0m[1m[32m       Fresh[0m crunchy v0.2.2
[0m[0m[1m[32m       Fresh[0m log v0.4.17
[0m[0m[1m[32m       Fresh[0m proc-macro2 v1.0.42
[0m[0m[1m[32m       Fresh[0m dirs-sys-next v0.1.2
[0m[0m[1m[32m       Fresh[0m parking_lot_core v0.9.3
[0m[0m[1m[32m       Fresh[0m lock_api v0.4.7
[0m[0m[1m[32m       Fresh[0m aho-corasick v0.7.18
[0m[0m[1m[32m       Fresh[0m indexmap v1.9.1
[0m[0m[1m[32m       Fresh[0m atty v0.2.14
[0m[0m[1m[32m       Fresh[0m tiny-keccak v2.0.2
[0m[0m[1m[32m       Fresh[0m dirs-next v2.0.0
[0m[0m[1m[32m       Fresh[0m regex v1.6.0
[0m[0m[1m[32m       Fresh[0m parking_lot v0.12.1
[0m[0m[1m[32m       Fresh[0m ena v0.14.0
[0m[0m[1m[32m       Fresh[0m petgraph v0.6.2
[0m[0m[1m[32m       Fresh[0m quote v1.0.20
[0m[0m[1m[32m       Fresh[0m term v0.7.0
[0m[0m[1m[32m       Fresh[0m lalrpop-util v0.19.8
[0m[0m[1m[32m       Fresh[0m string_cache v0.8.4
[0m[0m[1m[32m       Fresh[0m syn v1.0.98
[0m[0m[1m[32m       Fresh[0m ascii-canvas v3.0.0
[0m[0m[1m[32m       Fresh[0m tabled_derive v0.3.0
[0m[0m[1m[32m       Fresh[0m lalrpop v0.19.8
[0m[0m[1m[32m       Fresh[0m tabled v0.7.0
[0m[0m[1m[32m       Fresh[0m eqlog-util v0.1.0 (/home/mbid/work/exp-epa/eqlog/eqlog-util)
[0m[0m[1m[32m   Compiling[0m eqlog v0.1.0 (/home/mbid/work/exp-epa/eqlog)
[0m[0m[1m[32m     Running[0m `/home/mbid/work/exp-epa/target/debug/build/eqlog-9d3e477065b8524a/build-script-build`
[0m[0m[1m[32m     Running[0m `CARGO=/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/bin/cargo CARGO_CRATE_NAME=eqlog CARGO_MANIFEST_DIR=/home/mbid/work/exp-epa/eqlog CARGO_PKG_AUTHORS='Martin Bidlingmaier <martin.bidlingmaier@mbid.me>' CARGO_PKG_DESCRIPTION='' CARGO_PKG_HOMEPAGE='' CARGO_PKG_LICENSE='' CARGO_PKG_LICENSE_FILE='' CARGO_PKG_NAME=eqlog CARGO_PKG_REPOSITORY='' CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 CARGO_PKG_VERSION_PRE='' LD_LIBRARY_PATH='/home/mbid/work/exp-epa/target/debug/deps:/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/lib:/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/lib' OUT_DIR=/home/mbid/work/exp-epa/target/debug/build/eqlog-8cfb5cbc9bde85c9/out rustc --crate-name eqlog --edition=2021 eqlog/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 -C metadata=75d65a0dc786a7f7 -C extra-filename=-75d65a0dc786a7f7 --out-dir /home/mbid/work/exp-epa/target/debug/deps -C incremental=/home/mbid/work/exp-epa/target/debug/incremental -L dependency=/home/mbid/work/exp-epa/target/debug/deps --extern convert_case=/home/mbid/work/exp-epa/target/debug/deps/libconvert_case-aab48c5420b4a5ec.rmeta --extern indoc=/home/mbid/work/exp-epa/target/debug/deps/libindoc-4f354f9e6ce2f4d0.so --extern itertools=/home/mbid/work/exp-epa/target/debug/deps/libitertools-732f09b03dcfb75d.rmeta --extern lalrpop_util=/home/mbid/work/exp-epa/target/debug/deps/liblalrpop_util-09f3aa58cd65e789.rmeta --extern maplit=/home/mbid/work/exp-epa/target/debug/deps/libmaplit-7541836b214019f3.rmeta --extern regex=/home/mbid/work/exp-epa/target/debug/deps/libregex-3c2cc51fba83b5fb.rmeta`
[0m[0m[1m[32m   Compiling[0m eqlog-test v0.1.0 (/home/mbid/work/exp-epa/eqlog/eqlog-test)
[0m[0m[1m[32m     Running[0m `CARGO=/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/bin/cargo CARGO_CRATE_NAME=build_script_build CARGO_MANIFEST_DIR=/home/mbid/work/exp-epa/eqlog/eqlog-test CARGO_PKG_AUTHORS='' CARGO_PKG_DESCRIPTION='' CARGO_PKG_HOMEPAGE='' CARGO_PKG_LICENSE='' CARGO_PKG_LICENSE_FILE='' CARGO_PKG_NAME=eqlog-test CARGO_PKG_REPOSITORY='' CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 CARGO_PKG_VERSION_PRE='' CARGO_PRIMARY_PACKAGE=1 LD_LIBRARY_PATH='/home/mbid/work/exp-epa/target/debug/deps:/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/lib:/usr/local/rustup/toolchains/1.61.0-x86_64-unknown-linux-gnu/lib' rustc --crate-name build_script_build --edition=2021 eqlog/eqlog-test/build.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 -C metadata=136af4432db86cd3 -C extra-filename=-136af4432db86cd3 --out-dir /home/mbid/work/exp-epa/target/debug/build/eqlog-test-136af4432db86cd3 -C incremental=/home/mbid/work/exp-epa/target/debug/incremental -L dependency=/home/mbid/work/exp-epa/target/debug/deps --extern eqlog=/home/mbid/work/exp-epa/target/debug/deps/libeqlog-75d65a0dc786a7f7.rlib`
[0m[0m[1m[32m     Running[0m `/home/mbid/work/exp-epa/target/debug/build/eqlog-test-136af4432db86cd3/build-script-build`
[eqlog-test 0.1.0] Compiling "src/equational_monoid.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/equational_monoid.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 5 | Axiom Mul(x, E()) ~> x;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0]   Mul(x, E()): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 6 | Axiom Mul(E(), x) ~> x;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   Mul(E(), x): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 7 | Axiom Mul(Mul(a, b), c) <~> Mul(a, Mul(b, c));
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   b: M
[eqlog-test 0.1.0]   Mul(a, b): M
[eqlog-test 0.1.0]   c: M
[eqlog-test 0.1.0]   Mul(Mul(a, b), c): M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   b: M
[eqlog-test 0.1.0]   c: M
[eqlog-test 0.1.0]   Mul(b, c): M
[eqlog-test 0.1.0]   Mul(a, Mul(b, c)): M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/trivial_idempotent.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/trivial_idempotent.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0]  6 | Axiom
[eqlog-test 0.1.0]  7 |   & a = Mul(a, a)
[eqlog-test 0.1.0]  8 |   & E()!
[eqlog-test 0.1.0]  9 |   =>
[eqlog-test 0.1.0] 10 |   & a = E()
[eqlog-test 0.1.0] 11 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   Mul(a, a): M
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/poset.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/poset.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 4 | Axiom x : P => Le(x, x);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 5 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   y: P
[eqlog-test 0.1.0]   y: P
[eqlog-test 0.1.0]   z: P
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   z: P
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 6 | Axiom Le(x, y) & Le(y, x) => x = y;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   y: P
[eqlog-test 0.1.0]   y: P
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   x: P
[eqlog-test 0.1.0]   y: P
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/logic.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/logic.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 5 | Axiom Truth();
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 6 | Axiom Absurd() => Undetermined();
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/group.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/group.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 8 | Axiom x: El & y: El => Mul(x, y)!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Mul(x, y): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 9 | Axiom Id()!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   Id(): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 10 | Axiom x: El => Inv(x)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   Inv(x): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 13 | Axiom Mul(Mul(x, y), z) <~> Mul(x, Mul(y, z));
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Mul(x, y): El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   Mul(Mul(x, y), z): El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   Mul(y, z): El
[eqlog-test 0.1.0]   Mul(x, Mul(y, z)): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 16 | Axiom Mul(x, Id()) ~> x;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   Id(): El
[eqlog-test 0.1.0]   Mul(x, Id()): El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 19 | Axiom Mul(x, Inv(x)) <~> Id();
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   Inv(x): El
[eqlog-test 0.1.0]   Mul(x, Inv(x)): El
[eqlog-test 0.1.0]   Id(): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/semilattice.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/semilattice.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 6 | Axiom x: El => Le(x, x);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 7 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 8 | Axiom Le(x, y) & Le(y, x) => x = y;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 11 | Axiom x: El & y: El => Meet(x, y)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 12 | Axiom meet = Meet(x, y) => Le(meet, x) & Le(meet, y);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 13 | Axiom Le(z, x) & Le(z, y) & meet = Meet(x, y) => Le(z, meet);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/pointed.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/pointed.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 3 | Axiom Pt()!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   Pt(): P
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/category_mod/category.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/category_mod/category.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 9 | Axiom Cod(f) = Dom(g) => Comp(g, f)!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Cod(f): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   Dom(g): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Comp(g, f): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 10 | Axiom h = Comp(_, f) & d = Dom(f) => Dom(h) = d;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   h: Mor
[eqlog-test 0.1.0]   _1: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Comp(_1, f): Mor
[eqlog-test 0.1.0]   d: Obj
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Dom(f): Obj
[eqlog-test 0.1.0]   h: Mor
[eqlog-test 0.1.0]   Dom(h): Obj
[eqlog-test 0.1.0]   d: Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 11 | Axiom h = Comp(g, _) & c = Cod(g) => Cod(h) = c;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   h: Mor
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   _2: Mor
[eqlog-test 0.1.0]   Comp(g, _2): Mor
[eqlog-test 0.1.0]   c: Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   Cod(g): Obj
[eqlog-test 0.1.0]   h: Mor
[eqlog-test 0.1.0]   Cod(h): Obj
[eqlog-test 0.1.0]   c: Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 12 | Axiom x : Obj & y : Obj => Id(x)! & Id(y)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   y: Obj
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   Id(x): Mor
[eqlog-test 0.1.0]   y: Obj
[eqlog-test 0.1.0]   Id(y): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/monoid.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/monoid.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 7 | Axiom E()!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 8 | Axiom x: M & y: M => Mul(x, y)!;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0]   Mul(x, y): M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 9 | Axiom y = Mul(x, E()) => x = y;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0]   Mul(x, E()): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 10 | Axiom y = Mul(E(), x) => x = y;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0]   E(): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   Mul(E(), x): M
[eqlog-test 0.1.0]   x: M
[eqlog-test 0.1.0]   y: M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 11 | Axiom d = Mul(Mul(a, b), c) & e = Mul(a, Mul(b, c)) => d = e;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   d: M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   b: M
[eqlog-test 0.1.0]   Mul(a, b): M
[eqlog-test 0.1.0]   c: M
[eqlog-test 0.1.0]   Mul(Mul(a, b), c): M
[eqlog-test 0.1.0]   e: M
[eqlog-test 0.1.0]   a: M
[eqlog-test 0.1.0]   b: M
[eqlog-test 0.1.0]   c: M
[eqlog-test 0.1.0]   Mul(b, c): M
[eqlog-test 0.1.0]   Mul(a, Mul(b, c)): M
[eqlog-test 0.1.0]   d: M
[eqlog-test 0.1.0]   e: M
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/distr_lattice.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/distr_lattice.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 7 | Axiom x: El => Le(x, x);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 8 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 9 | Axiom Le(x, y) & Le(y, x) => x = y;
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 12 | Axiom x: El & y: El => Meet(x, y)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 13 | Axiom meet = Meet(x, y) => Le(meet, x) & Le(meet, y);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 14 | Axiom Le(z, x) & Le(z, y) & meet = Meet(x, y) => Le(z, meet);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Meet(x, y): El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   meet: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 17 | Axiom x: El & y: El => Join(x, y)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Join(x, y): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 18 | Axiom join = Join(x, y) => Le(x, join) & Le(y, join);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   join: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Join(x, y): El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   join: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   join: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 19 | Axiom Le(x, z) & Le(y, z) & join = Join(x, y) => Le(join, z);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   join: El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Join(x, y): El
[eqlog-test 0.1.0]   join: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 22 | Axiom Join(x, Meet(y, z)) <~> Meet(Join(x, y), Join(x, z));
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   Meet(y, z): El
[eqlog-test 0.1.0]   Join(x, Meet(y, z)): El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   y: El
[eqlog-test 0.1.0]   Join(x, y): El
[eqlog-test 0.1.0]   x: El
[eqlog-test 0.1.0]   z: El
[eqlog-test 0.1.0]   Join(x, z): El
[eqlog-test 0.1.0]   Meet(Join(x, y), Join(x, z)): El
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/trans_refl.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/trans_refl.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 7 | Axiom x: V => Edge(x, x);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: V
[eqlog-test 0.1.0]   x: V
[eqlog-test 0.1.0]   x: V
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 8 | Axiom Edge(x, y) & Edge(y, z) => Edge(x, z);
[eqlog-test 0.1.0]   | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: V
[eqlog-test 0.1.0]   y: V
[eqlog-test 0.1.0]   y: V
[eqlog-test 0.1.0]   z: V
[eqlog-test 0.1.0]   x: V
[eqlog-test 0.1.0]   z: V
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Compiling "src/finite-products.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/finite-products.rs"
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 20 | Axiom f: Mor => Dom(f)! & Cod(f)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Dom(f): Obj
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Cod(f): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 23 | Axiom x: Obj => Id(x)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   Id(x): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 26 | Axiom Cod(f) = Dom(g) => Comp(g, f)!;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Cod(f): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   Dom(g): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Comp(g, f): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 27 | Axiom Comp(g, f)! => Dom(f) <~> Cod(g);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Comp(g, f): Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Dom(f): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   Cod(g): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 30 | Axiom Dom(Id(x)) ~> x;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   Id(x): Mor
[eqlog-test 0.1.0]   Dom(Id(x)): Obj
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 31 | Axiom Cod(Id(x)) ~> x;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0]   Id(x): Mor
[eqlog-test 0.1.0]   Cod(Id(x)): Obj
[eqlog-test 0.1.0]   x: Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 34 | Axiom Dom(Comp(_, f)) ~> Dom(f);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   _0: Mor
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Comp(_0, f): Mor
[eqlog-test 0.1.0]   Dom(Comp(_0, f)): Obj
[eqlog-test 0.1.0]   f: Mor
[eqlog-test 0.1.0]   Dom(f): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 35 | Axiom Cod(Comp(g, _)) ~> Cod(g);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   _1: Mor
[eqlog-test 0.1.0]   Comp(g, _1): Mor
[eqlog-test 0.1.0]   Cod(Comp(g, _1)): Obj
[eqlog-test 0.1.0]   g: Mor
[eqlog-test 0.1.0]   Cod(g): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 38 | Axiom
[eqlog-test 0.1.0] 39 |   & prod: Prod
[eqlog-test 0.1.0] 40 |   =>
[eqlog-test 0.1.0] 41 |   & Left(prod)!
[eqlog-test 0.1.0] 42 |   & Right(prod)!
[eqlog-test 0.1.0] 43 |   & ProdObj(prod)!
[eqlog-test 0.1.0] 44 |   & LeftProj(prod)!
[eqlog-test 0.1.0] 45 |   & RightProj(prod)!
[eqlog-test 0.1.0] 46 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Left(prod): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Right(prod): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   ProdObj(prod): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   LeftProj(prod): Mor
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   RightProj(prod): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 49 | Axiom
[eqlog-test 0.1.0] 50 |   & Left(prod_0) = Left(prod_1)
[eqlog-test 0.1.0] 51 |   & Right(prod_0) = Right(prod_1)
[eqlog-test 0.1.0] 52 |   & ProdObj(prod_0) = ProdObj(prod_1)
[eqlog-test 0.1.0] 53 |   & LeftProj(prod_0) = LeftProj(prod_1)
[eqlog-test 0.1.0] 54 |   & RightProj(prod_0) = RightProj(prod_1)
[eqlog-test 0.1.0] 55 |   =>
[eqlog-test 0.1.0] 56 |   prod_0 = prod_1
[eqlog-test 0.1.0] 57 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   Left(prod_0): Obj
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0]   Left(prod_1): Obj
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   Right(prod_0): Obj
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0]   Right(prod_1): Obj
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   ProdObj(prod_0): Obj
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0]   ProdObj(prod_1): Obj
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   LeftProj(prod_0): Mor
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0]   LeftProj(prod_1): Mor
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   RightProj(prod_0): Mor
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0]   RightProj(prod_1): Mor
[eqlog-test 0.1.0]   prod_0: Prod
[eqlog-test 0.1.0]   prod_1: Prod
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 60 | Axiom
[eqlog-test 0.1.0] 61 |   & Dom(l) = Dom(r)
[eqlog-test 0.1.0] 62 |   & Cod(l) = Left(prod)
[eqlog-test 0.1.0] 63 |   & Cod(r) = Right(prod)
[eqlog-test 0.1.0] 64 |   =>
[eqlog-test 0.1.0] 65 |   & Tuple(prod, l, r)!
[eqlog-test 0.1.0] 66 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Dom(l): Obj
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Dom(r): Obj
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Cod(l): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Left(prod): Obj
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Cod(r): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Right(prod): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Tuple(prod, l, r): Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 67 | Axiom
[eqlog-test 0.1.0] 68 |   & Tuple(prod, l, r)!
[eqlog-test 0.1.0] 69 |   & Dom(l)! & Dom(r)! & Cod(l)! & Left(prod)! & Right(prod)!
[eqlog-test 0.1.0] 70 |   =>
[eqlog-test 0.1.0] 71 |   & Dom(l) = Dom(r)
[eqlog-test 0.1.0] 72 |   & Cod(l) = Left(prod)
[eqlog-test 0.1.0] 73 |   & Cod(r) = Right(prod)
[eqlog-test 0.1.0] 74 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Tuple(prod, l, r): Mor
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Dom(l): Obj
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Dom(r): Obj
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Cod(l): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Left(prod): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Right(prod): Obj
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Dom(l): Obj
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Dom(r): Obj
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Cod(l): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Left(prod): Obj
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Cod(r): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   Right(prod): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 77 | Axiom Dom(Tuple(_, l, _)) ~> Dom(l);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   _0: Prod
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   _2: Mor
[eqlog-test 0.1.0]   Tuple(_0, l, _2): Mor
[eqlog-test 0.1.0]   Dom(Tuple(_0, l, _2)): Obj
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   Dom(l): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 78 | Axiom Cod(Tuple(prod, _, _)) ~> ProdObj(prod);
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   _1: Mor
[eqlog-test 0.1.0]   _2: Mor
[eqlog-test 0.1.0]   Tuple(prod, _1, _2): Mor
[eqlog-test 0.1.0]   Cod(Tuple(prod, _1, _2)): Obj
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   ProdObj(prod): Obj
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 81 | Axiom Comp(Tuple(prod, l, _), LeftProj(prod)) ~> l;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   _2: Mor
[eqlog-test 0.1.0]   Tuple(prod, l, _2): Mor
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   LeftProj(prod): Mor
[eqlog-test 0.1.0]   Comp(Tuple(prod, l, _2), LeftProj(prod)): Mor
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 82 | Axiom Comp(Tuple(prod, _, r), RightProj(prod)) ~> r;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   _1: Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Tuple(prod, _1, r): Mor
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   RightProj(prod): Mor
[eqlog-test 0.1.0]   Comp(Tuple(prod, _1, r), RightProj(prod)): Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 85 | Axiom
[eqlog-test 0.1.0] 86 |   & Comp(LeftProj(prod), u) = l
[eqlog-test 0.1.0] 87 |   & Comp(RightProj(prod), u) = r
[eqlog-test 0.1.0] 88 |   =>
[eqlog-test 0.1.0] 89 | 	Tuple(prod, l, r) ~> u
[eqlog-test 0.1.0] 90 |   ;
[eqlog-test 0.1.0]    | 
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] Inferred sorts:
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   LeftProj(prod): Mor
[eqlog-test 0.1.0]   u: Mor
[eqlog-test 0.1.0]   Comp(LeftProj(prod), u): Mor
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   RightProj(prod): Mor
[eqlog-test 0.1.0]   u: Mor
[eqlog-test 0.1.0]   Comp(RightProj(prod), u): Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   prod: Prod
[eqlog-test 0.1.0]   l: Mor
[eqlog-test 0.1.0]   r: Mor
[eqlog-test 0.1.0]   Tuple(prod, l, r): Mor
[eqlog-test 0.1.0]   u: Mor
[eqlog-test 0.1.0] --------------------------------------------------------------------------------
[eqlog-test 0.1.0] 
[eqlog-test 0.1.0] thread 'main' panicked at 'assertion failed: `(left == right)`
[eqlog-test 0.1.0]   left: `"Mor"`,
[eqlog-test 0.1.0]  right: `"Prod"`', eqlog/src/flat_to_llam.rs:93:13
[eqlog-test 0.1.0] stack backtrace:
[eqlog-test 0.1.0]    0: rust_begin_unwind
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/std/src/panicking.rs:584:5
[eqlog-test 0.1.0]    1: core::panicking::panic_fmt
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:143:14
[eqlog-test 0.1.0]    2: core::panicking::assert_failed_inner
[eqlog-test 0.1.0]    3: core::panicking::assert_failed
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:182:5
[eqlog-test 0.1.0]    4: eqlog::flat_to_llam::translate_action_atom
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:93:13
[eqlog-test 0.1.0]    5: eqlog::flat_to_llam::lower_sequent_seminaive::{{closure}}
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:254:21
[eqlog-test 0.1.0]    6: core::iter::adapters::map::map_fold::{{closure}}
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:84:28
[eqlog-test 0.1.0]    7: core::iter::traits::iterator::Iterator::fold
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:2362:21
[eqlog-test 0.1.0]    8: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:124:9
[eqlog-test 0.1.0]    9: core::iter::traits::iterator::Iterator::for_each
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:779:9
[eqlog-test 0.1.0]   10: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_extend.rs:40:17
[eqlog-test 0.1.0]   11: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_from_iter_nested.rs:62:9
[eqlog-test 0.1.0]   12: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_from_iter.rs:33:9
[eqlog-test 0.1.0]   13: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2554:9
[eqlog-test 0.1.0]   14: core::iter::traits::iterator::Iterator::collect
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:1784:9
[eqlog-test 0.1.0]   15: eqlog::flat_to_llam::lower_sequent_seminaive
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:251:35
[eqlog-test 0.1.0]   16: eqlog::build::process_file::{{closure}}
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/build.rs:102:48
[eqlog-test 0.1.0]   17: core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/ops/function.rs:280:13
[eqlog-test 0.1.0]   18: core::option::Option<T>::map
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/option.rs:912:29
[eqlog-test 0.1.0]   19: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:103:9
[eqlog-test 0.1.0]   20: alloc::vec::Vec<T,A>::extend_desugared
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2651:35
[eqlog-test 0.1.0]   21: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_extend.rs:18:9
[eqlog-test 0.1.0]   22: <alloc::vec::Vec<T,A> as core::iter::traits::collect::Extend<T>>::extend
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2625:9
[eqlog-test 0.1.0]   23: eqlog::build::process_file
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/build.rs:101:5
[eqlog-test 0.1.0]   24: eqlog::build::process_root
[eqlog-test 0.1.0]              at /home/mbid/work/exp-epa/eqlog/src/build.rs:187:27
[eqlog-test 0.1.0]   25: build_script_build::main
[eqlog-test 0.1.0]              at ./build.rs:2:5
[eqlog-test 0.1.0]   26: core::ops::function::FnOnce::call_once
[eqlog-test 0.1.0]              at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/ops/function.rs:227:5
[eqlog-test 0.1.0] note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
[0m[0m[1m[31merror[0m[1m:[0m failed to run custom build command for `eqlog-test v0.1.0 (/home/mbid/work/exp-epa/eqlog/eqlog-test)`

Caused by:
  process didn't exit successfully: `/home/mbid/work/exp-epa/target/debug/build/eqlog-test-136af4432db86cd3/build-script-build` (exit status: 101)
  --- stdout
  Compiling "src/equational_monoid.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/equational_monoid.rs"
  --------------------------------------------------------------------------------
    | 
  5 | Axiom Mul(x, E()) ~> x;
    | 

  Inferred sorts:
    x: M
    E(): M
    Mul(x, E()): M
    x: M
  --------------------------------------------------------------------------------
    | 
  6 | Axiom Mul(E(), x) ~> x;
    | 

  Inferred sorts:
    E(): M
    x: M
    Mul(E(), x): M
    x: M
  --------------------------------------------------------------------------------
    | 
  7 | Axiom Mul(Mul(a, b), c) <~> Mul(a, Mul(b, c));
    | 

  Inferred sorts:
    a: M
    b: M
    Mul(a, b): M
    c: M
    Mul(Mul(a, b), c): M
    a: M
    b: M
    c: M
    Mul(b, c): M
    Mul(a, Mul(b, c)): M
  --------------------------------------------------------------------------------

  Compiling "src/trivial_idempotent.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/trivial_idempotent.rs"
  --------------------------------------------------------------------------------
     | 
   6 | Axiom
   7 |   & a = Mul(a, a)
   8 |   & E()!
   9 |   =>
  10 |   & a = E()
  11 |   ;
     | 

  Inferred sorts:
    a: M
    a: M
    a: M
    Mul(a, a): M
    E(): M
    a: M
    E(): M
  --------------------------------------------------------------------------------

  Compiling "src/poset.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/poset.rs"
  --------------------------------------------------------------------------------
    | 
  4 | Axiom x : P => Le(x, x);
    | 

  Inferred sorts:
    x: P
    x: P
    x: P
  --------------------------------------------------------------------------------
    | 
  5 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
    | 

  Inferred sorts:
    x: P
    y: P
    y: P
    z: P
    x: P
    z: P
  --------------------------------------------------------------------------------
    | 
  6 | Axiom Le(x, y) & Le(y, x) => x = y;
    | 

  Inferred sorts:
    x: P
    y: P
    y: P
    x: P
    x: P
    y: P
  --------------------------------------------------------------------------------

  Compiling "src/logic.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/logic.rs"
  --------------------------------------------------------------------------------
    | 
  5 | Axiom Truth();
    | 

  Inferred sorts:
  --------------------------------------------------------------------------------
    | 
  6 | Axiom Absurd() => Undetermined();
    | 

  Inferred sorts:
  --------------------------------------------------------------------------------

  Compiling "src/group.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/group.rs"
  --------------------------------------------------------------------------------
    | 
  8 | Axiom x: El & y: El => Mul(x, y)!;
    | 

  Inferred sorts:
    x: El
    y: El
    x: El
    y: El
    Mul(x, y): El
  --------------------------------------------------------------------------------
    | 
  9 | Axiom Id()!;
    | 

  Inferred sorts:
    Id(): El
  --------------------------------------------------------------------------------
     | 
  10 | Axiom x: El => Inv(x)!;
     | 

  Inferred sorts:
    x: El
    x: El
    Inv(x): El
  --------------------------------------------------------------------------------
     | 
  13 | Axiom Mul(Mul(x, y), z) <~> Mul(x, Mul(y, z));
     | 

  Inferred sorts:
    x: El
    y: El
    Mul(x, y): El
    z: El
    Mul(Mul(x, y), z): El
    x: El
    y: El
    z: El
    Mul(y, z): El
    Mul(x, Mul(y, z)): El
  --------------------------------------------------------------------------------
     | 
  16 | Axiom Mul(x, Id()) ~> x;
     | 

  Inferred sorts:
    x: El
    Id(): El
    Mul(x, Id()): El
    x: El
  --------------------------------------------------------------------------------
     | 
  19 | Axiom Mul(x, Inv(x)) <~> Id();
     | 

  Inferred sorts:
    x: El
    x: El
    Inv(x): El
    Mul(x, Inv(x)): El
    Id(): El
  --------------------------------------------------------------------------------

  Compiling "src/semilattice.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/semilattice.rs"
  --------------------------------------------------------------------------------
    | 
  6 | Axiom x: El => Le(x, x);
    | 

  Inferred sorts:
    x: El
    x: El
    x: El
  --------------------------------------------------------------------------------
    | 
  7 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
    | 

  Inferred sorts:
    x: El
    y: El
    y: El
    z: El
    x: El
    z: El
  --------------------------------------------------------------------------------
    | 
  8 | Axiom Le(x, y) & Le(y, x) => x = y;
    | 

  Inferred sorts:
    x: El
    y: El
    y: El
    x: El
    x: El
    y: El
  --------------------------------------------------------------------------------
     | 
  11 | Axiom x: El & y: El => Meet(x, y)!;
     | 

  Inferred sorts:
    x: El
    y: El
    x: El
    y: El
    Meet(x, y): El
  --------------------------------------------------------------------------------
     | 
  12 | Axiom meet = Meet(x, y) => Le(meet, x) & Le(meet, y);
     | 

  Inferred sorts:
    meet: El
    x: El
    y: El
    Meet(x, y): El
    meet: El
    x: El
    meet: El
    y: El
  --------------------------------------------------------------------------------
     | 
  13 | Axiom Le(z, x) & Le(z, y) & meet = Meet(x, y) => Le(z, meet);
     | 

  Inferred sorts:
    z: El
    x: El
    z: El
    y: El
    meet: El
    x: El
    y: El
    Meet(x, y): El
    z: El
    meet: El
  --------------------------------------------------------------------------------

  Compiling "src/pointed.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/pointed.rs"
  --------------------------------------------------------------------------------
    | 
  3 | Axiom Pt()!;
    | 

  Inferred sorts:
    Pt(): P
  --------------------------------------------------------------------------------

  Compiling "src/category_mod/category.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/category_mod/category.rs"
  --------------------------------------------------------------------------------
    | 
  9 | Axiom Cod(f) = Dom(g) => Comp(g, f)!;
    | 

  Inferred sorts:
    f: Mor
    Cod(f): Obj
    g: Mor
    Dom(g): Obj
    g: Mor
    f: Mor
    Comp(g, f): Mor
  --------------------------------------------------------------------------------
     | 
  10 | Axiom h = Comp(_, f) & d = Dom(f) => Dom(h) = d;
     | 

  Inferred sorts:
    h: Mor
    _1: Mor
    f: Mor
    Comp(_1, f): Mor
    d: Obj
    f: Mor
    Dom(f): Obj
    h: Mor
    Dom(h): Obj
    d: Obj
  --------------------------------------------------------------------------------
     | 
  11 | Axiom h = Comp(g, _) & c = Cod(g) => Cod(h) = c;
     | 

  Inferred sorts:
    h: Mor
    g: Mor
    _2: Mor
    Comp(g, _2): Mor
    c: Obj
    g: Mor
    Cod(g): Obj
    h: Mor
    Cod(h): Obj
    c: Obj
  --------------------------------------------------------------------------------
     | 
  12 | Axiom x : Obj & y : Obj => Id(x)! & Id(y)!;
     | 

  Inferred sorts:
    x: Obj
    y: Obj
    x: Obj
    Id(x): Mor
    y: Obj
    Id(y): Mor
  --------------------------------------------------------------------------------

  Compiling "src/monoid.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/monoid.rs"
  --------------------------------------------------------------------------------
    | 
  7 | Axiom E()!;
    | 

  Inferred sorts:
    E(): M
  --------------------------------------------------------------------------------
    | 
  8 | Axiom x: M & y: M => Mul(x, y)!;
    | 

  Inferred sorts:
    x: M
    y: M
    x: M
    y: M
    Mul(x, y): M
  --------------------------------------------------------------------------------
    | 
  9 | Axiom y = Mul(x, E()) => x = y;
    | 

  Inferred sorts:
    y: M
    x: M
    E(): M
    Mul(x, E()): M
    x: M
    y: M
  --------------------------------------------------------------------------------
     | 
  10 | Axiom y = Mul(E(), x) => x = y;
     | 

  Inferred sorts:
    y: M
    E(): M
    x: M
    Mul(E(), x): M
    x: M
    y: M
  --------------------------------------------------------------------------------
     | 
  11 | Axiom d = Mul(Mul(a, b), c) & e = Mul(a, Mul(b, c)) => d = e;
     | 

  Inferred sorts:
    d: M
    a: M
    b: M
    Mul(a, b): M
    c: M
    Mul(Mul(a, b), c): M
    e: M
    a: M
    b: M
    c: M
    Mul(b, c): M
    Mul(a, Mul(b, c)): M
    d: M
    e: M
  --------------------------------------------------------------------------------

  Compiling "src/distr_lattice.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/distr_lattice.rs"
  --------------------------------------------------------------------------------
    | 
  7 | Axiom x: El => Le(x, x);
    | 

  Inferred sorts:
    x: El
    x: El
    x: El
  --------------------------------------------------------------------------------
    | 
  8 | Axiom Le(x, y) & Le(y, z) => Le(x, z);
    | 

  Inferred sorts:
    x: El
    y: El
    y: El
    z: El
    x: El
    z: El
  --------------------------------------------------------------------------------
    | 
  9 | Axiom Le(x, y) & Le(y, x) => x = y;
    | 

  Inferred sorts:
    x: El
    y: El
    y: El
    x: El
    x: El
    y: El
  --------------------------------------------------------------------------------
     | 
  12 | Axiom x: El & y: El => Meet(x, y)!;
     | 

  Inferred sorts:
    x: El
    y: El
    x: El
    y: El
    Meet(x, y): El
  --------------------------------------------------------------------------------
     | 
  13 | Axiom meet = Meet(x, y) => Le(meet, x) & Le(meet, y);
     | 

  Inferred sorts:
    meet: El
    x: El
    y: El
    Meet(x, y): El
    meet: El
    x: El
    meet: El
    y: El
  --------------------------------------------------------------------------------
     | 
  14 | Axiom Le(z, x) & Le(z, y) & meet = Meet(x, y) => Le(z, meet);
     | 

  Inferred sorts:
    z: El
    x: El
    z: El
    y: El
    meet: El
    x: El
    y: El
    Meet(x, y): El
    z: El
    meet: El
  --------------------------------------------------------------------------------
     | 
  17 | Axiom x: El & y: El => Join(x, y)!;
     | 

  Inferred sorts:
    x: El
    y: El
    x: El
    y: El
    Join(x, y): El
  --------------------------------------------------------------------------------
     | 
  18 | Axiom join = Join(x, y) => Le(x, join) & Le(y, join);
     | 

  Inferred sorts:
    join: El
    x: El
    y: El
    Join(x, y): El
    x: El
    join: El
    y: El
    join: El
  --------------------------------------------------------------------------------
     | 
  19 | Axiom Le(x, z) & Le(y, z) & join = Join(x, y) => Le(join, z);
     | 

  Inferred sorts:
    x: El
    z: El
    y: El
    z: El
    join: El
    x: El
    y: El
    Join(x, y): El
    join: El
    z: El
  --------------------------------------------------------------------------------
     | 
  22 | Axiom Join(x, Meet(y, z)) <~> Meet(Join(x, y), Join(x, z));
     | 

  Inferred sorts:
    x: El
    y: El
    z: El
    Meet(y, z): El
    Join(x, Meet(y, z)): El
    x: El
    y: El
    Join(x, y): El
    x: El
    z: El
    Join(x, z): El
    Meet(Join(x, y), Join(x, z)): El
  --------------------------------------------------------------------------------

  Compiling "src/trans_refl.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/trans_refl.rs"
  --------------------------------------------------------------------------------
    | 
  7 | Axiom x: V => Edge(x, x);
    | 

  Inferred sorts:
    x: V
    x: V
    x: V
  --------------------------------------------------------------------------------
    | 
  8 | Axiom Edge(x, y) & Edge(y, z) => Edge(x, z);
    | 

  Inferred sorts:
    x: V
    y: V
    y: V
    z: V
    x: V
    z: V
  --------------------------------------------------------------------------------

  Compiling "src/finite-products.eqlog" into "/home/mbid/work/exp-epa/target/debug/build/eqlog-test-b48251657a891b19/out/finite-products.rs"
  --------------------------------------------------------------------------------
     | 
  20 | Axiom f: Mor => Dom(f)! & Cod(f)!;
     | 

  Inferred sorts:
    f: Mor
    f: Mor
    Dom(f): Obj
    f: Mor
    Cod(f): Obj
  --------------------------------------------------------------------------------
     | 
  23 | Axiom x: Obj => Id(x)!;
     | 

  Inferred sorts:
    x: Obj
    x: Obj
    Id(x): Mor
  --------------------------------------------------------------------------------
     | 
  26 | Axiom Cod(f) = Dom(g) => Comp(g, f)!;
     | 

  Inferred sorts:
    f: Mor
    Cod(f): Obj
    g: Mor
    Dom(g): Obj
    g: Mor
    f: Mor
    Comp(g, f): Mor
  --------------------------------------------------------------------------------
     | 
  27 | Axiom Comp(g, f)! => Dom(f) <~> Cod(g);
     | 

  Inferred sorts:
    g: Mor
    f: Mor
    Comp(g, f): Mor
    f: Mor
    Dom(f): Obj
    g: Mor
    Cod(g): Obj
  --------------------------------------------------------------------------------
     | 
  30 | Axiom Dom(Id(x)) ~> x;
     | 

  Inferred sorts:
    x: Obj
    Id(x): Mor
    Dom(Id(x)): Obj
    x: Obj
  --------------------------------------------------------------------------------
     | 
  31 | Axiom Cod(Id(x)) ~> x;
     | 

  Inferred sorts:
    x: Obj
    Id(x): Mor
    Cod(Id(x)): Obj
    x: Obj
  --------------------------------------------------------------------------------
     | 
  34 | Axiom Dom(Comp(_, f)) ~> Dom(f);
     | 

  Inferred sorts:
    _0: Mor
    f: Mor
    Comp(_0, f): Mor
    Dom(Comp(_0, f)): Obj
    f: Mor
    Dom(f): Obj
  --------------------------------------------------------------------------------
     | 
  35 | Axiom Cod(Comp(g, _)) ~> Cod(g);
     | 

  Inferred sorts:
    g: Mor
    _1: Mor
    Comp(g, _1): Mor
    Cod(Comp(g, _1)): Obj
    g: Mor
    Cod(g): Obj
  --------------------------------------------------------------------------------
     | 
  38 | Axiom
  39 |   & prod: Prod
  40 |   =>
  41 |   & Left(prod)!
  42 |   & Right(prod)!
  43 |   & ProdObj(prod)!
  44 |   & LeftProj(prod)!
  45 |   & RightProj(prod)!
  46 |   ;
     | 

  Inferred sorts:
    prod: Prod
    prod: Prod
    Left(prod): Obj
    prod: Prod
    Right(prod): Obj
    prod: Prod
    ProdObj(prod): Obj
    prod: Prod
    LeftProj(prod): Mor
    prod: Prod
    RightProj(prod): Mor
  --------------------------------------------------------------------------------
     | 
  49 | Axiom
  50 |   & Left(prod_0) = Left(prod_1)
  51 |   & Right(prod_0) = Right(prod_1)
  52 |   & ProdObj(prod_0) = ProdObj(prod_1)
  53 |   & LeftProj(prod_0) = LeftProj(prod_1)
  54 |   & RightProj(prod_0) = RightProj(prod_1)
  55 |   =>
  56 |   prod_0 = prod_1
  57 |   ;
     | 

  Inferred sorts:
    prod_0: Prod
    Left(prod_0): Obj
    prod_1: Prod
    Left(prod_1): Obj
    prod_0: Prod
    Right(prod_0): Obj
    prod_1: Prod
    Right(prod_1): Obj
    prod_0: Prod
    ProdObj(prod_0): Obj
    prod_1: Prod
    ProdObj(prod_1): Obj
    prod_0: Prod
    LeftProj(prod_0): Mor
    prod_1: Prod
    LeftProj(prod_1): Mor
    prod_0: Prod
    RightProj(prod_0): Mor
    prod_1: Prod
    RightProj(prod_1): Mor
    prod_0: Prod
    prod_1: Prod
  --------------------------------------------------------------------------------
     | 
  60 | Axiom
  61 |   & Dom(l) = Dom(r)
  62 |   & Cod(l) = Left(prod)
  63 |   & Cod(r) = Right(prod)
  64 |   =>
  65 |   & Tuple(prod, l, r)!
  66 |   ;
     | 

  Inferred sorts:
    l: Mor
    Dom(l): Obj
    r: Mor
    Dom(r): Obj
    l: Mor
    Cod(l): Obj
    prod: Prod
    Left(prod): Obj
    r: Mor
    Cod(r): Obj
    prod: Prod
    Right(prod): Obj
    prod: Prod
    l: Mor
    r: Mor
    Tuple(prod, l, r): Mor
  --------------------------------------------------------------------------------
     | 
  67 | Axiom
  68 |   & Tuple(prod, l, r)!
  69 |   & Dom(l)! & Dom(r)! & Cod(l)! & Left(prod)! & Right(prod)!
  70 |   =>
  71 |   & Dom(l) = Dom(r)
  72 |   & Cod(l) = Left(prod)
  73 |   & Cod(r) = Right(prod)
  74 |   ;
     | 

  Inferred sorts:
    prod: Prod
    l: Mor
    r: Mor
    Tuple(prod, l, r): Mor
    l: Mor
    Dom(l): Obj
    r: Mor
    Dom(r): Obj
    l: Mor
    Cod(l): Obj
    prod: Prod
    Left(prod): Obj
    prod: Prod
    Right(prod): Obj
    l: Mor
    Dom(l): Obj
    r: Mor
    Dom(r): Obj
    l: Mor
    Cod(l): Obj
    prod: Prod
    Left(prod): Obj
    r: Mor
    Cod(r): Obj
    prod: Prod
    Right(prod): Obj
  --------------------------------------------------------------------------------
     | 
  77 | Axiom Dom(Tuple(_, l, _)) ~> Dom(l);
     | 

  Inferred sorts:
    _0: Prod
    l: Mor
    _2: Mor
    Tuple(_0, l, _2): Mor
    Dom(Tuple(_0, l, _2)): Obj
    l: Mor
    Dom(l): Obj
  --------------------------------------------------------------------------------
     | 
  78 | Axiom Cod(Tuple(prod, _, _)) ~> ProdObj(prod);
     | 

  Inferred sorts:
    prod: Prod
    _1: Mor
    _2: Mor
    Tuple(prod, _1, _2): Mor
    Cod(Tuple(prod, _1, _2)): Obj
    prod: Prod
    ProdObj(prod): Obj
  --------------------------------------------------------------------------------
     | 
  81 | Axiom Comp(Tuple(prod, l, _), LeftProj(prod)) ~> l;
     | 

  Inferred sorts:
    prod: Prod
    l: Mor
    _2: Mor
    Tuple(prod, l, _2): Mor
    prod: Prod
    LeftProj(prod): Mor
    Comp(Tuple(prod, l, _2), LeftProj(prod)): Mor
    l: Mor
  --------------------------------------------------------------------------------
     | 
  82 | Axiom Comp(Tuple(prod, _, r), RightProj(prod)) ~> r;
     | 

  Inferred sorts:
    prod: Prod
    _1: Mor
    r: Mor
    Tuple(prod, _1, r): Mor
    prod: Prod
    RightProj(prod): Mor
    Comp(Tuple(prod, _1, r), RightProj(prod)): Mor
    r: Mor
  --------------------------------------------------------------------------------
     | 
  85 | Axiom
  86 |   & Comp(LeftProj(prod), u) = l
  87 |   & Comp(RightProj(prod), u) = r
  88 |   =>
  89 | 	Tuple(prod, l, r) ~> u
  90 |   ;
     | 

  Inferred sorts:
    prod: Prod
    LeftProj(prod): Mor
    u: Mor
    Comp(LeftProj(prod), u): Mor
    l: Mor
    prod: Prod
    RightProj(prod): Mor
    u: Mor
    Comp(RightProj(prod), u): Mor
    r: Mor
    prod: Prod
    l: Mor
    r: Mor
    Tuple(prod, l, r): Mor
    u: Mor
  --------------------------------------------------------------------------------


  --- stderr
  thread 'main' panicked at 'assertion failed: `(left == right)`
    left: `"Mor"`,
   right: `"Prod"`', eqlog/src/flat_to_llam.rs:93:13
  stack backtrace:
     0: rust_begin_unwind
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/std/src/panicking.rs:584:5
     1: core::panicking::panic_fmt
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:143:14
     2: core::panicking::assert_failed_inner
     3: core::panicking::assert_failed
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:182:5
     4: eqlog::flat_to_llam::translate_action_atom
               at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:93:13
     5: eqlog::flat_to_llam::lower_sequent_seminaive::{{closure}}
               at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:254:21
     6: core::iter::adapters::map::map_fold::{{closure}}
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:84:28
     7: core::iter::traits::iterator::Iterator::fold
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:2362:21
     8: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:124:9
     9: core::iter::traits::iterator::Iterator::for_each
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:779:9
    10: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_extend.rs:40:17
    11: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter_nested::SpecFromIterNested<T,I>>::from_iter
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_from_iter_nested.rs:62:9
    12: <alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_from_iter.rs:33:9
    13: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2554:9
    14: core::iter::traits::iterator::Iterator::collect
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/traits/iterator.rs:1784:9
    15: eqlog::flat_to_llam::lower_sequent_seminaive
               at /home/mbid/work/exp-epa/eqlog/src/flat_to_llam.rs:251:35
    16: eqlog::build::process_file::{{closure}}
               at /home/mbid/work/exp-epa/eqlog/src/build.rs:102:48
    17: core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/ops/function.rs:280:13
    18: core::option::Option<T>::map
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/option.rs:912:29
    19: <core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/iter/adapters/map.rs:103:9
    20: alloc::vec::Vec<T,A>::extend_desugared
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2651:35
    21: <alloc::vec::Vec<T,A> as alloc::vec::spec_extend::SpecExtend<T,I>>::spec_extend
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/spec_extend.rs:18:9
    22: <alloc::vec::Vec<T,A> as core::iter::traits::collect::Extend<T>>::extend
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/alloc/src/vec/mod.rs:2625:9
    23: eqlog::build::process_file
               at /home/mbid/work/exp-epa/eqlog/src/build.rs:101:5
    24: eqlog::build::process_root
               at /home/mbid/work/exp-epa/eqlog/src/build.rs:187:27
    25: build_script_build::main
               at ./build.rs:2:5
    26: core::ops::function::FnOnce::call_once
               at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/ops/function.rs:227:5
  note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
