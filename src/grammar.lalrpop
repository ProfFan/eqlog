use std::str::FromStr;
use crate::ast::{Def, Tm, Ty};

grammar;

pub Id: String = r"[A-Za-z_][A-Za-z0-9'_]*" => <>.to_string();

pub Unit: Vec<Def> =
    Def* => <>;

pub Def: Def = {
    "def" <DefBody> "." => <>,
    "unit_ind" <UnitIndBody> "." => <>,
    "dump" "." => Def::Dump,
}

pub DefBody: Def =
    <name: Id> <args: Args> ":" <ty: Ty> ":=" <tm: Tm> => Def::Def { <> };

pub UnitIndBody: Def = {
    <name: Id> "(" <var: Id> ":" "Unit" ")" ":" <into_ty: Ty>
    "|" "unit" "=>" <unit_case: Tm>
    => Def::UnitInd { <> }
}

pub Args: Vec<(String, Ty)> =
    ("(" <Id+> ":" <Ty> ")")*
    => <>.into_iter()
         .flat_map(
             |(names, ty)|
             names.into_iter()
                  .map(move |name| (name, ty.clone())))
         .collect();

pub Ty: Ty = {
    "(" <Ty> ")" => <>,
    "Unit" => Ty::Unit,
    <left: Tm> "=" <right: Tm> =>
        Ty::Eq(Box::new(left), Box::new(right)),
};

RevArgList : Vec<Tm> = {
    "" => Vec::new(),
    <tm: Tm> => vec![tm],
    <head: Tm> "," <mut tail: RevArgList> => {
        tail.push(head);
        tail
    },
};

pub Tm: Tm = {
    "(" <Tm> ")" => <>,
    "(" <tm: Tm> ":" <ty: Ty> ")" => {
        let tm = Box::new(tm);
        let ty = Box::new(ty);
        Tm::Typed { tm, ty }
    },
    "let" <body: Def*> "in" <result: Tm> =>
        Tm::Let { body,
                  result: Box::new(result) },
    "refl" <tm: Tm> => Tm::Refl(Box::new(tm)),
    "unit" => Tm::UnitTm,
    <var: Id> => Tm::Variable(var),
    <fun: Id> "(" <mut args: RevArgList> ")" => {
        args.reverse();
        Tm::App { fun, args}
    }
};
