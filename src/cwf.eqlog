Sort Ctx;
Sort Mor;

Func Dom: Mor -> Ctx;
Func Cod: Mor -> Ctx;
Func Comp: Mor * Mor -> Mor;
Func Id: Ctx -> Mor;

Axiom ctx!: Ctx => Id(ctx)!;
Axiom Dom(Id(ctx)) ~> ctx;
Axiom Cod(Id(ctx)) ~> ctx;
Axiom Dom(Comp(_, f)) ~> Dom(f);
Axiom Cod(Comp(g, _)) ~> Cod(g);

Axiom Comp(f, Id(Dom(f))) ~> f;
Axiom Comp(Id(Cod(f)), f) ~> f;

Axiom Comp(h, Comp(g, f)) ~> Comp(Comp(h, g), f);
Axiom Comp(Comp(h, g), f) ~> Comp(h, Comp(g, f));

Sort Ty;
Sort Tm;

Func TyCtx : Ty -> Ctx;
Func TmTy : Tm -> Ty;
Func SubstTy: Mor * Ty-> Ty;
Func SubstTm: Mor * Tm-> Tm;

Axiom TyCtx(SubstTy(f, _)) ~> Cod(f);
Axiom TmTy(SubstTm(f, s)) ~> SubstTy(f, TmTy(s));

Axiom SubstTy(Id(TyCtx(sigma)), sigma) ~> sigma;
Axiom SubstTm(Id(TyCtx(TmTy(s))), s) ~> s;

Axiom SubstTy(Comp(g, f), sigma) ~> SubstTy(g, SubstTy(f, sigma));
Axiom SubstTm(Comp(g, f), s) ~> SubstTm(g, SubstTm(f, s));

Func ExtCtx: Ctx * Ty -> Ctx;
Func Wkn: Ctx * Ty -> Mor;
Func Var: Ctx * Ty -> Tm;
Func MorExt: Ctx * Ty * Mor * Tm -> Mor;

Axiom Dom(Wkn(ctx, _)) ~> ctx;
Axiom Cod(Wkn(ctx, sigma)) ~> ExtCtx(ctx, sigma);
Axiom TmTy(Var(ctx, sigma)) ~> SubstTy(Wkn(ctx, sigma), sigma);
Axiom Dom(MorExt(ctx, sigma, _, _)) ~> ExtCtx(ctx, sigma);
Axiom Cod(MorExt(_, _, f, _)) ~> Cod(f);
Axiom Comp(MorExt(ctx, sigma, f, _), Wkn(ctx, sigma)) ~> f;
Axiom SubstTm(MorExt(ctx, sigma, _, s), Var(ctx, sigma)) ~> s;

// Reduction for composition.
Axiom MorExt(ctx, sigma, Comp(g, f), SubstTm(g, s)) ~> Comp(g, MorExt(ctx, sigma, f, s));

// If an extended context is defined, then also weakening and variable are
// defined.
Axiom ExtCtx(base, sigma)! => Wkn(base, sigma)! & Var(base, sigma)!;

Axiom
	ExtCtx(dom, sigma)! &
	dom = Dom(f) &
	cod = Cod(f) &
	sigma_f = SubstTy(f, sigma) &
	ExtCtx(cod, sigma_f)! &
	cod_wkn = Wkn(cod, sigma_f) &
	var_cod = Var(cod, sigma)
	=>
	Comp(cod_wkn, f)! &
	MorExt(dom, sigma, Comp(cod_wkn, f), var_cod)!
	;

Func Unit: Ctx -> Ty;
Func UnitTm: Ctx -> Tm;
Func UnitInd : Ctx * Ty * Tm -> Tm;

Axiom TyCtx(Unit(ctx)) ~> ctx;
Axiom TmTy(UnitTm(ctx)) ~> Unit(ctx);
Axiom SubstTy(f, Unit(Dom(f))) ~> Unit(Cod(f));
Axiom SubstTm(f, UnitTm(Dom(f))) ~> UnitTm(Cod(f));
Axiom TmTy(UnitInd(_, sigma, _)) ~> sigma;
Axiom
	ind_c = UnitInd(base, _, c) &
	f_unit = MorExt(base, Unit(base), f, UnitTm(Cod(f)))
	=>
	SubstTm(f_unit, ind_c) ~> SubstTm(f, c)
	;
// TODO: Substitution stability of unit ind

Func Bool: Ctx -> Ty;
Func FalseTm: Ctx -> Tm;
Func TrueTm: Ctx -> Tm;
// base ctx, into type, false case, true case
Func BoolInd: Ctx * Ty * Tm * Tm -> Tm;

Axiom TyCtx(Bool(ctx)) ~> ctx;
Axiom TmTy(FalseTm(ctx)) ~> Bool(ctx);
Axiom TmTy(TrueTm(ctx)) ~> Bool(ctx);
Axiom SubstTy(f, Bool(Dom(f))) ~> Bool(Cod(f));
Axiom SubstTm(f, FalseTm(Dom(f))) ~> FalseTm(Cod(f));
Axiom SubstTm(f, TrueTm(Dom(f))) ~> TrueTm(Cod(f));
Axiom TmTy(BoolInd(_, sigma, _, _)) ~> sigma;
// Induction principle for substituting false:
Axiom
	ind = BoolInd(base, _, false_case, _) &
	f_false = MorExt(base, Bool(base), f, FalseTm(Cod(f)))
	=>
	SubstTm(f_false, ind) ~> SubstTm(f, false_case);
// Induction principle for substituting true:
Axiom
	ind = BoolInd(base, _, _, true_case) &
	f_true = MorExt(base, Bool(base), f, TrueTm(Cod(f)))
	=>
	SubstTm(f_true, ind) ~> SubstTm(f, true_case);
// TODO: Substitution stability of bool ind

Func Eq: Tm * Tm -> Ty;
Func Refl: Tm -> Tm;

Axiom Eq(s, t)! & sigma = TmTy(s) & tau = TmTy(t) => sigma = tau;
Axiom TyCtx(Eq(s, _)) ~> TyCtx(TmTy(s));
Axiom TyCtx(Eq(_, t)) ~> TyCtx(TmTy(t));
Axiom SubstTy(f, Eq(s, t)) ~> Eq(SubstTm(f, s), SubstTm(f, t));
Axiom SubstTm(f, Refl(s)) ~> Refl(SubstTm(f, s));
Axiom TmTy(Refl(s)) ~> Eq(s, s);
Axiom TmTy(r) = Eq(s, t) => s = t & r = Refl(s) & r = Refl(t);
