// The category of contexts and morphisms.
Sort Ctx;
Sort Mor;

// Domains and codomains of morphisms.
Func Dom: Mor -> Ctx;
Func Cod: Mor -> Ctx;
// Compositions of morphisms.
Func Comp: Mor * Mor -> Mor;
// Identity morphisms.
Func Id: Ctx -> Mor;

// The identity morphisms is defined at every context.
Axiom ctx! : Ctx => Id(ctx)!;
// Domains and codomains of identity morphisms.
Axiom Dom(Id(ctx)) ~> ctx;
Axiom Cod(Id(ctx)) ~> ctx;
// Domains and codomains of composed morphisms.
Axiom Dom(Comp(_, f)) ~> Dom(f);
Axiom Cod(Comp(g, _)) ~> Cod(g);

// Composition with identity morphisms.
Axiom Comp(f, Id(Dom(f))) ~> f;
Axiom Comp(Id(Cod(f)), f) ~> f;

// // Associativity of composition.
// Axiom Comp(h, Comp(g, f)) ~> Comp(Comp(h, g), f);
// Axiom Comp(Comp(h, g), f) ~> Comp(h, Comp(g, f));

// Types and terms.
Sort Ty;
Sort Tm;

// The context of a type.
Func TyCtx : Ty -> Ctx;
// The type of a term.
Func TmTy : Tm -> Ty;

// Substituting types and terms.
Func SubstTy: Mor * Ty-> Ty;
Func SubstTm: Mor * Tm-> Tm;

// The context of a substituted type.
Axiom TyCtx(SubstTy(f, _)) ~> Cod(f);
// The type of a substituted term.
Axiom TmTy(SubstTm(f, s)) ~> SubstTy(f, TmTy(s));

// Substitution along identity morphisms.
Axiom SubstTy(Id(TyCtx(sigma)), sigma) ~> sigma;
Axiom SubstTm(Id(TyCtx(TmTy(s))), s) ~> s;

// Substitution along composed morphisms.
Axiom SubstTy(Comp(g, f), sigma) ~> SubstTy(g, SubstTy(f, sigma));
Axiom SubstTm(Comp(g, f), s) ~> SubstTm(g, SubstTm(f, s));

// Context extensions by variables of a given type.
Func ExtCtx: Ctx * Ty -> Ctx;
// The corresponding weakenings.
Func Wkn: Ctx * Ty -> Mor;
// The corresponding variable terms.
Func Var: Ctx * Ty -> Tm;
// The extended morphisms induced by the universal property of context extensions.
Func MorExt: Ctx * Ty * Mor * Tm -> Mor;

// If an extended context is defined, then also weakening and variable are defined.
Axiom ExtCtx(base, sigma)! => Wkn(base, sigma)! & Var(base, sigma)!;

// Domains and codomains of weakenings.
Axiom Dom(Wkn(ctx, _)) ~> ctx;
Axiom Cod(Wkn(ctx, sigma)) ~> ExtCtx(ctx, sigma);

// The types of variables.
Axiom TmTy(Var(ctx, sigma)) ~> SubstTy(Wkn(ctx, sigma), sigma);
// Domains and codomains of extended morphisms.
Axiom Dom(MorExt(ctx, sigma, _, _)) ~> ExtCtx(ctx, sigma);
Axiom Cod(MorExt(_, _, f, _)) ~> Cod(f);

// Iterated substitutions.
Axiom SubstTm(g, SubstTm(f, _))! & g = MorExt(_, _, _, _) => Comp(g, f)!;
Axiom SubstTy(g, SubstTy(f, _))! & g = MorExt(_, _, _, _) => Comp(g, f)!;

// The precomposition of an extended morphism.
Axiom Comp(g, MorExt(_, _, f, s))! & SubstTm(g, s)! => Comp(g, f)!;
Axiom h = Comp(g, MorExt(ctx, sigma, f, s)) & Comp(g, f)! & SubstTm(g, s)! => h = MorExt(ctx, sigma, Comp(g, f), SubstTm(g, s));
// The composition of weakening and extended morphisms.
Axiom c = Comp(MorExt(ctx, sigma, f, _), Comp(Wkn(ctx, sigma), q)) => c = Comp(f, q);
// The composition of weakenings.
Axiom c = Comp(Comp(Wkn(ctx, sigma), g), f) => Comp(g, f)! & c = Comp(Wkn(ctx, sigma), Comp(g, f));

// Substituting variables along extended morphisms.
Axiom SubstTm(MorExt(ctx, sigma, _, s), Var(ctx, sigma)) ~> s;

// Uniqueness of extended morphisms.
// TODO: Enough to detect identities?
Axiom
	SubstTm(e, Var(ctx, sigma)) = s &
	Comp(e, Wkn(ctx, sigma)) = f
  =>
	e = MorExt(ctx, sigma, f, s)
	;

// If f : dom -> cod and the extended contexts dom.sigma and cod.f(sigma) are defined, then also
//   <w o f, v> : dom.sigma -> cod.f(sigma)
// is defined.
Axiom
	ExtCtx(dom, sigma)! &
	dom = Dom(f) &
	cod = Cod(f) &
	sigma_f = SubstTy(f, sigma) &
	ExtCtx(cod, sigma_f)! &
	cod_wkn = Wkn(cod, sigma_f) &
	var_cod = Var(cod, sigma)
	=>
	Comp(cod_wkn, f)! &
	MorExt(dom, sigma, Comp(cod_wkn, f), var_cod)!
	;

// The unit type.
Func Unit: Ctx -> Ty;
// The unique term of the unit type.
Func UnitTm: Ctx -> Tm;
// The induction principle for the unit type.
Func UnitInd : Ctx * Ty * Tm -> Tm;

// Context of unit types.
Axiom TyCtx(Unit(ctx)) ~> ctx;
// Types of unit terms.
Axiom TmTy(UnitTm(ctx)) ~> Unit(ctx);
// Substitution stability of unit types.
Axiom SubstTy(f, Unit(Dom(f))) ~> Unit(Cod(f));
// Substitution stability of unit terms.
Axiom SubstTm(f, UnitTm(Dom(f))) ~> UnitTm(Cod(f));
// Type of unit induction terms.
Axiom TmTy(UnitInd(_, sigma, _)) ~> sigma;
// Evaluation rule for unit induction.
Axiom
	ind_c = UnitInd(base, _, c) &
	f_unit = MorExt(base, Unit(base), f, UnitTm(Cod(f)))
	=>
	SubstTm(f_unit, ind_c) ~> SubstTm(f, c)
	;
// TODO: Substitution stability of unit ind

Func Bool: Ctx -> Ty;
Func FalseTm: Ctx -> Tm;
Func TrueTm: Ctx -> Tm;
// base ctx, into type, false case, true case
Func BoolInd: Ctx * Ty * Tm * Tm -> Tm;

Axiom TyCtx(Bool(ctx)) ~> ctx;
Axiom TmTy(FalseTm(ctx)) ~> Bool(ctx);
Axiom TmTy(TrueTm(ctx)) ~> Bool(ctx);
Axiom SubstTy(f, Bool(Dom(f))) ~> Bool(Cod(f));
Axiom SubstTm(f, FalseTm(Dom(f))) ~> FalseTm(Cod(f));
Axiom SubstTm(f, TrueTm(Dom(f))) ~> TrueTm(Cod(f));
Axiom TmTy(BoolInd(_, sigma, _, _)) ~> sigma;
// Evaluation rule for induction on false:
Axiom
	ind = BoolInd(base, _, false_case, _) &
	f_false = MorExt(base, Bool(base), f, FalseTm(Cod(f)))
	=>
	SubstTm(f_false, ind) ~> SubstTm(f, false_case);
// Evaluation rule for induction on true:
Axiom
	ind = BoolInd(base, _, _, true_case) &
	f_true = MorExt(base, Bool(base), f, TrueTm(Cod(f)))
	=>
	SubstTm(f_true, ind) ~> SubstTm(f, true_case);
// TODO: Substitution stability of bool ind

Func Eq: Tm * Tm -> Ty;
Func Refl: Tm -> Tm;

Axiom Eq(s, t)! & sigma = TmTy(s) & tau = TmTy(t) => sigma = tau;
Axiom TyCtx(Eq(s, _)) ~> TyCtx(TmTy(s));
Axiom TyCtx(Eq(_, t)) ~> TyCtx(TmTy(t));
Axiom SubstTy(f, Eq(s, t)) ~> Eq(SubstTm(f, s), SubstTm(f, t));
Axiom SubstTm(f, Refl(s)) ~> Refl(SubstTm(f, s));
Axiom TmTy(Refl(s)) ~> Eq(s, s);
Axiom TmTy(r) = Eq(s, t) => s = t & r = Refl(s) & r = Refl(t);
