// The category of contexts and morphisms.
Sort Ctx;
Sort Mor;

// Domains and codomains of morphisms.
Func Dom: Mor -> Ctx;
Query dom(f) -> Dom(f);
Func Cod: Mor -> Ctx;
Query cod(f) -> Cod(f);
// Compositions of morphisms.
Func Comp: Mor * Mor -> Mor;
// Identity morphisms.
Func Id: Ctx -> Mor;

Query id_pre(f: Mor) -> x where f = Id(x);

// Iterator over hom(gamma, delta).
Query hom(gamma, delta) -> f where Dom(f) = gamma & Cod(f) = delta;

// Domains and codomains of identity morphisms.
Axiom Dom(Id(ctx)) ~> ctx;
Axiom Cod(Id(ctx)) ~> ctx;
// Domains and codomains of composed morphisms.
Axiom Dom(Comp(_, f)) ~> Dom(f);
Axiom Cod(Comp(g, _)) ~> Cod(g);

// The set of active contexts.
Pred ActiveCtx : Ctx;

// Identity laws.
Axiom ActiveCtx(Cod(f)) & i = Id(Dom(f)) => Comp(f, i) = f;
Axiom ActiveCtx(ctx) & Cod(f) = ctx & i = Id(ctx) => Comp(i, f) = f;

// Types and terms.
Sort Ty;
Sort Tm;

// The context of a type.
Func TyCtx : Ty -> Ctx;
// The type of a term.
Func TmTy : Tm -> Ty;
Query ty_ctx(ty: Ty) -> TyCtx(ty);
Query tm_ctx(tm: Tm) -> TyCtx(TmTy(tm));

// Substituting types and terms.
Func SubstTy: Mor * Ty-> Ty;
Func SubstTm: Mor * Tm-> Tm;

Query subst_ty_pre(subst_ty: Ty) -> (mor, ty) where subst_ty = SubstTy(mor, ty);
Query subst_tm_pre(subst_tm: Tm) -> (mor, tm) where subst_tm = SubstTm(mor, tm);

// The context of a substituted type.
Axiom TyCtx(SubstTy(f, _)) ~> Cod(f);
// The type of a substituted term.
Axiom TmTy(SubstTm(f, s)) ~> SubstTy(f, TmTy(s));

// Substitution along identity morphisms.
Axiom SubstTy(Id(TyCtx(sigma)), sigma) ~> sigma;
Axiom SubstTm(Id(TyCtx(TmTy(s))), s) ~> s;

// Substitution along composed morphisms.
Axiom SubstTy(Comp(g, f), sigma) ~> SubstTy(g, SubstTy(f, sigma));
Axiom SubstTy(g, SubstTy(f, sigma)) ~> SubstTy(Comp(g, f), sigma);
Axiom SubstTm(Comp(g, f), s) ~> SubstTm(g, SubstTm(f, s));
Axiom SubstTm(g, SubstTm(f, s)) ~> SubstTm(Comp(g, f), s);

// Partial functions assigning to extended contexts data:
// - The base context.
Func BaseCtx: Ctx -> Ctx;
// - The weakening from the base context.
Func ExtWkn: Ctx -> Mor;
// - The type in the base context by which it is extended.
Func ExtTy: Ctx -> Ty;
// - The variable term.
Func ExtVar: Ctx -> Tm;
// - Extended morphisms ExtMor(gamma, f, s) : gamma -> delta, where
//   * f : BaseCtx(gamma) -> delta
//   * delta |- s : SubstTy(f, ExtTy(gamma))
Func ExtMor: Ctx * Mor * Tm -> Mor;

// Signature of weakenings.
Axiom Dom(ExtWkn(gamma)) ~> BaseCtx(gamma);
Axiom Cod(ExtWkn(gamma)) ~> gamma;
// The type of the variable term.
Axiom TmTy(ExtVar(gamma)) ~> SubstTy(ExtWkn(gamma), ExtTy(gamma));
// Domain and codomain of extended morphisms.
Axiom Dom(ExtMor(gamma, _, _)) ~> gamma;
Axiom Cod(ExtMor(_, f, _)) ~> Cod(f);
// Commutativity of extended morphisms with the weakening and the base
// morphism.
Axiom f_0 = Comp(ExtMor(gamma, f, _), ExtWkn(gamma)) => f_0 = f;
// Image of the variable under extended morphisms.
Axiom SubstTm(ExtMor(gamma, _, s), ExtVar(gamma)) ~> s;

// The transitive reflexive closure of context extension.
Pred CtxExt: Ctx * Ctx;
Axiom a = BaseCtx(b) => CtxExt(a, b);
Axiom a!: Ctx => CtxExt(a, a);
Axiom CtxExt(a, b) & CtxExt(b, c) => CtxExt(a, c);

// Iterated substitutions.
Axiom SubstTm(g, SubstTm(f, s)) ~> SubstTm(Comp(g, f), s);
Axiom SubstTy(g, SubstTy(f, sigma)) ~> SubstTy(Comp(g, f), sigma);

// We add new composed morphisms g o f in the following situation:
// - The codomain of g is an active context.
// - The signatures of g and f match.
// - f is a substitution from an inner scope of Dom(g) into Dom(g).
// - SubstTm(g, SubstTm(f, s)) is defined for some term s in the domain of f.
Axiom
  ActiveCtx(Cod(g))
  & Cod(f) = Dom(g)
  & CtxExt(Cod(f), Dom(f))
  & SubstTm(g, SubstTm(f, _))!
  =>
  Comp(g, f)!
  ;

// The equality
//   ExtMor(gamma, f, _) o ExtWkn(gamma) = f
// in both directions, and in a version that works for compositions of 
// weakenings instead of just a single one.
Axiom 
  ActiveCtx(Cod(g))
  & g = ExtMor(gamma, g_0, _)
  & w = Comp(ExtWkn(gamma), w_0)
  & Comp(g_0, w_0)!
  =>
  Comp(g, w) = Comp(g_0, w_0)
  ;
Axiom 
  ActiveCtx(Cod(g))
  & g = ExtMor(gamma, g_0, _)
  & w = Comp(ExtWkn(gamma), w_0)
  & Comp(g, w)!
  =>
  Comp(g, w) = Comp(g_0, w_0)
  ;

// The equality
//   g o ExtMor(gamma, f, s) = ExtMor(gamma, g o f, g[s])
// in both directions.
Axiom
  ActiveCtx(Cod(g))
  & Cod(f) = Dom(g)
  & f = ExtMor(gamma, f_0, s)
  & h = ExtMor(gamma, Comp(g, f_0), SubstTm(g, s))
  =>
  h = Comp(g, f)
  ;
Axiom
  ActiveCtx(Cod(g))
  & Cod(f) = Dom(g)
  & f = ExtMor(gamma, f_0, s)
  & h = Comp(g, f)
  & Comp(g, f_0)!
  & SubstTm(g, s)!
  =>
  h = ExtMor(gamma, Comp(g, f_0), SubstTm(g, s))
  ;

// The unit type.
Func Unit: Ctx -> Ty;
// The unique term of the unit type.
Func UnitTm: Ctx -> Tm;
// The induction principle for the unit type. Arguments:
// - The type we eliminate into. Must live in an extended context.
// - The term for the case where the variable is UnitTm.
Func UnitInd: Ty * Tm -> Tm;

// Context of unit types.
Axiom TyCtx(Unit(ctx)) ~> ctx;
// Types of unit terms.
Axiom TmTy(UnitTm(ctx)) ~> Unit(ctx);
// Substitution stability of unit types.
Axiom SubstTy(f, Unit(Dom(f))) ~> Unit(Cod(f));
// Substitution stability of unit terms.
Axiom SubstTm(f, UnitTm(Dom(f))) ~> UnitTm(Cod(f));
// Type of unit induction terms.
Axiom TmTy(UnitInd(sigma, _)) ~> sigma;
// Evaluation rule for unit induction.
Axiom
	c = UnitInd(sigma, unit_case) &
	f_unit = ExtMor(TyCtx(sigma), f, UnitTm(Cod(f)))
	=>
	SubstTm(f_unit, c) ~> SubstTm(f, unit_case)
	;

// The equality type.
Func Eq: Tm * Tm -> Ty;
// The reflexivity term.
Func Refl: Tm -> Tm;

// The context of the equality type.
Axiom TyCtx(Eq(s, _)) ~> TyCtx(TmTy(s));
Axiom TyCtx(Eq(_, t)) ~> TyCtx(TmTy(t));
// The type of the reflexivity term.
Axiom TmTy(Refl(s)) ~> Eq(s, s);
// Substitution stability of the equality type and reflexivity term.
Axiom SubstTy(f, Eq(s, t)) ~> Eq(SubstTm(f, s), SubstTm(f, t));
Axiom SubstTm(f, Refl(s)) ~> Refl(SubstTm(f, s));
// Equality reflection, part one: If there is a term of the equality type for
// s and t, then s and t are equal.
Axiom TmTy(_) = Eq(s, t) => s = t;
// Equality reflection, part two: Every two terms of and equality type are equal.
Axiom e = Eq(s, s) & TmTy(r_1) = e & TmTy(r_2) = e => r_1 = r_2;

// The type of booleans.
Func Bool: Ctx -> Ty;
Func FalseTm : Ctx -> Tm;
Func TrueTm : Ctx -> Tm;
// Boolean elimination, i.e. "if - else -". Takes
// - the type to eliminate into, which must live a context extended by a variable of type `Bool`,
// - the result for `FalseTm`,
// - the result for `TrueTm`.
// Returns a term in the extended context.
Func BoolInd : Ty * Tm * Tm -> Tm;

// The context of the bool type.
Axiom TyCtx(Bool(ctx)) ~> ctx;
// The types of the true and false terms.
Axiom TmTy(FalseTm(ctx)) ~> Bool(ctx);
Axiom TmTy(TrueTm(ctx)) ~> Bool(ctx);
// Substitution stability of the bool type.
Axiom SubstTy(f, Bool(Dom(f))) ~> Bool(Cod(f));
// Substitution stability of the false and true terms.
Axiom SubstTm(f, FalseTm(Dom(f))) ~> FalseTm(Cod(f));
Axiom SubstTm(f, TrueTm(Dom(f))) ~> TrueTm(Cod(f));
// The type of bool induction.
Axiom TmTy(BoolInd(sigma, _, _)) ~> sigma;
// Evaluation rules for BoolInd: One for substituting false, on for substituting true.
Axiom 
	c = BoolInd(sigma, false_case, _) &
	f_false = ExtMor(TyCtx(sigma), f, FalseTm(Cod(f)))
	=>
	SubstTm(f_false, c) ~> SubstTm(f, false_case)
	;
Axiom 
	c = BoolInd(sigma, _, true_case) &
	f_true = ExtMor(TyCtx(sigma), f, TrueTm(Cod(f)))
	=>
	SubstTm(f_true, c) ~> SubstTm(f, true_case)
	;
