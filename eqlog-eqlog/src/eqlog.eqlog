pred absurd();

// ## Identifiers
//
// The `Ident` type corresponds to actual strings that occur in the source
// file. The `VirtIdent` type represent ids that do not occur verbatim in
// source code, but semantically correspond to identifiers. For example, each
// occurence of a wildcard token _ corresponds to a separate `VirtIdent` which
// does not arise from an `Ident`.
type Ident;
type VirtIdent;
func real_virt_ident(Ident) -> VirtIdent;

rule real_virt_ident_total {
    if ident: Ident;
    then real_virt_ident(ident)!;
}

// ## Abstract syntax tree (AST) nodes

type TypeDeclNode;
pred type_decl(TypeDeclNode, name: Ident);

type ArgDeclNode;
// arg_decl_node_name is optional (but must be unique), arg_decl_node_type is
// mandatory and must be unique.
pred arg_decl_node_name(ArgDeclNode, name: Ident);
pred arg_decl_node_type(ArgDeclNode, typ: Ident);

type ArgDeclListNode;
pred nil_arg_decl_list_node(ArgDeclListNode);
pred cons_arg_decl_list_node(ArgDeclListNode, head: ArgDeclNode, tail: ArgDeclListNode);

type PredDeclNode;
pred pred_decl(PredDeclNode, name: Ident, args: ArgDeclListNode);

type FuncDeclNode;
pred func_decl(FuncDeclNode, name: Ident, args: ArgDeclListNode, result_type: Ident);

type CtorDeclNode;
pred ctor_decl(CtorDeclNode, name: Ident, args: ArgDeclListNode);

type CtorDeclListNode;
pred nil_ctor_decl_list_node(CtorDeclListNode);
pred cons_ctor_decl_list_node(CtorDeclListNode, head: CtorDeclNode, tail: CtorDeclListNode);

type EnumDeclNode;
pred enum_decl(EnumDeclNode, name: Ident, ctors: CtorDeclListNode);

type TermNode;

type TermListNode;
pred nil_term_list_node(nil: TermListNode);
pred cons_term_list_node(node: TermListNode, head: TermNode, tail: TermListNode);

type OptTermNode;
pred none_term_node(OptTermNode);
pred some_term_node(OptTermNode, value: TermNode);

pred var_term_node(TermNode, Ident);
pred wildcard_term_node(TermNode);
pred app_term_node(TermNode, function: Ident, args: TermListNode);

type IfAtomNode;
pred equal_if_atom_node(IfAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_if_atom_node(IfAtomNode, term: TermNode);
pred pred_if_atom_node(IfAtomNode, predicate: Ident, args: TermListNode);
pred var_if_atom_node(IfAtomNode, var: TermNode, typ: Ident);

type ThenAtomNode;
pred equal_then_atom_node(ThenAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_then_atom_node(ThenAtomNode, var: OptTermNode, tm: TermNode);
pred pred_then_atom_node(ThenAtomNode, predicate: Ident, args: TermListNode);

type StmtNode;
pred if_stmt_node(StmtNode, IfAtomNode);
pred then_stmt_node(StmtNode, ThenAtomNode);
pred branch_stmt_node(StmtNode, blocks: StmtBlockListNode);

type StmtListNode;
pred nil_stmt_list_node(nil: StmtListNode);
pred cons_stmt_list_node(node: StmtListNode, head: StmtNode, tail: StmtListNode);

type StmtBlockListNode;
pred nil_stmt_block_list_node(node: StmtBlockListNode);
pred cons_stmt_block_list_node(node: StmtBlockListNode, head: StmtListNode, tail: StmtBlockListNode);

type RuleDeclNode;
pred rule_decl(node: RuleDeclNode, stmts: StmtListNode);
// This is defined for non-anonymous RuleDeclNode elements only.
func rule_name(RuleDeclNode) -> Ident;

type DeclNode;
pred decl_node_type(DeclNode, TypeDeclNode);
pred decl_node_pred(DeclNode, PredDeclNode);
pred decl_node_func(DeclNode, FuncDeclNode);
pred decl_node_rule(DeclNode, RuleDeclNode);
pred decl_node_enum(DeclNode, EnumDeclNode);

type DeclListNode;
pred nil_decl_list_node(DeclListNode);
pred cons_decl_list_node(DeclListNode, head: DeclNode, tail: DeclListNode);

type ModuleNode;
pred decls_module_node(ModuleNode, DeclListNode);

// ### Locations
type Loc;

func type_decl_node_loc(TypeDeclNode) -> Loc;
func arg_decl_node_loc(ArgDeclNode) -> Loc;
func arg_decl_list_node_loc(ArgDeclListNode) -> Loc;
func pred_decl_node_loc(PredDeclNode) -> Loc;
func func_decl_node_loc(FuncDeclNode) -> Loc;
func ctor_decl_node_loc(CtorDeclNode) -> Loc;
func enum_decl_node_loc(EnumDeclNode) -> Loc;
func term_node_loc(TermNode) -> Loc;
func term_list_node_loc(TermListNode) -> Loc;
func opt_term_node_loc(OptTermNode) -> Loc;
func if_atom_node_loc(IfAtomNode) -> Loc;
func then_atom_node_loc(ThenAtomNode) -> Loc;
func stmt_node_loc(StmtNode) -> Loc;
func stmt_list_node_loc(StmtListNode) -> Loc;
func rule_decl_node_loc(RuleDeclNode) -> Loc;
func decl_node_loc(DeclNode) -> Loc;
func decl_list_node_loc(DeclListNode) -> Loc;
func module_node_loc(ModuleNode) -> Loc;

// ### Child nodes of rules
//
// Every node that can appear as a descendant of a `RuleDeclNode` can be
// coerced into a `RuleChildNode`. This can then be used to query the rule that
// a given node belongs to.
type RuleChildNode;

func rule_child_term(TermNode) -> RuleChildNode;
func rule_child_term_list(TermListNode) -> RuleChildNode;
func rule_child_opt_term(OptTermNode) -> RuleChildNode;
func rule_child_if_atom(IfAtomNode) -> RuleChildNode;
func rule_child_then_atom(ThenAtomNode) -> RuleChildNode;
func rule_child_stmt(StmtNode) -> RuleChildNode;
func rule_child_stmt_list(StmtListNode) -> RuleChildNode;
func rule_child_stmt_block_list(StmtBlockListNode) -> RuleChildNode;

rule rule_child_term_total {
    if tm: TermNode;
    then rule_child_term(tm)!;
}
rule rule_child_term_list_total {
    if tms: TermListNode;
    then rule_child_term_list(tms)!;
}
rule rule_child_opt_term_total {
    if opt_tm: OptTermNode;
    then rule_child_opt_term(opt_tm)!;
}
rule rule_child_if_atom_total {
    if atom: IfAtomNode;
    then rule_child_if_atom(atom)!;
}
rule rule_child_then_atom_total {
    if atom: ThenAtomNode;
    then rule_child_then_atom(atom)!;
}
rule rule_child_stmt_total {
    if stmt: StmtNode;
    then rule_child_stmt(stmt)!;
}
rule rule_child_stmt_list_total {
    if stmts: StmtListNode;
    then rule_child_stmt_list(stmts)!;
}
rule rule_child_stmt_block_list_total {
    if blocks: StmtBlockListNode;
    then rule_child_stmt_block_list(blocks)!;
}

pred rule_child(RuleChildNode, RuleDeclNode);

rule rule_child_rule_decl {
    if rule_decl(rul, stmts);
    if child = rule_child_stmt_list(stmts);
    then rule_child(child, rul);
}

rule rule_child_stmts_cons {
    if cons_stmt_list_node(stmts, head, tail);
    if rule_child(rule_child_stmt_list(stmts), rul);
    if child_head = rule_child_stmt(head);
    if child_tail = rule_child_stmt_list(tail);
    then rule_child(child_head, rul);
    then rule_child(child_tail, rul);
}

rule rule_child_stmt_blocks_cons {
    if cons_stmt_block_list_node(block, head, tail);
    if rule_child(rule_child_stmt_block_list(block), rul);
    if child_head = rule_child_stmt_list(head);
    if child_tail = rule_child_stmt_block_list(tail);
    then rule_child(child_head, rul);
    then rule_child(child_tail, rul);
}

rule rule_child_stmt_if {
    if if_stmt_node(stmt, atom);
    if rule_child(rule_child_stmt(stmt), rul);
    if child_atom = rule_child_if_atom(atom);
    then rule_child(child_atom, rul);
}
rule rule_child_stmt_then {
    if then_stmt_node(stmt, atom);
    if rule_child(rule_child_stmt(stmt), rul);
    if child_atom = rule_child_then_atom(atom);
    then rule_child(child_atom, rul);
}
rule rule_child_stmt_branch {
    if branch_stmt_node(stmt, blocks);
    if rule_child(rule_child_stmt(stmt), rul);
    if child_block_list = rule_child_stmt_block_list(blocks);
    then rule_child(child_block_list, rul);
}

rule rule_child_if_atom_equal {
    if equal_if_atom_node(atom, lhs, rhs);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_lhs = rule_child_term(lhs);
    if child_rhs = rule_child_term(rhs);
    then rule_child(child_lhs, rul);
    then rule_child(child_rhs, rul);
}
rule rule_child_if_atom_defined {
    if defined_if_atom_node(atom, tm);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}
rule rule_child_if_atom_pred {
    if pred_if_atom_node(atom, _, tms);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tms = rule_child_term_list(tms);
    then rule_child(child_tms, rul);
}
rule rule_child_if_atom_var {
    if var_if_atom_node(atom, tm, _);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}

rule rule_child_then_atom_equal {
    if equal_then_atom_node(atom, lhs, rhs);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_lhs = rule_child_term(lhs);
    if child_rhs = rule_child_term(rhs);
    then rule_child(child_lhs, rul);
    then rule_child(child_rhs, rul);
}
rule rule_child_then_atom_defined {
    if defined_then_atom_node(atom, var_tm, tm);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_var_tm = rule_child_opt_term(var_tm);
    if child_tm = rule_child_term(tm);
    then rule_child(child_var_tm, rul);
    then rule_child(child_tm, rul);
}
rule rule_child_then_atom_pred {
    if pred_then_atom_node(atom, _, tms);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_tms = rule_child_term_list(tms);
    then rule_child(child_tms, rul);
}

rule rule_child_terms_cons {
    if cons_term_list_node(tms, head, tail);
    if rule_child(rule_child_term_list(tms), rul);
    if child_head = rule_child_term(head);
    if child_tail = rule_child_term_list(tail);
    then rule_child(child_head, rul);
    then rule_child(child_tail, rul);
}
rule rule_child_opt_term_some {
    if some_term_node(opt_tm, tm);
    if rule_child(rule_child_opt_term(opt_tm), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}
rule rule_child_term_app {
    if app_term_node(tm, _, args);
    if rule_child(rule_child_term(tm), rul);
    if child_args = rule_child_term_list(args);
    then rule_child(child_args, rul);
}

// ### The enum constructor belong to

func ctor_enum(CtorDeclNode) -> EnumDeclNode;
func ctors_enum(CtorDeclListNode) -> EnumDeclNode;

rule enum_ctors {
    if enum_decl(enum_node, _, ctors);
    then ctors_enum(ctors) = enum_node;
}
rule enum_ctors_cons {
    if ctors_enum(ctors) = enum_node;
    if cons_ctor_decl_list_node(ctors, head_ctor, tail_ctors);
    then ctor_enum(head_ctor) = enum_node;
    then ctors_enum(tail_ctors) = enum_node;
}

// ## Semantic types, predicates and functions

type Type;
type TypeList;
func nil_type_list() -> TypeList;
func cons_type_list(head: Type, tail: TypeList) -> TypeList;
rule type_list_nil_not_cons {
    if nil_type_list() = cons_type_list(_, _);
    then absurd();
}
rule type_list_cons_injective {
    if cons_type_list(head_0, tail_0) = cons_type_list(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}

func semantic_type(Ident) -> Type;
rule semantic_decl_type {
    if type_decl(_, ident);
    then semantic_type(ident)!;
}
rule semantic_decl_enum {
    if enum_decl(_, ident, _);
    then semantic_type(ident)!;
}

func semantic_arg_types(ArgDeclListNode) -> TypeList;
rule semantic_arg_types_nil {
    if nil_arg_decl_list_node(n);
    then nil_type_list()!;
    then semantic_arg_types(n) = nil_type_list();
}
rule semantic_arg_types_cons {
    if cons_arg_decl_list_node(arg_decls, head, tail);
    if arg_decl_node_type(head, head_type_name);
    if head_type = semantic_type(head_type_name);
    if tail_types = semantic_arg_types(tail);
    then cons_type_list(head_type, tail_types)!;
    then semantic_arg_types(arg_decls) = cons_type_list(head_type, tail_types);
}

type Pred;
func semantic_pred(Ident) -> Pred;
rule semantic_decl_pred {
    if pred_decl(_, name, _);
    then semantic_pred(name)!;
}


func arity(Pred) -> TypeList;
rule arity_decl {
    if pred_decl(_, pred_name, arg_decls);
    if predicate = semantic_pred(pred_name);
    if arg_types = semantic_arg_types(arg_decls);
    then arity(predicate) = arg_types;
}

type Func;
func semantic_func(Ident) -> Func;
rule semantic_decl_func {
    if func_decl(_, name, _, _);
    then semantic_func(name)!;
}
rule semantic_decl_func_ctor {
    if ctor_decl(_, name, _);
    then semantic_func(name)!;
}

func domain(Func) -> TypeList;
func codomain(Func) -> Type;
rule func_decl_domain_codomain {
    if func_decl(_, func_name, arg_decls, result_type_name);
    if function = semantic_func(func_name);
    if domain_types = semantic_arg_types(arg_decls);
    if result_type = semantic_type(result_type_name);
    then domain(function) = domain_types;
    then codomain(function) = result_type;
}
rule ctor_decl_domain {
    if ctor_decl(_, ctor_name, arg_decls);
    if function = semantic_func(ctor_name);
    if domain_types = semantic_arg_types(arg_decls);
    then domain(function) = domain_types;
}
rule ctor_decl_codomain {
    if ctor_decl(ctor, ctor_name, _);
    if function = semantic_func(ctor_name);
    if enum_decl(ctor_enum(ctor), enum_name, _);
    if semantic_enum_type = semantic_type(enum_name);
    then codomain(function) = semantic_enum_type;
}

// ## Structures

type Structure;

type El;

type ElList;
func nil_el_list(Structure) -> ElList;
func cons_el_list(head: El, tail: ElList) -> ElList;

rule el_list_cons_injective {
    if cons_el_list(head_0, tail_0) = cons_el_list(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}
rule el_list_cons_nil {
    if cons_el_list(_, _) = nil_el_list(_);
    then absurd();
}

func func_app(Func, ElList) -> El;

pred pred_app(Pred, ElList);

func var(Structure, VirtIdent) -> El;

// ### The structure that elements belong to
func el_structure(El) -> Structure;
func els_structure(ElList) -> Structure;
rule nil_els_structure {
    if els = nil_el_list(structure);
    then els_structure(els) = structure;
}
rule cons_els_structure {
    if els = cons_el_list(head, tail);
    if head_structure = el_structure(head);
    then head_structure = els_structure(els);
    then head_structure = els_structure(tail);
}

rule func_app_structure {
    if result = func_app(_, args);
    if structure = els_structure(args);
    then structure = el_structure(result);
}

rule var_structure {
    if el = var(structure, _);
    then el_structure(el) = structure;
}

// ### The types of elements
pred el_type(El, Type);
pred el_types(ElList, TypeList);

rule nil_el_types {
    if els = nil_el_list(_);
    then nil_type_list()!;
    then el_types(els, nil_type_list());
}
rule cons_el_types {
    if els = cons_el_list(head, tail);
    if el_type(head, head_type);
    if el_types(tail, tail_types);
    then cons_type_list(head_type, tail_types)!;
    then el_types(els, cons_type_list(head_type, tail_types));
}
rule cons_el_types_reverse {
    if els = cons_el_list(head, tail);
    if el_types(els, cons_type_list(head_type, tail_types));
    then el_type(head, head_type);
    then el_types(tail, tail_types);
}

rule func_app_types {
    if result = func_app(function, args);
    if domain(function) = dom;
    if codomain(function) = cod;
    then el_types(args, dom);
    then el_type(result, cod);
}

rule pred_app_types {
    if pred_app(predicate, args);
    if arity(predicate) = ar;
    then el_types(args, ar);
}

// ### Constrained elements
//
// An element is constrained if it appears in a function
// application (including the result) or in the
// application of a predicate.
pred constrained_el(El);
pred constrained_els(ElList);
rule func_app_constrained {
    if result = func_app(_, args);
    then constrained_els(args);
    then constrained_el(result);
}
rule pred_app_constrained {
    if pred_app(_, args);
    then constrained_els(args);
}
rule constrained_head_tail {
    if constrained_els(cons_el_list(head, tail));
    then constrained_el(head);
    then constrained_els(tail);
}

// ## Morphisms

type Morphism;
func dom(Morphism) -> Structure;
func cod(Morphism) -> Structure;

rule dom_total {
    if morph: Morphism;
    then dom(morph)!;
}
rule cod_total {
    if morph: Morphism;
    then cod(morph)!;
}

func map_el(Morphism, El) -> El;
func map_els(Morphism, ElList) -> ElList;

// Mapped elements live in the codomain structure.
rule map_el_structure {
    if mapped = map_el(mor, _);
    if cod = cod(mor);
    then el_structure(mapped) = cod;
}
rule map_els_structure {
    if mapped = map_els(mor, _);
    if cod = cod(mor);
    then els_structure(mapped) = cod;
}

// The operations map_el(mor, -) and map_els(mor, -) are total.
rule map_el_defined {
    if dom(mor) = struct;
    if el_structure(el) = struct;
    then map_el(mor, el)!;
}
rule map_els_defined {
    if dom(mor) = struct;
    if els_structure(els) = struct;
    then map_els(mor, els)!;
}

// Morphisms commute with nil and cons.
rule map_nil_els {
    if mapped = map_els(mor, nil_el_list(_));
    if cod = cod(mor);
    then mapped = nil_el_list(cod);
}
rule map_cons_els {
    if mapped = map_els(mor, cons_el_list(head, tail));
    then map_el(mor, head)!;
    then map_els(mor, tail)!;
    then mapped = cons_el_list(map_el(mor, head), map_els(mor, tail));
}

// Morphisms commute with function application, preserve
// variables and are compatible with predicates.
rule map_app_func {
    if mapped_result = map_el(mor, func_app(function, args));
    if mapped_args = map_els(mor, args);
    then mapped_result = func_app(function, mapped_args);
}
rule map_var {
    if el = var(_, name);
    if mapped_el = map_el(morph, el);
    if cod(morph) = cod_structure;
    then mapped_el = var(cod_structure, name);
}
rule map_pred_app {
    if pred_app(predicate, args);
    if mapped_args = map_els(_, args);
    then pred_app(predicate, mapped_args);
}

// Morphisms preserve and reflect types.
rule map_preserves_el_type {
    if el_type(el, typ);
    if mapped_el = map_el(_, el);
    then el_type(mapped_el, typ);
}
rule map_reflects_el_type {
    if el_type(map_el(_, el), typ);
    then el_type(el, typ);
}

// ### Kernel pairs of morphisms.

pred in_ker(Morphism, El, El);
rule in_ker_rule {
    if map_el(morph, el_0) = map_el(morph, el_1);
    then in_ker(morph, el_0, el_1);
}

// ### Images of morphisms.

pred el_in_img(Morphism, El);
rule el_in_img_rule {
    if map_el(morph, _) = el;
    then el_in_img(morph, el);
}

pred pred_tuple_in_img(Morphism, Pred, ElList);
rule pred_tuple_in_img_rule {
    if map_els(morphism, dom_els) = cod_els;
    if pred_app(predicate, dom_els);
    then pred_tuple_in_img(morphism, predicate, cod_els);
}

pred func_app_in_img(Morphism, Func, args: ElList);
rule func_app_in_img_rule {
    if map_els(morphism, dom_els) = cod_els;
    if func_app(function, dom_els)!;
    then func_app_in_img(morphism, function, cod_els);
}

// ## Symbol checks
//
// This is for facilitating checks for duplicated symbols, wrong symbol types,
// and wrong argument numbers.

type SymbolKind;
func type_symbol() -> SymbolKind;
func pred_symbol() -> SymbolKind;
func func_symbol() -> SymbolKind;
func rule_symbol() -> SymbolKind;
func enum_symbol() -> SymbolKind;
func ctor_symbol() -> SymbolKind;
rule {
    then type_symbol()!;
    then pred_symbol()!;
    then func_symbol()!;
    then rule_symbol()!;
    then enum_symbol()!;
    then ctor_symbol()!;
}

pred defined_symbol(Ident, SymbolKind, Loc);

rule type_decl_defines_symbol {
    if type_decl(decl, name);
    if kind = type_symbol();
    if loc = type_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule enum_decl_defines_symbol {
    if enum_decl(decl, name, _);
    if kind = enum_symbol();
    if loc = enum_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule pred_decl_defines_symbol {
    if pred_decl(decl, name, _);
    if kind = pred_symbol();
    if loc = pred_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule func_decl_defines_symbol {
    if func_decl(decl, name, _, _);
    if kind = func_symbol();
    if loc = func_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule ctor_decl_defines_symbol {
    if ctor_decl(decl, name, _);
    if kind  = ctor_symbol();
    if loc = ctor_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule rule_decl_defines_symbol {
    if rule_decl(decl, _);
    if name = rule_name(decl);
    if kind = rule_symbol();
    if loc = rule_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}

// ### Symbol lookup checks

// Only one kind of symbol is allowed.
pred should_be_symbol(name: Ident, kind: SymbolKind, loc: Loc);
// Two kinds of symbols are allowed, with `kind_1` being the typical one.
pred should_be_symbol_2(name: Ident, kind_1: SymbolKind, kind_2: SymbolKind, loc: Loc);

rule arg_decl_should_be_type {
    if arg_decl_node_type(arg_decl, name);
    if type_kind = type_symbol();
    if enum_kind = enum_symbol();
    if loc = arg_decl_node_loc(arg_decl);
    then should_be_symbol_2(name, type_kind, enum_kind, loc);
}
rule result_should_be_type {
    if func_decl(func_decl, _, _, result_type);
    if type_kind = type_symbol();
    if enum_kind = enum_symbol();
    if loc = func_decl_node_loc(func_decl);
    then should_be_symbol_2(result_type, type_kind, enum_kind, loc);
}
rule var_atom_should_be_type {
    if var_if_atom_node(atom, _, name);
    if type_kind = type_symbol();
    if enum_kind = enum_symbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol_2(name, type_kind, enum_kind, loc);
}
rule pred_if_atom_should_be_pred {
    if pred_if_atom_node(atom, pred_name, _);
    if kind = pred_symbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, loc);
}
rule pred_then_atom_should_be_pred {
    if pred_then_atom_node(atom, pred_name, _);
    if kind = pred_symbol();
    if loc = then_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, loc);
}
rule app_atom_should_be_func {
    if app_term_node(term, name, _);
    if func_kind = func_symbol();
    if ctor_kind = ctor_symbol();
    if loc = term_node_loc(term);
    then should_be_symbol_2(name, func_kind, ctor_kind, loc);
}

// ### Natural numbers and argument numbers

type Nat;
func zero() -> Nat;
func succ(Nat) -> Nat;

func type_list_len(TypeList) -> Nat;
rule type_list_len_total {
    if tys: TypeList;
    then type_list_len(tys)!;
}
rule type_list_len_nil {
    if tys = nil_type_list();
    if len = type_list_len(tys);
    then len = zero();
}
rule type_list_len_cons {
    if tys = cons_type_list(_, tail);
    if len = type_list_len(tys);
    if tail_len = type_list_len(tail);
    then len = succ(tail_len);
}

func term_list_len(TermListNode) -> Nat;
rule term_list_len_total {
    if terms: TermListNode;
    then term_list_len(terms)!;
}
rule term_list_len_nil {
    if nil_term_list_node(terms);
    if len = term_list_len(terms);
    then len = zero();
}
rule term_list_len_cons {
    if cons_term_list_node(terms, _, tail);
    if len = term_list_len(terms);
    if tail_len = term_list_len(tail);
    then len = succ(tail_len);
}

pred pred_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);
pred func_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);

rule pred_if_atom_arg_num_should_match {
    if pred_if_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(arity(semantic_pred(name)));
    if loc = if_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}
rule pred_then_atom_arg_num_should_match {
    if pred_then_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(arity(semantic_pred(name)));
    if loc = then_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}

rule app_term_arg_num_should_match {
    if app_term_node(tm, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(domain(semantic_func(name)));
    if loc = term_node_loc(tm);
    then func_arg_num_should_match(got_len, expected_len, loc);
}

// ## Control flow graph
pred cfg_edge(from: StmtNode, to: StmtNode);
pred cfg_linear_first(stmt: StmtNode);
pred cfg_linear_last(stmt: StmtNode);
pred cfg_edge_linear(from: StmtNode, to: StmtNode);
pred cfg_edge_nonlinear(from: StmtNode, to: StmtNode);

rule cfg_edge_linear_general {
    if cfg_edge_linear(from, to);
    then cfg_edge(from, to);
}
rule cfg_edge_nonlinear_general {
    if cfg_edge_nonlinear(from, to);
    then cfg_edge(from, to);
}

rule cfg_edge_adjacent {
    if cons_stmt_list_node(_, first , tail);
    if cons_stmt_list_node(tail, second , _);
    then cfg_edge_linear(first, second);
}

rule cfg_linear_first_rule {
    if rule_decl(_, stmts);
    if cons_stmt_list_node(stmts, head, _);
    then cfg_linear_first(head);
}
rule cfg_linear_first_block_list {
    if cons_stmt_block_list_node(_, head_block, _);
    if cons_stmt_list_node(head_block, head_stmt, _);
    then cfg_linear_first(head_stmt);
}
rule cfg_linear_last_list {
    if cons_stmt_list_node(_, head, tail);
    if nil_stmt_list_node(tail);
    then cfg_linear_last(head);
}

// ### Control flow from and into StmtListNodes
// 
// If control flows into a list of statements, then it flows into the first statement in that list.
// If control flows out of a statement list, then it flows out of every suffix of the statement list, and from the last statement in the list.
// In case of an empty statement list, there's an ordinary cfg edge between every before-statement to every after-statement.
pred cfg_edge_nonlinear_stmts_stmt(from: StmtListNode, to: StmtNode);
pred cfg_edge_nonlinear_stmt_stmts(from: StmtNode, to: StmtListNode);

rule cfg_edge_stmts_stmt_cons {
    if cfg_edge_nonlinear_stmts_stmt(stmts, stmt);
    if cons_stmt_list_node(stmts, _, tail);
    then cfg_edge_nonlinear_stmts_stmt(tail, stmt);
}
rule cfg_edge_stmts_stmt_singleton {
    if cfg_edge_nonlinear_stmts_stmt(stmts, stmt);
    if cons_stmt_list_node(stmts, head, tail);
    if nil_stmt_list_node(tail);
    then cfg_edge_nonlinear(head, stmt);
}

rule cfg_edge_stmt_stmts_cons {
    if cfg_edge_nonlinear_stmt_stmts(stmt, stmts);
    if cons_stmt_list_node(stmts, head, _);
    then cfg_edge_nonlinear(stmt, head);
}
rule cfg_edge_stmt_stmts_nil {
    if cfg_edge_nonlinear_stmt_stmts(stmt, stmts);
    if nil_stmt_list_node(stmts);
    if cfg_edge_nonlinear_stmts_stmt(stmts, next_stmt);
    then cfg_edge_nonlinear(stmt, next_stmt);
}

// ### Control flow from and into block lists.
//
// This is for branches.

pred cfg_edge_nonlinear_fork(from: StmtNode, to: StmtBlockListNode);
pred cfg_edge_nonlinear_join(from: StmtBlockListNode, to: StmtNode);

rule cfg_edge_fork_cons {
    if cfg_edge_nonlinear_fork(stmt, blocks);
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    then cfg_edge_nonlinear_fork(stmt, tail_blocks);
    then cfg_edge_nonlinear_stmt_stmts(stmt, head_block);
}

rule cfg_edge_join_cons {
    if cfg_edge_nonlinear_join(blocks, stmt);
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    then cfg_edge_nonlinear_join(tail_blocks, stmt);
    then cfg_edge_nonlinear_stmts_stmt(head_block, stmt);
}

rule cfg_edge_fork_stmt_into {
    if branch_stmt_node(branch_stmt, fork_blocks);
    if cfg_edge(from_stmt, branch_stmt);
    then cfg_edge_nonlinear_fork(from_stmt, fork_blocks);
}
rule cfg_edge_fork_stmt_from {
    if branch_stmt_node(branch_stmt, fork_blocks);
    if cfg_edge(branch_stmt, into_stmt);
    then cfg_edge_nonlinear_join(fork_blocks, into_stmt);
}

// ## The morphisms associated to statements.
//
// Each statement in a rule corresponds to a morphism of structures. The domain
// of this morphism corresponds to the data that has been queries or asserted
// earlier in the rule, and the codomain to the result of adjoining the data in
// that statement. Codomain and domain of subsequent statements match, so their
// morphisms are composable.

pred before_stmt_structure(StmtNode, Structure);
pred stmt_morphism(StmtNode, Morphism);

func before_rule_structure(RuleDeclNode) -> Structure;
rule before_rule_structure_total {
    if rn: RuleDeclNode;
    then before_rule_structure(rn)!;
}
rule before_first_rule_stmt {
    if rule_decl(rul, stmts);
    if cons_stmt_list_node(stmts, first, _);
    if structure = before_rule_structure(rul);
    then before_stmt_structure(first, structure);
}

rule cfg_edge_stmt_structure {
    if cfg_edge(from_stmt, to_stmt);
    if stmt_morphism(from_stmt, from_morphism);
    if from_cod = cod(from_morphism);
    then before_stmt_structure(to_stmt, from_cod);
}

func if_atom_morphism(IfAtomNode, before_structure: Structure) -> Morphism;
func then_atom_morphism(ThenAtomNode, before_structure: Structure) -> Morphism;

rule if_atom_morphism_dom {
    if morph_dom = dom(if_atom_morphism(_, before_structure));
    then morph_dom = before_structure;
}

rule then_atom_morphism_dom {
    if morph_dom = dom(then_atom_morphism(_, before_structure));
    then morph_dom = before_structure;
}

rule if_stmt_morphism {
    if if_stmt_node(stmt, atom);
    if before_stmt_structure(stmt, before_structure);
    then morph := if_atom_morphism(atom, before_structure)!;
    then stmt_morphism(stmt, morph);
}

rule then_stmt_morphism {
    if then_stmt_node(stmt, atom);
    if before_stmt_structure(stmt, before_structure);
    then morph := then_atom_morphism(atom, before_structure)!;
    then stmt_morphism(stmt, morph);
}

pred if_morphism(Morphism);
pred surj_then_morphism(Morphism);
pred non_surj_then_morphism(Morphism);

rule if_stmt_morphism_is_if {
    if if_stmt_node(stmt, _);
    if stmt_morphism(stmt, morph);
    then if_morphism(morph);
}
rule then_equal_stmt_morphism_is_surj {
    if then_stmt_node(stmt, atom);
    if equal_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then surj_then_morphism(morph);
}
rule then_pred_stmt_morphism_is_surj {
    if then_stmt_node(stmt, atom);
    if pred_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then surj_then_morphism(morph);
}
rule then_defined_stmt_morphism_is_non_surj {
    if then_stmt_node(stmt, atom);
    if defined_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then non_surj_then_morphism(morph);
}

// ### Propagation of associated structures through the AST
//
// Even though a statement corresponds to a morphism, inside the statement we
// only need access to the codomain of that morphism. That's the
// stmt_structure, and similarly for subnodes of statements.
//
// #### Propagate stmt structure through if and then stmts.
pred stmt_structure(StmtNode, Structure);
pred if_atom_structure(IfAtomNode, Structure);
pred then_atom_structure(ThenAtomNode, Structure);
pred term_structure(TermNode, Structure);
pred terms_structure(TermListNode, Structure);
pred opt_term_structure(OptTermNode, Structure);

rule stmt_structure_morphism {
    if stmt_morphism(stmt, morph);
    if s = cod(morph);
    then stmt_structure(stmt, s);
}

rule if_stmt_structure {
    if if_stmt_node(stmt, atom);
    if stmt_structure(stmt, structure);
    then if_atom_structure(atom, structure);
}
rule then_stmt_structure {
    if then_stmt_node(stmt, atom);
    if stmt_structure(stmt, structure);
    then then_atom_structure(atom, structure);
}

// #### Propagate associated structures through if atoms.
rule equal_if_atom_structure {
    if equal_if_atom_node(atom, lhs, rhs);
    if if_atom_structure(atom, structure);
    then term_structure(lhs, structure);
    then term_structure(rhs, structure);
}
rule defined_if_atom_structure {
    if defined_if_atom_node(atom, term);
    if if_atom_structure(atom, structure);
    then term_structure(term, structure);
}
rule pred_if_atom_structure {
    if pred_if_atom_node(atom, _, arg_terms);
    if if_atom_structure(atom, structure);
    then terms_structure(arg_terms, structure);
}
rule var_if_atom_structure {
    if var_if_atom_node(atom, var_term, _);
    if if_atom_structure(atom, structure);
    then term_structure(var_term, structure);
}

// #### Propagate associated structures through then atoms.
rule equal_then_atom_structure {
    if equal_then_atom_node(atom, lhs, rhs);
    if then_atom_structure(atom, structure);
    then term_structure(lhs, structure);
    then term_structure(rhs, structure);
}
rule defined_then_atom_structure {
    if defined_then_atom_node(atom, var_term, term);
    if then_atom_structure(atom, structure);
    then opt_term_structure(var_term, structure);
    then term_structure(term, structure);
}
rule pred_then_atom_structure {
    if pred_then_atom_node(atom, _, arg_terms);
    if then_atom_structure(atom, structure);
    then terms_structure(arg_terms, structure);
}

// #### Propagate associated structures through terms.
rule cons_term_list_structure {
    if cons_term_list_node(terms, head, tail);
    if terms_structure(terms, structure);
    then term_structure(head, structure);
    then terms_structure(tail, structure);
}

rule some_opt_term_structure {
    if some_term_node(opt_term, term);
    if opt_term_structure(opt_term, structure);
    then term_structure(term, structure);
}

rule app_term_structure {
    if app_term_node(term, _, args);
    if term_structure(term, structure);
    then terms_structure(args, structure);
}

// ### Populate associated structures

func semantic_el(TermNode, Structure) -> El;
rule semantic_el_defined {
    if el: TermNode;
    if term_structure(el, structure);
    then semantic_el(el, structure)!;
}

func semantic_els(TermListNode, Structure) -> ElList;
rule semantic_els_total {
    if els: TermListNode;
    if terms_structure(els, structure);
    then semantic_els(els, structure)!;
}

rule semantic_els_nil {
    if nil_term_list_node(terms);
    if terms_structure(terms, structure);
    if sem_els = semantic_els(terms, structure);
    then sem_els = nil_el_list(structure);
}
rule semantic_els_cons {
    if cons_term_list_node(terms, head, tail);
    if sem_els = semantic_els(terms, structure);
    if head_sem_el = semantic_el(head, structure);
    if tail_sem_els = semantic_els(tail, structure);
    then sem_els = cons_el_list(head_sem_el, tail_sem_els);
}

// #### The structures of semantic elements
rule semantic_el_struct {
    if el = semantic_el(_, structure);
    then el_structure(el) = structure;
}
rule semantic_els_struct {
    if els = semantic_els(_, structure);
    then els_structure(els) = structure;
}

// #### Semantics of terms
rule app_term_semantics {
    if app_term_node(result_term, func_name, arg_terms);
    if result_el = semantic_el(result_term, structure);
    if arg_els = semantic_els(arg_terms, structure);
    if function = semantic_func(func_name);
    then result_el = func_app(function, arg_els);
}

rule var_term_semantics {
    if var_term_node(term, name);
    if virt_name = real_virt_ident(name);
    if el = semantic_el(term, structure);
    then el = var(structure, virt_name);
}

func wildcard_virt_ident(TermNode) -> VirtIdent;
rule wildcard_virt_ident_defined {
    if wildcard_term_node(term);
    then wildcard_virt_ident(term)!;
}
rule wildcard_term_semantics {
    if wildcard_term_node(term);
    if name = wildcard_virt_ident(term);
    if el = semantic_el(term, structure);
    then el = var(structure, name);
}

// #### Semantics of if atoms
rule equal_if_atom_semantics {
    if equal_if_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term, structure);
    if rhs_el = semantic_el(rhs_term, structure);
    then lhs_el = rhs_el;
}
// No rule for `defined_if_atom` -- this is already taken care of because `semantic_el` is total.
rule pred_if_atom_semantics {
    if pred_if_atom_node(_, predicate_name, arg_terms);
    if predicate = semantic_pred(predicate_name);
    if arg_els = semantic_els(arg_terms, _);
    then pred_app(predicate, arg_els);
}
rule var_if_atom_semantics {
    if var_if_atom_node(_, var_term, type_name);
    if typ = semantic_type(type_name);
    if var_el = semantic_el(var_term, _);
    then el_type(var_el, typ);
}

// #### Semantics of then atoms
rule equal_then_atom_semantics {
    if equal_then_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term, structure);
    if rhs_el = semantic_el(rhs_term, structure);
    then lhs_el = rhs_el;
}
rule defined_then_atom_semantics {
    if defined_then_atom_node(_, opt_var_term, term);
    if some_term_node(opt_var_term, var_term);
    if var_el = semantic_el(var_term, structure);
    if el = semantic_el(term, structure);
    then var_el = el;
}
rule pred_then_atom_semantics {
    if pred_then_atom_node(_, predicate_name, arg_terms);
    if predicate = semantic_pred(predicate_name);
    if arg_els = semantic_els(arg_terms, _);
    then pred_app(predicate, arg_els);
}

// ### The *grouped* morphism associated to a statement
//
// Consecutive if statements and surjective then statements have the same
// grouped morphism.
func grouped_stmt_morphism(StmtNode, Morphism) -> Morphism;
rule grouped_stmt_morphism_defined {
    if stmt_morphism(stmt, morph);
    then grouped_stmt_morphism(stmt, morph)!;
}

// ### The first grouped morphism associated to a rule.
pred rule_first_grouped_morphism(RuleDeclNode, Morphism);
rule rule_stmt_first_grouped {
    if rule_decl(rul, stmts);
    if cons_stmt_list_node(stmts, first, _);
    if gsm = grouped_stmt_morphism(first, _);
    then rule_first_grouped_morphism(rul, gsm);
}

// #### The grouped statement morphism has the same type as the ungrouped one.
rule grouped_stmt_morphism_if {
    if stmt_morphism(stmt, morph);
    if if_morphism(morph);
    if gsm = grouped_stmt_morphism(stmt, morph);
    then if_morphism(gsm);
}
rule grouped_stmt_morphism_surj_then {
    if stmt_morphism(stmt, morph);
    if surj_then_morphism(morph);
    if gsm = grouped_stmt_morphism(stmt, morph);
    then surj_then_morphism(gsm);
}
rule grouped_stmt_morphism_non_surj_then {
    if stmt_morphism(stmt, morph);
    if non_surj_then_morphism(morph);
    if gsm = grouped_stmt_morphism(stmt, morph);
    then non_surj_then_morphism(gsm);
}

// #### The next grouped morphism in a statement list
pred next_grouped_morphism(Morphism, Morphism);
rule next_grouped_nonlinear_cfg_edge {
    if cfg_edge_nonlinear(first, second);
    if first_gsm = grouped_stmt_morphism(first, first_morph);
    if second_gsm = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);
    then next_grouped_morphism(first_gsm, second_gsm);
}

// #### The domains and codomains of grouped morphisms

rule grouped_stmt_morphism_first_dom {
    if cfg_linear_first(stmt);
    if gsm = grouped_stmt_morphism(stmt, morph);
    if morph_dom = dom(morph);
    if gsm_dom = dom(gsm);
    then morph_dom = gsm_dom;
}

rule grouped_stmt_morphism_last_cod {
    if cfg_linear_last(stmt);
    if gsm = grouped_stmt_morphism(stmt, morph);
    if morph_cod = cod(morph);
    if gsm_cod = cod(gsm);
    then morph_cod = gsm_cod;
}

rule next_grouped_dom_cod {
    if cfg_edge(first, second);
    if first_gsm = grouped_stmt_morphism(first, first_morph);
    if second_gsm = grouped_stmt_morphism(second, _);
    if next_grouped_morphism(first_gsm, second_gsm);
    if s = cod(first_morph);
    then cod(first_gsm) = s;
    then dom(second_gsm) = s;
}

// #### Grouping rules for an if statement followed by an arbitrary statement.
rule grouped_stmt_morphism_if_if {
    if cfg_edge_linear(first, second);
    if if_stmt_node(first, _);
    if if_stmt_node(second, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    then gsm_first = gsm_second;
}
rule grouped_stmt_morphism_if_then {
    if cfg_edge_linear(first, second);
    if if_stmt_node(first, _);
    if then_stmt_node(second, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    then next_grouped_morphism(gsm_first, gsm_second);
}

// #### Grouping rules for a then atom followed by an arbitrary morphism.
rule grouped_stmt_morphism_then_if {
    if cfg_edge_linear(first, second);
    if then_stmt_node(first, _);
    if if_stmt_node(second, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    then next_grouped_morphism(gsm_first, gsm_second);
}

rule grouped_stmt_morphism_surj_then_surj_then {
    if cfg_edge_linear(first, second);
    if then_stmt_node(first, _);
    if then_stmt_node(second, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    if surj_then_morphism(first_morph);
    if surj_then_morphism(second_morph);

    then gsm_first = gsm_second;
}
rule grouped_stmt_morphism_surj_then_non_surj_then {
    if cfg_edge_linear(first, second);
    if then_stmt_node(first, _);
    if then_stmt_node(second, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    if surj_then_morphism(first_morph);
    if non_surj_then_morphism(second_morph);

    then next_grouped_morphism(gsm_first, gsm_second);
}
// #### Grouping rule for a non-surjective then statement followed by an arbitrary statement.
rule grouped_stmt_morphism_non_surj_then_arbitrary {
    if cfg_edge_linear(first, second);
    if then_stmt_node(first, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    if non_surj_then_morphism(first_morph);

    then next_grouped_morphism(gsm_first, gsm_second);
}
// #### Grouping rule for a branch statement followed by an arbitrary statement.
rule grouped_stmt_morphism_branch {
    if cfg_edge_linear(first, second);
    if branch_stmt_node(first, _);

    if gsm_first = grouped_stmt_morphism(first, first_morph);
    if gsm_second = grouped_stmt_morphism(second, second_morph);
    if cod(first_morph) = dom(second_morph);

    then next_grouped_morphism(gsm_first, gsm_second);
}

// ## Epic check

// ### Bound variables
//
// These predicates track which variables have been
// introduced in *statements* prior to the one in which
// the AST node appears.
pred var_before_term(TermNode, VirtIdent);
pred var_before_terms(TermListNode, VirtIdent);
pred var_before_opt_term(OptTermNode, VirtIdent);
pred var_before_if_atom(IfAtomNode, VirtIdent);
pred var_before_then_atom(ThenAtomNode, VirtIdent);
pred var_before_stmt(StmtNode, VirtIdent);
pred var_before_stmts(StmtListNode, VirtIdent);
pred var_before_stmt_blocks(StmtBlockListNode, VirtIdent);

// These predicates track which variables appear in the
// respective AST node.
pred var_in_term(TermNode, VirtIdent);
pred var_in_terms(TermListNode, VirtIdent);
pred var_in_opt_term(OptTermNode, VirtIdent);
pred var_in_if_atom(IfAtomNode, VirtIdent);
pred var_in_then_atom(ThenAtomNode, VirtIdent);
pred var_in_stmt(StmtNode, VirtIdent);
pred var_in_stmts(StmtListNode, VirtIdent);
// This predicate is not quite analogous to the ones above, since it tracks
// whether the variable occurs in *each* of the blocks in a statement block
// list node, not just whether it occurs in some of the blocks.
pred var_in_all_stmt_blocks(StmtBlockListNode, VirtIdent);

// #### Propagate var_before_X downwards
rule var_before_stmt_blocks_cons {
    if var_before_stmt_blocks(blocks, name);
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    then var_before_stmts(head_block, name);
    then var_before_stmt_blocks(tail_blocks, name);
}
rule var_before_stmts_cons {
    if var_before_stmts(stmts, name);
    if cons_stmt_list_node(stmts, stmt, stmts_tail);
    then var_before_stmt(stmt, name);
    then var_before_stmts(stmts_tail, name);
}
rule var_before_stmt_if {
    if var_before_stmt(stmt, name);
    if if_stmt_node(stmt, atom);
    then var_before_if_atom(atom, name);
}
rule var_before_stmt_then {
    if var_before_stmt(stmt, name);
    if then_stmt_node(stmt, atom);
    then var_before_then_atom(atom, name);
}
rule var_before_stmt_branch {
    if var_before_stmt(stmt, name);
    if branch_stmt_node(stmt, blocks);
    then var_before_stmt_blocks(blocks, name);
}

rule var_before_if_atom_equal {
    if var_before_if_atom(atom, name);
    if equal_if_atom_node(atom, lhs, rhs);
    then var_before_term(lhs, name);
    then var_before_term(rhs, name);
}
rule var_before_if_atom_defined {
    if var_before_if_atom(atom, name);
    if defined_if_atom_node(atom, tm);
    then var_before_term(tm, name);
}
rule var_before_if_atom_pred {
    if var_before_if_atom(atom, name);
    if pred_if_atom_node(atom, _, args);
    then var_before_terms(args, name);
}
rule var_before_if_atom_var {
    if var_before_if_atom(atom, name);
    if var_if_atom_node(atom, var_term, _);
    then var_before_term(var_term, name);
}

rule var_before_then_atom_equal {
    if var_before_then_atom(atom, name);
    if equal_then_atom_node(atom, lhs, rhs);
    then var_before_term(lhs, name);
    then var_before_term(rhs, name);
}
rule var_before_then_atom_defined {
    if var_before_then_atom(atom, name);
    if defined_then_atom_node(atom, var_term, tm);
    then var_before_opt_term(var_term, name);
    then var_before_term(tm, name);
}
rule var_before_then_atom_pred {
    if var_before_then_atom(atom, name);
    if pred_then_atom_node(atom, _, args);
    then var_before_terms(args, name);
}

rule var_before_terms_cons {
    if var_before_terms(tms, name);
    if cons_term_list_node(tms, head, tail);
    then var_before_term(head, name);
    then var_before_terms(tail, name);
}

rule var_before_opt_term_some {
    if var_before_opt_term(opt_term, name);
    if some_term_node(opt_term, term);
    then var_before_term(term, name);
}

rule var_before_term_app {
    if var_before_term(tm, name);
    if app_term_node(tm, _, args);
    then var_before_terms(args, name);
}

// #### Propagate var_in_X upwards
rule var_in_term_var {
    if var_term_node(tm, ident);
    if name = real_virt_ident(ident);
    then var_in_term(tm, name);
}
rule var_in_term_wildcard {
    if wildcard_term_node(tm);
    if name = wildcard_virt_ident(tm);
    then var_in_term(tm, name);
}
rule var_in_term_app {
    if app_term_node(tm, _, args);
    if var_in_terms(args, name);
    then var_in_term(tm, name);
}

rule var_in_terms_cons_head {
    if cons_term_list_node(tms, head, _);
    if var_in_term(head, name);
    then var_in_terms(tms, name);
}
rule var_in_terms_cons_tail {
    if cons_term_list_node(tms, _, tail);
    if var_in_terms(tail, name);
    then var_in_terms(tms, name);
}

rule var_in_opt_terms {
    if some_term_node(opt_term, term);
    if var_in_term(term, name);
    then var_in_opt_term(opt_term, name);
}

rule var_in_if_atom_equal_lhs {
    if equal_if_atom_node(atom, lhs, _);
    if var_in_term(lhs, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_equal_rhs {
    if equal_if_atom_node(atom, _, rhs);
    if var_in_term(rhs, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_defined {
    if defined_if_atom_node(atom, tm);
    if var_in_term(tm, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_pred {
    if pred_if_atom_node(atom, _, args);
    if var_in_terms(args, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_var {
    if var_if_atom_node(atom, var_term, _);
    if var_in_term(var_term, name);
    then var_in_if_atom(atom, name);
}

rule var_in_then_atom_equal_lhs {
    if equal_then_atom_node(atom, lhs, _);
    if var_in_term(lhs, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_equal_rhs {
    if equal_then_atom_node(atom, _, rhs);
    if var_in_term(rhs, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_defined_var_term {
    if defined_then_atom_node(atom, var_term, _);
    if var_in_opt_term(var_term, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_defined_term {
    if defined_then_atom_node(atom, _, tm);
    if var_in_term(tm, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_pred {
    if pred_then_atom_node(atom, _, args);
    if var_in_terms(args, name);
    then var_in_then_atom(atom, name);
}

rule var_in_stmt_if {
    if if_stmt_node(stmt, atom);
    if var_in_if_atom(atom, name);
    then var_in_stmt(stmt, name);
}
rule var_in_stmt_then {
    if then_stmt_node(stmt, atom);
    if var_in_then_atom(atom, name);
    then var_in_stmt(stmt, name);
}
rule var_in_stmt_branch {
    if branch_stmt_node(stmt, blocks);
    if var_in_all_stmt_blocks(blocks, name);
    then var_in_stmt(stmt, name);
}

rule var_in_stmts_cons_head {
    if cons_stmt_list_node(stmts, head_stmt, _);
    if var_in_stmt(head_stmt, name);
    then var_in_stmts(stmts, name);
}
rule var_in_stmts_cons_tail {
    if cons_stmt_list_node(stmts, _, tail_stmts);
    if var_in_stmts(tail_stmts, name);
    then var_in_stmts(stmts, name);
}

rule var_in_all_stmt_blocks_cons {
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    if var_in_stmts(head_block, name);
    if var_in_all_stmt_blocks(tail_blocks, name);
    then var_in_all_stmt_blocks(blocks, name);
}

// #### Connect var_before_X and var_in_X

rule var_in_var_before {
    if cons_stmt_list_node(_, stmt, tail);
    if var_in_stmt(stmt, name);
    then var_before_stmts(tail, name);
}

// ### Terms that should need epic checking
//
// These are terms that appear in then statements.

pred term_should_be_epic_ok(TermNode);
pred terms_should_be_epic_ok(TermListNode);

// #### Propagate should_be_epic_ok downwards.
rule terms_should_be_epic_ok_cons {
    if terms_should_be_epic_ok(terms);
    if cons_term_list_node(terms, head, tail);
    then term_should_be_epic_ok(head);
    then terms_should_be_epic_ok(tail);
}

rule terms_should_be_epic_ok_app {
    if term_should_be_epic_ok(tm);
    if app_term_node(tm, _, args);
    then terms_should_be_epic_ok(args);
}

rule then_atom_epic_ok_equal {
    if equal_then_atom_node(_, lhs, rhs);
    then term_should_be_epic_ok(lhs);
    then term_should_be_epic_ok(rhs);
}
rule then_atom_epic_ok_defined {
    if defined_then_atom_node(_, _, tm);
    then term_should_be_epic_ok(tm);
}
rule then_atom_epic_ok_pred {
    if pred_then_atom_node(_, _, args);
    then terms_should_be_epic_ok(args);
}

// ## Surjectivity check

// Only *ungrouped* surjective then morphisms need surjectivity checking.
pred should_be_surjective(Morphism);
rule surj_then_should_be_surjective {
    if stmt_morphism(_, morph);
    if surj_then_morphism(morph);
    then should_be_surjective(morph);
}
rule non_surj_then_should_be_surjective {
    if stmt_morphism(_, morph);
    if non_surj_then_morphism(morph);
    then should_be_surjective(morph);
}

pred el_should_be_surjective_ok(El);
pred el_is_surjective_ok(El);
pred el_is_surjective_exempted(El);

rule surjective_codomain_should_be_ok {
    if should_be_surjective(morph);
    if el_structure(el) = cod(morph);
    then el_should_be_surjective_ok(el);
}

rule surjective_img_el_is_ok {
    if should_be_surjective(morph);
    if el_in_img(morph, el);
    then el_is_surjective_ok(el);
}

rule surjective_exempted_then_defined_term {
    if defined_then_atom_node(_, _, tm);
    if el = semantic_el(tm, _);
    then el_is_surjective_exempted(el);
}

// ## Variable occurs twice check

pred var_term_in_rule(TermNode, Ident, RuleDeclNode);
rule var_term_in_rule_child {
    if var_term_node(tm, ident);
    if rule_child(rule_child_term(tm), rul);
    then var_term_in_rule(tm, ident, rul);
}

pred should_be_obtained_by_ctor(TermNode, EnumDeclNode);

// ## Enum constructor surjectivity check
rule defined_then_should_be_given_by_ctor {
    if defined_then_atom_node(_, _, tm);
    if el = semantic_el(tm, _);
    if el_type(el, semantic_type(ty_name));
    if enum_decl(enum_decl_node, ty_name, _);
    then should_be_obtained_by_ctor(tm, enum_decl_node);
}

pred is_given_by_ctor(TermNode, EnumDeclNode);

rule ctor_app_is_given_by_ctor {
    if app_term_node(tm, func_ident, _);
    if ctor_decl(ctor, func_ident, _);
    if ctor_enum(ctor) = enum_decl_node;
    then is_given_by_ctor(tm, enum_decl_node);
}
