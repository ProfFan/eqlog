pred absurd();

// ## Identifiers
//
// The `Ident` type corresponds to actual strings that occur in the source
// file. The `VirtIdent` type represent ids that do not occur verbatim in
// source code, but semantically correspond to identifiers. For example, each
// occurence of a wildcard token _ corresponds to a separate `VirtIdent` which
// does not arise from an `Ident`.
type Ident;
type VirtIdent;
func real_virt_ident(Ident) -> VirtIdent;

rule real_virt_ident_total {
    if ident: Ident;
    then real_virt_ident(ident)!;
}

// ## Abstract syntax tree (AST) nodes

type TypeDeclNode;
pred type_decl(TypeDeclNode, name: Ident);

type ArgDeclNode;
// arg_decl_node_name is optional (but must be unique), arg_decl_node_type is
// mandatory and must be unique.
pred arg_decl_node_name(ArgDeclNode, name: Ident);
pred arg_decl_node_type(ArgDeclNode, typ: Ident);

type ArgDeclListNode;
pred nil_arg_decl_list_node(ArgDeclListNode);
pred cons_arg_decl_list_node(ArgDeclListNode, head: ArgDeclNode, tail: ArgDeclListNode);

type PredDeclNode;
pred pred_decl(PredDeclNode, name: Ident, args: ArgDeclListNode);

type FuncDeclNode;
pred func_decl(FuncDeclNode, name: Ident, args: ArgDeclListNode, result_type: Ident);

type TermNode;

type TermListNode;
pred nil_term_list_node(nil: TermListNode);
pred cons_term_list_node(node: TermListNode, head: TermNode, tail: TermListNode);

type OptTermNode;
pred none_term_node(OptTermNode);
pred some_term_node(OptTermNode, value: TermNode);

pred var_term_node(TermNode, Ident);
pred wildcard_term_node(TermNode);
pred app_term_node(TermNode, function: Ident, args: TermListNode);

type IfAtomNode;
pred equal_if_atom_node(IfAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_if_atom_node(IfAtomNode, term: TermNode);
pred pred_if_atom_node(IfAtomNode, predicate: Ident, args: TermListNode);
pred var_if_atom_node(IfAtomNode, var: TermNode, typ: Ident);

type ThenAtomNode;
pred equal_then_atom_node(ThenAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_then_atom_node(ThenAtomNode, var: OptTermNode, tm: TermNode);
pred pred_then_atom_node(ThenAtomNode, predicate: Ident, args: TermListNode);

type StmtNode;
pred if_stmt_node(StmtNode, IfAtomNode);
pred then_stmt_node(StmtNode, ThenAtomNode);

type StmtListNode;
pred nil_stmt_list_node(nil: StmtListNode);
pred cons_stmt_list_node(node: StmtListNode, head: StmtNode, tail: StmtListNode);

type RuleDeclNode;
pred rule_decl(node: RuleDeclNode, stmts: StmtListNode);
// This is defined for non-anonymous RuleDeclNode elements only.
func rule_name(RuleDeclNode) -> Ident;

type DeclNode;
pred decl_node_type(DeclNode, TypeDeclNode);
pred decl_node_pred(DeclNode, PredDeclNode);
pred decl_node_func(DeclNode, FuncDeclNode);
pred decl_node_rule(DeclNode, RuleDeclNode);

type DeclListNode;
pred nil_decl_list_node(DeclListNode);
pred cons_decl_list_node(DeclListNode, head: DeclNode, tail: DeclListNode);

type ModuleNode;
pred decls_module_node(ModuleNode, DeclListNode);

// ### Locations
type Loc;

func type_decl_node_loc(TypeDeclNode) -> Loc;
func arg_decl_node_loc(ArgDeclNode) -> Loc;
func arg_decl_list_node_loc(ArgDeclListNode) -> Loc;
func pred_decl_node_loc(PredDeclNode) -> Loc;
func func_decl_node_loc(FuncDeclNode) -> Loc;
func term_node_loc(TermNode) -> Loc;
func term_list_node_loc(TermListNode) -> Loc;
func opt_term_node_loc(OptTermNode) -> Loc;
func if_atom_node_loc(IfAtomNode) -> Loc;
func then_atom_node_loc(ThenAtomNode) -> Loc;
func stmt_node_loc(StmtNode) -> Loc;
func stmt_list_node_loc(StmtListNode) -> Loc;
func rule_decl_node_loc(RuleDeclNode) -> Loc;
func decl_node_loc(DeclNode) -> Loc;
func decl_list_node_loc(DeclListNode) -> Loc;
func module_node_loc(ModuleNode) -> Loc;

// ### Child nodes of rules
//
// Every node that can appear as a descendant of a `RuleDeclNode` can be
// coerced into a `RuleChildNode`. This can then be used to query the rule that
// a given node belongs to.
type RuleChildNode;

func rule_child_term(TermNode) -> RuleChildNode;
func rule_child_term_list(TermListNode) -> RuleChildNode;
func rule_child_opt_term(OptTermNode) -> RuleChildNode;
func rule_child_if_atom(IfAtomNode) -> RuleChildNode;
func rule_child_then_atom(ThenAtomNode) -> RuleChildNode;
func rule_child_stmt(StmtNode) -> RuleChildNode;
func rule_child_stmt_list(StmtListNode) -> RuleChildNode;

rule rule_child_term_total {
    if tm: TermNode;
    then rule_child_term(tm)!;
}
rule rule_child_term_list_total {
    if tms: TermListNode;
    then rule_child_term_list(tms)!;
}
rule rule_child_opt_term_total {
    if opt_tm: OptTermNode;
    then rule_child_opt_term(opt_tm)!;
}
rule rule_child_if_atom_total {
    if atom: IfAtomNode;
    then rule_child_if_atom(atom)!;
}
rule rule_child_then_atom_total {
    if atom: ThenAtomNode;
    then rule_child_then_atom(atom)!;
}
rule rule_child_stmt_total {
    if stmt: StmtNode;
    then rule_child_stmt(stmt)!;
}
rule rule_child_stmt_list_total {
    if stmts: StmtListNode;
    then rule_child_stmt_list(stmts)!;
}

pred rule_child(RuleChildNode, RuleDeclNode);

rule rule_child_rule_decl {
    if rule_decl(rul, stmts);
    if child = rule_child_stmt_list(stmts);
    then rule_child(child, rul);
}

rule rule_child_stmts_cons {
    if cons_stmt_list_node(stmts, head, tail);
    if rule_child(rule_child_stmt_list(stmts), rul);
    if child_head = rule_child_stmt(head);
    if child_tail = rule_child_stmt_list(tail);
    then rule_child(child_head, rul);
    then rule_child(child_tail, rul);
}

rule rule_child_stmt_if {
    if if_stmt_node(stmt, atom);
    if rule_child(rule_child_stmt(stmt), rul);
    if child_atom = rule_child_if_atom(atom);
    then rule_child(child_atom, rul);
}
rule rule_child_stmt_then {
    if then_stmt_node(stmt, atom);
    if rule_child(rule_child_stmt(stmt), rul);
    if child_atom = rule_child_then_atom(atom);
    then rule_child(child_atom, rul);
}

rule rule_child_if_atom_equal {
    if equal_if_atom_node(atom, lhs, rhs);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_lhs = rule_child_term(lhs);
    if child_rhs = rule_child_term(rhs);
    then rule_child(child_lhs, rul);
    then rule_child(child_rhs, rul);
}
rule rule_child_if_atom_defined {
    if defined_if_atom_node(atom, tm);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}
rule rule_child_if_atom_pred {
    if pred_if_atom_node(atom, _, tms);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tms = rule_child_term_list(tms);
    then rule_child(child_tms, rul);
}
rule rule_child_if_atom_var {
    if var_if_atom_node(atom, tm, _);
    if rule_child(rule_child_if_atom(atom), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}

rule rule_child_then_atom_equal {
    if equal_then_atom_node(atom, lhs, rhs);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_lhs = rule_child_term(lhs);
    if child_rhs = rule_child_term(rhs);
    then rule_child(child_lhs, rul);
    then rule_child(child_rhs, rul);
}
rule rule_child_then_atom_defined {
    if defined_then_atom_node(atom, var_tm, tm);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_var_tm = rule_child_opt_term(var_tm);
    if child_tm = rule_child_term(tm);
    then rule_child(child_var_tm, rul);
    then rule_child(child_tm, rul);
}
rule rule_child_then_atom_pred {
    if pred_then_atom_node(atom, _, tms);
    if rule_child(rule_child_then_atom(atom), rul);
    if child_tms = rule_child_term_list(tms);
    then rule_child(child_tms, rul);
}

rule rule_child_terms_cons {
    if cons_term_list_node(tms, head, tail);
    if rule_child(rule_child_term_list(tms), rul);
    if child_head = rule_child_term(head);
    if child_tail = rule_child_term_list(tail);
    then rule_child(child_head, rul);
    then rule_child(child_tail, rul);
}
rule rule_child_opt_term_some {
    if some_term_node(opt_tm, tm);
    if rule_child(rule_child_opt_term(opt_tm), rul);
    if child_tm = rule_child_term(tm);
    then rule_child(child_tm, rul);
}
rule rule_child_term_app {
    if app_term_node(tm, _, args);
    if rule_child(rule_child_term(tm), rul);
    if child_args = rule_child_term_list(args);
    then rule_child(child_args, rul);
}

// ## Semantic types, predicates and functions

type Type;
type TypeList;
func nil_type_list() -> TypeList;
func cons_type_list(head: Type, tail: TypeList) -> TypeList;
rule type_list_nil_not_cons {
    if nil_type_list() = cons_type_list(_, _);
    then absurd();
}
rule type_list_cons_injective {
    if cons_type_list(head_0, tail_0) = cons_type_list(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}

func semantic_type(Ident) -> Type;
rule semantic_decl_type {
    if type_decl(_, ident);
    then semantic_type(ident)!;
}

func semantic_arg_types(ArgDeclListNode) -> TypeList;
rule semantic_arg_types_nil {
    if nil_arg_decl_list_node(n);
    then nil_type_list()!;
    then semantic_arg_types(n) = nil_type_list();
}
rule semantic_arg_types_cons {
    if cons_arg_decl_list_node(arg_decls, head, tail);
    if arg_decl_node_type(head, head_type_name);
    if head_type = semantic_type(head_type_name);
    if tail_types = semantic_arg_types(tail);
    then cons_type_list(head_type, tail_types)!;
    then semantic_arg_types(arg_decls) = cons_type_list(head_type, tail_types);
}

type Pred;
func semantic_pred(Ident) -> Pred;
rule semantic_decl_pred {
    if pred_decl(_, name, _);
    then semantic_pred(name)!;
}


func arity(Pred) -> TypeList;
rule arity_decl {
    if pred_decl(_, pred_name, arg_decls);
    if predicate = semantic_pred(pred_name);
    if arg_types = semantic_arg_types(arg_decls);
    then arity(predicate) = arg_types;
}

type Func;
func semantic_func(Ident) -> Func;
rule semantic_decl_func {
    if func_decl(_, name, _, _);
    then semantic_func(name)!;
}

func domain(Func) -> TypeList;
func codomain(Func) -> Type;
rule domain_decl {
    if func_decl(_, func_name, arg_decls, result_type_name);
    if function = semantic_func(func_name);
    if domain_types = semantic_arg_types(arg_decls);
    if result_type = semantic_type(result_type_name);
    then domain(function) = domain_types;
    then codomain(function) = result_type;
}

// ## Structures

type Structure;

type El;

type ElList;
func nil_el_list(Structure) -> ElList;
func cons_el_list(head: El, tail: ElList) -> ElList;

rule el_list_cons_injective {
    if cons_el_list(head_0, tail_0) = cons_el_list(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}
rule el_list_cons_nil {
    if cons_el_list(_, _) = nil_el_list(_);
    then absurd();
}

func func_app(Func, ElList) -> El;

pred pred_app(Pred, ElList);

func var(Structure, VirtIdent) -> El;

// ### The structure that elements belong to
func el_structure(El) -> Structure;
func els_structure(ElList) -> Structure;
rule nil_els_structure {
    if els = nil_el_list(structure);
    then els_structure(els) = structure;
}
rule cons_els_structure {
    if els = cons_el_list(head, tail);
    if head_structure = el_structure(head);
    then head_structure = els_structure(els);
    then head_structure = els_structure(tail);
}

rule func_app_structure {
    if result = func_app(_, args);
    if structure = els_structure(args);
    then structure = el_structure(result);
}

rule var_structure {
    if el = var(structure, _);
    then el_structure(el) = structure;
}

// ### The types of elements
pred el_type(El, Type);
pred el_types(ElList, TypeList);

rule nil_el_types {
    if els = nil_el_list(_);
    then nil_type_list()!;
    then el_types(els, nil_type_list());
}
rule cons_el_types {
    if els = cons_el_list(head, tail);
    if el_type(head, head_type);
    if el_types(tail, tail_types);
    then cons_type_list(head_type, tail_types)!;
    then el_types(els, cons_type_list(head_type, tail_types));
}
rule cons_el_types_reverse {
    if els = cons_el_list(head, tail);
    if el_types(els, cons_type_list(head_type, tail_types));
    then el_type(head, head_type);
    then el_types(tail, tail_types);
}

rule func_app_types {
    if result = func_app(function, args);
    if domain(function) = dom;
    if codomain(function) = cod;
    then el_types(args, dom);
    then el_type(result, cod);
}

rule pred_app_types {
    if pred_app(predicate, args);
    if arity(predicate) = ar;
    then el_types(args, ar);
}

// ### Constrained elements
//
// An element is constrained if it appears in a function
// application (including the result) or in the
// application of a predicate.
pred constrained_el(El);
pred constrained_els(ElList);
rule func_app_constrained {
    if result = func_app(_, args);
    then constrained_els(args);
    then constrained_el(result);
}
rule pred_app_constrained {
    if pred_app(_, args);
    then constrained_els(args);
}
rule constrained_head_tail {
    if constrained_els(cons_el_list(head, tail));
    then constrained_el(head);
    then constrained_els(tail);
}

// ## Morphisms

type Morphism;
func dom(Morphism) -> Structure;
func cod(Morphism) -> Structure;
func map_el(Morphism, El) -> El;
func map_els(Morphism, ElList) -> ElList;

// Mapped elements live in the codomain structure.
rule map_el_structure {
    if mapped = map_el(mor, _);
    if cod = cod(mor);
    then el_structure(mapped) = cod;
}
rule map_els_structure {
    if mapped = map_els(mor, _);
    if cod = cod(mor);
    then els_structure(mapped) = cod;
}

// The operations map_el(mor, -) and map_els(mor, -) are total.
rule map_el_defined {
    if dom(mor) = struct;
    if el_structure(el) = struct;
    then map_el(mor, el)!;
}
rule map_els_defined {
    if dom(mor) = struct;
    if els_structure(els) = struct;
    then map_els(mor, els)!;
}

// Morphisms commute with nil and cons.
rule map_nil_els {
    if mapped = map_els(mor, nil_el_list(_));
    if cod = cod(mor);
    then mapped = nil_el_list(cod);
}
rule map_cons_els {
    if mapped = map_els(mor, cons_el_list(head, tail));
    then map_el(mor, head)!;
    then map_els(mor, tail)!;
    then mapped = cons_el_list(map_el(mor, head), map_els(mor, tail));
}

// Morphisms commute with function application, preserve
// variables and are compatible with predicates.
rule map_app_func {
    if mapped_result = map_el(mor, func_app(function, args));
    if mapped_args = map_els(mor, args);
    then mapped_result = func_app(function, mapped_args);
}
rule map_var {
    if el = var(_, name);
    if mapped_el = map_el(morph, el);
    if cod(morph) = cod_structure;
    then mapped_el = var(cod_structure, name);
}
rule map_pred_app {
    if pred_app(predicate, args);
    if mapped_args = map_els(_, args);
    then pred_app(predicate, mapped_args);
}

// Morphisms preserve and reflect types.
rule map_preserves_el_type {
    if el_type(el, typ);
    if mapped_el = map_el(_, el);
    then el_type(mapped_el, typ);
}
rule map_reflects_el_type {
    if el_type(map_el(_, el), typ);
    then el_type(el, typ);
}

// ### Kernel pairs of morphisms.

pred in_ker(Morphism, El, El);
rule in_ker_rule {
    if map_el(morph, el_0) = map_el(morph, el_1);
    then in_ker(morph, el_0, el_1);
}

// ### Images of morphisms.

pred el_in_img(Morphism, El);
rule el_in_img_rule {
    if map_el(morph, _) = el;
    then el_in_img(morph, el);
}

pred pred_tuple_in_img(Morphism, Pred, ElList);
rule pred_tuple_in_img_rule {
    if map_els(morphism, dom_els) = cod_els;
    if pred_app(predicate, dom_els);
    then pred_tuple_in_img(morphism, predicate, cod_els);
}

pred func_app_in_img(Morphism, Func, args: ElList);
rule func_app_in_img_rule {
    if map_els(morphism, dom_els) = cod_els;
    if func_app(function, dom_els)!;
    then func_app_in_img(morphism, function, cod_els);
}

// ## The initial structure

func initial_structure() -> Structure;
func initiality_morphism(Structure) -> Morphism;

rule initial_structure_total {
    then initial_structure()!;
}

rule initiality_morphism_total {
    if structure: Structure;
    then initiality_morphism(structure)!;
}

rule dom_cod_initiality_morphism {
    if initial_struct = initial_structure();
    if initiality_morph = initiality_morphism(structure);
    then dom(initiality_morph) = initial_struct;
    then cod(initiality_morph) = structure;
}

rule initiality_uniqueness {
    if dom(morph) = initial_structure();
    if cod(morph) = structure;
    then morph = initiality_morphism(structure);
}

// ## Non-empty chains of structures.

type Chain;
func nil_chain() -> Chain;
func chain_tail(Chain) -> Chain;
func chain_head_structure(Chain) -> Structure;
func chain_head_transition(Chain) -> Morphism;

rule chain_head_structure_defined {
    if chain_tail(chain)!;
    then chain_head_structure(chain)!;
}
rule chain_head_transition_defined {
    if chain_tail(chain_tail(chain))!;
    then chain_head_transition(chain)!;
}
rule chain_transition_signature {
    if tail = chain_tail(chain);
    if head_0 = chain_head_structure(chain);
    if trans = chain_head_transition(chain);
    if head_1 = chain_head_structure(tail);
    then dom(trans) = head_0;
    then cod(trans) = head_1;
}

// ## Symbol checks
//
// This is for facilitating checks for duplicated symbols, wrong symbol types,
// and wrong argument numbers.

type SymbolKind;
func type_symbol() -> SymbolKind;
func pred_symbol() -> SymbolKind;
func func_symbol() -> SymbolKind;
func rule_symbol() -> SymbolKind;
rule {
    then type_symbol()!;
    then pred_symbol()!;
    then func_symbol()!;
    then rule_symbol()!;
}

pred defined_symbol(Ident, SymbolKind, Loc);

rule type_decl_defines_symbol {
    if type_decl(decl, name);
    if kind = type_symbol();
    if loc = type_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule pred_decl_defines_symbol {
    if pred_decl(decl, name, _);
    if kind = pred_symbol();
    if loc = pred_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule func_decl_defines_symbol {
    if func_decl(decl, name, _, _);
    if kind = func_symbol();
    if loc = func_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}
rule rule_decl_defines_symbol {
    if rule_decl(decl, _);
    if name = rule_name(decl);
    if kind = rule_symbol();
    if loc = rule_decl_node_loc(decl);
    then defined_symbol(name, kind, loc);
}

// ### Symbol lookup checks
pred should_be_symbol(name: Ident, kind: SymbolKind, loc: Loc);

rule arg_decl_should_be_type {
    if arg_decl_node_type(arg_decl, name);
    if kind = type_symbol();
    if loc = arg_decl_node_loc(arg_decl);
    then should_be_symbol(name, kind, loc);
}
rule var_atom_should_be_type {
    if var_if_atom_node(atom, _, name);
    if kind = type_symbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol(name, kind, loc);
}
rule pred_if_atom_should_be_pred {
    if pred_if_atom_node(atom, pred_name, _);
    if kind = pred_symbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, loc);
}
rule pred_then_atom_should_be_pred {
    if pred_then_atom_node(atom, pred_name, _);
    if kind = pred_symbol();
    if loc = then_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, loc);
}
rule app_atom_should_be_func {
    if app_term_node(term, name, _);
    if kind = func_symbol();
    if loc = term_node_loc(term);
    then should_be_symbol(name, kind, loc);
}

// ### Natural numbers and argument numbers

type Nat;
func zero() -> Nat;
func succ(Nat) -> Nat;

func type_list_len(TypeList) -> Nat;
rule type_list_len_total {
    if tys: TypeList;
    then type_list_len(tys)!;
}
rule type_list_len_nil {
    if tys = nil_type_list();
    if len = type_list_len(tys);
    then len = zero();
}
rule type_list_len_cons {
    if tys = cons_type_list(_, tail);
    if len = type_list_len(tys);
    if tail_len = type_list_len(tail);
    then len = succ(tail_len);
}

func term_list_len(TermListNode) -> Nat;
rule term_list_len_total {
    if terms: TermListNode;
    then term_list_len(terms)!;
}
rule term_list_len_nil {
    if nil_term_list_node(terms);
    if len = term_list_len(terms);
    then len = zero();
}
rule term_list_len_cons {
    if cons_term_list_node(terms, _, tail);
    if len = term_list_len(terms);
    if tail_len = term_list_len(tail);
    then len = succ(tail_len);
}

pred pred_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);
pred func_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);

rule pred_if_atom_arg_num_should_match {
    if pred_if_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(arity(semantic_pred(name)));
    if loc = if_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}
rule pred_then_atom_arg_num_should_match {
    if pred_then_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(arity(semantic_pred(name)));
    if loc = then_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}

rule app_term_arg_num_should_match {
    if app_term_node(tm, name, args);
    if got_len = term_list_len(args);
    if expected_len = type_list_len(domain(semantic_func(name)));
    if loc = term_node_loc(tm);
    then func_arg_num_should_match(got_len, expected_len, loc);
}

// ## The Chain associated to a RuleDeclNode
//
// The chain of a rule has one structure for each statement in the rule. The
// structure associated to statement corresponds to all the data that has been
// hypothesized or concluded in this and prior statements.

func rule_chain(RuleDeclNode) -> Chain;
rule rule_chain_total {
    if rul: RuleDeclNode;
    then rule_chain(rul)!;
}
// The chain of rule always starts with the initial structure, with tail of the
// being given by the statements in the rule.
rule rule_stmt_list_chain {
    if rule_decl(rul, stmts);
    if rule_chain = rule_chain(rul);
    if stmts_chain = stmt_list_chain(stmts);
    then chain_tail(rule_chain) = stmts_chain;
    then initial_structure()!;
    then chain_head_structure(rule_chain) = initial_structure();
}

// ### The structure of the chain
func stmt_list_chain(StmtListNode) -> Chain;
rule stmt_list_chain_total {
    if stmts: StmtListNode;
    then stmt_list_chain(stmts)!;
}

rule stmt_list_chain_nil {
    if nil_stmt_list_node(stmts);
    if chain = stmt_list_chain(stmts);
    then chain = nil_chain();
}
rule stmt_list_chain_cons {
    if cons_stmt_list_node(stmts, _, tail_stmts);
    if stmts_chain = stmt_list_chain(stmts);
    if tail_chain = stmt_list_chain(tail_stmts);
    then chain_tail(stmts_chain) = tail_chain;
}

// ### Propagation of associated structures through the AST

// #### Propagate stmt structure through if and then stmts.
func stmt_structure(StmtNode) -> Structure;
func if_atom_structure(IfAtomNode) -> Structure;
func then_atom_structure(ThenAtomNode) -> Structure;
func term_structure(TermNode) -> Structure;
func terms_structure(TermListNode) -> Structure;
func opt_term_structure(OptTermNode) -> Structure;

rule stmt_structure_chain {
    if cons_stmt_list_node(stmts, stmt, _);
    if structure = chain_head_structure(stmt_list_chain(stmts));
    then stmt_structure(stmt) = structure;
}

rule if_stmt_structure {
    if if_stmt_node(stmt, atom);
    if structure = stmt_structure(stmt);
    then if_atom_structure(atom) = structure;
}
rule then_stmt_structure {
    if then_stmt_node(stmt, atom);
    if structure = stmt_structure(stmt);
    then then_atom_structure(atom) = structure;
}

// #### Propagate associated structures through if atoms.
rule equal_if_atom_structure {
    if equal_if_atom_node(atom, lhs, rhs);
    if structure = if_atom_structure(atom);
    then term_structure(lhs) = structure;
    then term_structure(rhs) = structure;
}
rule defined_if_atom_structure {
    if defined_if_atom_node(atom, term);
    if structure = if_atom_structure(atom);
    then term_structure(term) = structure;
}
rule pred_if_atom_structure {
    if pred_if_atom_node(atom, _, arg_terms);
    if structure = if_atom_structure(atom);
    then terms_structure(arg_terms) = structure;
}
rule var_if_atom_structure {
    if var_if_atom_node(atom, var_term, _);
    if structure = if_atom_structure(atom);
    then term_structure(var_term) = structure;
}

// #### Propagate associated structures through then atoms.
rule equal_then_atom_structure {
    if equal_then_atom_node(atom, lhs, rhs);
    if structure = then_atom_structure(atom);
    then term_structure(lhs) = structure;
    then term_structure(rhs) = structure;
}
rule defined_then_atom_structure {
    if defined_then_atom_node(atom, var_term, term);
    if structure = then_atom_structure(atom);
    then opt_term_structure(var_term) = structure;
    then term_structure(term) = structure;
}
rule pred_then_atom_structure {
    if pred_then_atom_node(atom, _, arg_terms);
    if structure = then_atom_structure(atom);
    then terms_structure(arg_terms) = structure;
}

// #### Propagate associated structures through terms.
rule cons_term_list_structure {
    if cons_term_list_node(terms, head, tail);
    if structure = terms_structure(terms);
    then term_structure(head) = structure;
    then terms_structure(tail) = structure;
}

rule some_opt_term_structure {
    if some_term_node(opt_term, term);
    if structure = opt_term_structure(opt_term);
    then term_structure(term) = structure;
}

rule app_term_structure {
    if app_term_node(term, _, args);
    if structure = term_structure(term);
    then terms_structure(args) = structure;
}

// ### Populate associated structures

func semantic_el(TermNode) -> El;
rule semantic_el_total {
    if el: TermNode;
    then semantic_el(el)!;
}

func semantic_els(TermListNode) -> ElList;
rule semantic_els_total {
    if els: TermListNode;
    then semantic_els(els)!;
}

rule semantic_els_nil {
    if nil_term_list_node(terms);
    if structure = terms_structure(terms);
    if sem_els = semantic_els(terms);
    then sem_els = nil_el_list(structure);
}
rule semantic_els_cons {
    if cons_term_list_node(terms, head, tail);
    if sem_els = semantic_els(terms);
    if head_sem_el = semantic_el(head);
    if tail_sem_els = semantic_els(tail);
    then sem_els = cons_el_list(head_sem_el, tail_sem_els);
}

// #### The structures of semantic elements
rule semantic_el_struct {
    if el = semantic_el(tm);
    if structure = term_structure(tm);
    then el_structure(el) = structure;
}
rule semantic_els_struct {
    if els = semantic_els(tms);
    if structure = terms_structure(tms);
    then els_structure(els) = structure;
}

// #### Semantics of terms
rule app_term_semantics {
    if app_term_node(result_term, func_name, arg_terms);
    if result_el = semantic_el(result_term);
    if arg_els = semantic_els(arg_terms);
    if function = semantic_func(func_name);
    then result_el = func_app(function, arg_els);
}

rule var_term_semantics {
    if var_term_node(term, name);
    if virt_name = real_virt_ident(name);
    if el = semantic_el(term);
    if structure = term_structure(term);
    then el = var(structure, virt_name);
}

func wildcard_virt_ident(TermNode) -> VirtIdent;
rule wildcard_virt_ident_defined {
    if wildcard_term_node(term);
    then wildcard_virt_ident(term)!;
}
rule wildcard_term_semantics {
    if wildcard_term_node(term);
    if name = wildcard_virt_ident(term);
    if el = semantic_el(term);
    if structure = term_structure(term);
    then el = var(structure, name);
}

// #### Semantics of if atoms
rule equal_if_atom_semantics {
    if equal_if_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term);
    if rhs_el = semantic_el(rhs_term);
    then lhs_el = rhs_el;
}
// No rule for `defined_if_atom` -- this is already taken care of because `semantic_el` is total.
rule pred_if_atom_semantics {
    if pred_if_atom_node(_, predicate_name, arg_terms);
    if predicate = semantic_pred(predicate_name);
    if arg_els = semantic_els(arg_terms);
    then pred_app(predicate, arg_els);
}
rule var_if_atom_semantics {
    if var_if_atom_node(_, var_term, type_name);
    if typ = semantic_type(type_name);
    if var_el = semantic_el(var_term);
    then el_type(var_el, typ);
}

// #### Semantics of then atoms
rule equal_then_atom_semantics {
    if equal_then_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term);
    if rhs_el = semantic_el(rhs_term);
    then lhs_el = rhs_el;
}
rule defined_then_atom_semantics {
    if defined_then_atom_node(_, opt_var_term, term);
    if some_term_node(opt_var_term, var_term);
    if var_el = semantic_el(var_term);
    if el = semantic_el(term);
    then var_el = el;
}
rule pred_then_atom_semantics {
    if pred_then_atom_node(_, predicate_name, arg_terms);
    if predicate = semantic_pred(predicate_name);
    if arg_els = semantic_els(arg_terms);
    then pred_app(predicate, arg_els);
}


// ### The *grouped* Chain associated to a RuleDeclNode
//
// The chain of a rule has one object for each *group* of statements, where
// groups are given by consecutive statements of the same type (i.e. either
// `if` or `then` statements). The structure associated to a statement group 
// is the structure in the (ungrouped) chain of the last statement in that
// group.
func grouped_rule_chain(RuleDeclNode) -> Chain;
rule grouped_rule_stmt_list_chain {
    if rule_decl(node, stmts);
    if grouped_chain = grouped_stmt_list_chain(stmts);
    then grouped_rule_chain(node) = grouped_chain;
}

func grouped_stmt_list_chain(StmtListNode) -> Chain;
rule grouped_stmt_list_chain_total {
    if stmts: StmtListNode;
    then grouped_stmt_list_chain(stmts)!;
}

// The grouped chain of the empty statement list is the empty chain.
rule grouped_stmt_list_chain_nil {
    if nil_stmt_list_node(stmts);
    if grouped_chain = grouped_stmt_list_chain(stmts);
    then grouped_chain = nil_chain();
}

// For either
//
// - two consecutive `if` statements, or
// - two consecutive `then` statements
//
// the chains of the two statements agree.
rule grouped_chain_if_if {
    if cons_stmt_list_node(stmts, first, stmts_tail);
    if cons_stmt_list_node(stmts_tail, second, _);
    if if_stmt_node(first, _);
    if if_stmt_node(second, _);
    if stmts_chain = grouped_stmt_list_chain(stmts);
    then grouped_stmt_list_chain(stmts_tail) = stmts_chain;
}
rule stmt_list_chain_then_then {
    if cons_stmt_list_node(stmts, first, stmts_tail);
    if cons_stmt_list_node(stmts_tail, second, _);
    if then_stmt_node(first, _);
    if then_stmt_node(second, _);
    if stmts_chain = grouped_stmt_list_chain(stmts);
    then grouped_stmt_list_chain(stmts_tail) = stmts_chain;
}

// For a statement followed by a statement of different type (e.g. `if`
// statement followed by a `then` statement or no statement at all), there is a
// transition in the grouped chain. The head of the chain agrees with the head
// of the ungrouped chain.
rule stmt_list_chain_singleton {
    if cons_stmt_list_node(stmts, _, stmts_tail);
    if nil_stmt_list_node(stmts_tail);
    if grouped_chain = grouped_stmt_list_chain(stmts);
    if grouped_tail_chain = grouped_stmt_list_chain(stmts_tail);
    if ungrouped_chain_head = chain_head_structure(stmt_list_chain(stmts));
    then chain_tail(grouped_chain) = grouped_tail_chain;
    then chain_head_structure(grouped_chain) = ungrouped_chain_head;
}
rule grouped_chain_if_then {
    if cons_stmt_list_node(stmts, first, stmts_tail);
    if cons_stmt_list_node(stmts_tail, second, _);
    if if_stmt_node(first, _);
    if then_stmt_node(second, _);
    if grouped_chain = grouped_stmt_list_chain(stmts);
    if grouped_tail_chain = grouped_stmt_list_chain(stmts_tail);
    if ungrouped_chain_head = chain_head_structure(stmt_list_chain(stmts));
    then chain_tail(grouped_chain) = grouped_tail_chain;
    then chain_head_structure(grouped_chain) = ungrouped_chain_head;
}
rule grouped_chain_then_if {
    if cons_stmt_list_node(stmts, first, stmts_tail);
    if cons_stmt_list_node(stmts_tail, second, _);
    if then_stmt_node(first, _);
    if if_stmt_node(second, _);
    if grouped_chain = grouped_stmt_list_chain(stmts);
    if grouped_tail_chain = grouped_stmt_list_chain(stmts_tail);
    if ungrouped_chain_head = chain_head_structure(stmt_list_chain(stmts));
    then chain_tail(grouped_chain) = grouped_tail_chain;
    then chain_head_structure(grouped_chain) = ungrouped_chain_head;
}

// ## Epic check

// ### Bound variables
//
// These predicates track which variables have been
// introduced in *statements* prior to the one in which
// the AST node appears.
pred var_before_term(TermNode, VirtIdent);
pred var_before_terms(TermListNode, VirtIdent);
pred var_before_opt_term(OptTermNode, VirtIdent);
pred var_before_if_atom(IfAtomNode, VirtIdent);
pred var_before_then_atom(ThenAtomNode, VirtIdent);
pred var_before_stmt(StmtNode, VirtIdent);
pred var_before_stmts(StmtListNode, VirtIdent);

// These predicates track which variables appear in the
// respective AST node.
pred var_in_term(TermNode, VirtIdent);
pred var_in_terms(TermListNode, VirtIdent);
pred var_in_opt_term(OptTermNode, VirtIdent);
pred var_in_if_atom(IfAtomNode, VirtIdent);
pred var_in_then_atom(ThenAtomNode, VirtIdent);
pred var_in_stmt(StmtNode, VirtIdent);

// #### Propagate var_before_X downwards
rule var_before_stmts_cons {
    if var_before_stmts(stmts, name);
    if cons_stmt_list_node(stmts, stmt, stmts_tail);
    then var_before_stmt(stmt, name);
    then var_before_stmts(stmts_tail, name);
}
rule var_before_stmt_if {
    if var_before_stmt(stmt, name);
    if if_stmt_node(stmt, atom);
    then var_before_if_atom(atom, name);
}
rule var_before_stmt_then {
    if var_before_stmt(stmt, name);
    if then_stmt_node(stmt, atom);
    then var_before_then_atom(atom, name);
}

rule var_before_if_atom_equal {
    if var_before_if_atom(atom, name);
    if equal_if_atom_node(atom, lhs, rhs);
    then var_before_term(lhs, name);
    then var_before_term(rhs, name);
}
rule var_before_if_atom_defined {
    if var_before_if_atom(atom, name);
    if defined_if_atom_node(atom, tm);
    then var_before_term(tm, name);
}
rule var_before_if_atom_pred {
    if var_before_if_atom(atom, name);
    if pred_if_atom_node(atom, _, args);
    then var_before_terms(args, name);
}
rule var_before_if_atom_var {
    if var_before_if_atom(atom, name);
    if var_if_atom_node(atom, var_term, _);
    then var_before_term(var_term, name);
}

rule var_before_then_atom_equal {
    if var_before_then_atom(atom, name);
    if equal_then_atom_node(atom, lhs, rhs);
    then var_before_term(lhs, name);
    then var_before_term(rhs, name);
}
rule var_before_then_atom_defined {
    if var_before_then_atom(atom, name);
    if defined_then_atom_node(atom, var_term, tm);
    then var_before_opt_term(var_term, name);
    then var_before_term(tm, name);
}
rule var_before_then_atom_pred {
    if var_before_then_atom(atom, name);
    if pred_then_atom_node(atom, _, args);
    then var_before_terms(args, name);
}

rule var_before_terms_cons {
    if var_before_terms(tms, name);
    if cons_term_list_node(tms, head, tail);
    then var_before_term(head, name);
    then var_before_terms(tail, name);
}

rule var_before_opt_term_some {
    if var_before_opt_term(opt_term, name);
    if some_term_node(opt_term, term);
    then var_before_term(term, name);
}

rule var_before_term_app {
    if var_before_term(tm, name);
    if app_term_node(tm, _, args);
    then var_before_terms(args, name);
}

// #### Propagate var_in_X upwards
rule var_in_term_var {
    if var_term_node(tm, ident);
    if name = real_virt_ident(ident);
    then var_in_term(tm, name);
}
rule var_in_term_wildcard {
    if wildcard_term_node(tm);
    if name = wildcard_virt_ident(tm);
    then var_in_term(tm, name);
}
rule var_in_term_app {
    if app_term_node(tm, _, args);
    if var_in_terms(args, name);
    then var_in_term(tm, name);
}

rule var_in_terms_cons_head {
    if cons_term_list_node(tms, head, _);
    if var_in_term(head, name);
    then var_in_terms(tms, name);
}
rule var_in_terms_cons_tail {
    if cons_term_list_node(tms, _, tail);
    if var_in_terms(tail, name);
    then var_in_terms(tms, name);
}

rule var_in_opt_terms {
    if some_term_node(opt_term, term);
    if var_in_term(term, name);
    then var_in_opt_term(opt_term, name);
}

rule var_in_if_atom_equal_lhs {
    if equal_if_atom_node(atom, lhs, _);
    if var_in_term(lhs, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_equal_rhs {
    if equal_if_atom_node(atom, _, rhs);
    if var_in_term(rhs, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_defined {
    if defined_if_atom_node(atom, tm);
    if var_in_term(tm, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_pred {
    if pred_if_atom_node(atom, _, args);
    if var_in_terms(args, name);
    then var_in_if_atom(atom, name);
}
rule var_in_if_atom_var {
    if var_if_atom_node(atom, var_term, _);
    if var_in_term(var_term, name);
    then var_in_if_atom(atom, name);
}

rule var_in_then_atom_equal_lhs {
    if equal_then_atom_node(atom, lhs, _);
    if var_in_term(lhs, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_equal_rhs {
    if equal_then_atom_node(atom, _, rhs);
    if var_in_term(rhs, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_defined_var_term {
    if defined_then_atom_node(atom, var_term, _);
    if var_in_opt_term(var_term, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_defined_term {
    if defined_then_atom_node(atom, _, tm);
    if var_in_term(tm, name);
    then var_in_then_atom(atom, name);
}
rule var_in_then_atom_pred {
    if pred_then_atom_node(atom, _, args);
    if var_in_terms(args, name);
    then var_in_then_atom(atom, name);
}

rule var_in_stmt_if {
    if if_stmt_node(stmt, atom);
    if var_in_if_atom(atom, name);
    then var_in_stmt(stmt, name);
}

rule var_in_stmt_then {
    if then_stmt_node(stmt, atom);
    if var_in_then_atom(atom, name);
    then var_in_stmt(stmt, name);
}

// #### Connect var_before_X and var_in_X

rule var_in_var_before {
    if cons_stmt_list_node(_, stmt, tail);
    if var_in_stmt(stmt, name);
    then var_before_stmts(tail, name);
}

// ### Terms that should need epic checking
//
// These are terms that appear in then statements.

pred term_should_be_epic_ok(TermNode);
pred terms_should_be_epic_ok(TermListNode);

// #### Propagate should_be_epic_ok downwards.
rule terms_should_be_epic_ok_cons {
    if terms_should_be_epic_ok(terms);
    if cons_term_list_node(terms, head, tail);
    then term_should_be_epic_ok(head);
    then terms_should_be_epic_ok(tail);
}

rule terms_should_be_epic_ok_app {
    if term_should_be_epic_ok(tm);
    if app_term_node(tm, _, args);
    then terms_should_be_epic_ok(args);
}

rule then_atom_epic_ok_equal {
    if equal_then_atom_node(_, lhs, rhs);
    then term_should_be_epic_ok(lhs);
    then term_should_be_epic_ok(rhs);
}
rule then_atom_epic_ok_defined {
    if defined_then_atom_node(_, _, tm);
    then term_should_be_epic_ok(tm);
}
rule then_atom_epic_ok_pred {
    if pred_then_atom_node(_, _, args);
    then terms_should_be_epic_ok(args);
}

// ## Surjectivity check

pred should_be_surjective(Morphism);
rule then_stmt_surjective {
    if cons_stmt_list_node(stmts, _, tail_stmts);
    if cons_stmt_list_node(tail_stmts, second_stmt, _);
    if then_stmt_node(second_stmt, _);
    if chain = stmt_list_chain(stmts);
    // TODO: This doesn't work if the first statement in a rule is a then
    // statement, since then there's no chain_head_transition. This should be
    // fixed by making every chain start with the initial structure.
    if morph = chain_head_transition(chain);
    then should_be_surjective(morph);
}

pred term_surjective_exempted(TermNode);
pred terms_surjective_exempted(TermListNode);

rule cons_head_tail_terms_surjective_exempted {
    if cons_term_list_node(tms, head, tail);
    if terms_surjective_exempted(tms);
    then term_surjective_exempted(head);
    then terms_surjective_exempted(tail);
}

rule head_tail_cons_terms_surjective_exempted {
    if cons_term_list_node(tms, head, tail);
    if term_surjective_exempted(head);
    if terms_surjective_exempted(tail);
    then terms_surjective_exempted(tms);
}

rule subterms_surjective_exempted {
    if app_term_node(tm, _, args);
    if term_surjective_exempted(tm);
    then terms_surjective_exempted(args);
}

rule defined_atom_surjective_exempted {
    if defined_then_atom_node(_, _, tm);
    then term_surjective_exempted(tm);
}

pred el_surjective_exempted(El);

rule semantic_el_exempted {
    if term_surjective_exempted(tm);
    if el = semantic_el(tm);
    then el_surjective_exempted(el);
}

pred el_should_be_surjective_ok(El);
pred el_is_surjective_ok(El);

rule surjective_codomain_should_be_ok {
    if should_be_surjective(morph);
    if el_structure(el) = cod(morph);
    then el_should_be_surjective_ok(el);
}

rule surjective_exempted_el_is_ok {
    if el_surjective_exempted(el);
    then el_is_surjective_ok(el);
}

rule surjective_img_el_is_ok {
    if should_be_surjective(morph);
    if el_in_img(morph, el);
    then el_is_surjective_ok(el);
}

// ## Variable occurs twice check

pred var_term_in_rule(TermNode, Ident, RuleDeclNode);
rule var_term_in_rule_child {
    if var_term_node(tm, ident);
    if rule_child(rule_child_term(tm), rul);
    then var_term_in_rule(tm, ident, rul);
}

// ## If-after-then check
pred if_after_then(if_stmt: StmtNode);

rule after_then_should_be_if {
    if cons_stmt_list_node(_, first, tail);
    if then_stmt_node(first, _);
    if cons_stmt_list_node(tail, second, _);
    if if_stmt_node(second, _);
    then if_after_then(second);
}
