// src-digest: 668D9469A1587298830DFDF67467D2C6203BA728016E58EEA707998D23FA8391
use eqlog_runtime::tabled::{
    object::Segment, Alignment, Extract, Header, Modify, Style, Table, Tabled,
};
#[allow(unused)]
use eqlog_runtime::Unification;
#[allow(unused)]
use std::collections::{BTreeMap, BTreeSet};
use std::fmt;
use std::ops::Bound;

#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Ident(pub u32);
impl Into<u32> for Ident {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Ident {
    fn from(x: u32) -> Self {
        Ident(x)
    }
}
impl fmt::Display for Ident {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct VirtIdent(pub u32);
impl Into<u32> for VirtIdent {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for VirtIdent {
    fn from(x: u32) -> Self {
        VirtIdent(x)
    }
}
impl fmt::Display for VirtIdent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeDeclNode(pub u32);
impl Into<u32> for TypeDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TypeDeclNode {
    fn from(x: u32) -> Self {
        TypeDeclNode(x)
    }
}
impl fmt::Display for TypeDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclNode(pub u32);
impl Into<u32> for ArgDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ArgDeclNode {
    fn from(x: u32) -> Self {
        ArgDeclNode(x)
    }
}
impl fmt::Display for ArgDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclListNode(pub u32);
impl Into<u32> for ArgDeclListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ArgDeclListNode {
    fn from(x: u32) -> Self {
        ArgDeclListNode(x)
    }
}
impl fmt::Display for ArgDeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct PredDeclNode(pub u32);
impl Into<u32> for PredDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for PredDeclNode {
    fn from(x: u32) -> Self {
        PredDeclNode(x)
    }
}
impl fmt::Display for PredDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct FuncDeclNode(pub u32);
impl Into<u32> for FuncDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for FuncDeclNode {
    fn from(x: u32) -> Self {
        FuncDeclNode(x)
    }
}
impl fmt::Display for FuncDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermNode(pub u32);
impl Into<u32> for TermNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TermNode {
    fn from(x: u32) -> Self {
        TermNode(x)
    }
}
impl fmt::Display for TermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermListNode(pub u32);
impl Into<u32> for TermListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TermListNode {
    fn from(x: u32) -> Self {
        TermListNode(x)
    }
}
impl fmt::Display for TermListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct OptTermNode(pub u32);
impl Into<u32> for OptTermNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for OptTermNode {
    fn from(x: u32) -> Self {
        OptTermNode(x)
    }
}
impl fmt::Display for OptTermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct IfAtomNode(pub u32);
impl Into<u32> for IfAtomNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for IfAtomNode {
    fn from(x: u32) -> Self {
        IfAtomNode(x)
    }
}
impl fmt::Display for IfAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ThenAtomNode(pub u32);
impl Into<u32> for ThenAtomNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ThenAtomNode {
    fn from(x: u32) -> Self {
        ThenAtomNode(x)
    }
}
impl fmt::Display for ThenAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtNode(pub u32);
impl Into<u32> for StmtNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for StmtNode {
    fn from(x: u32) -> Self {
        StmtNode(x)
    }
}
impl fmt::Display for StmtNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtListNode(pub u32);
impl Into<u32> for StmtListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for StmtListNode {
    fn from(x: u32) -> Self {
        StmtListNode(x)
    }
}
impl fmt::Display for StmtListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleDeclNode(pub u32);
impl Into<u32> for RuleDeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for RuleDeclNode {
    fn from(x: u32) -> Self {
        RuleDeclNode(x)
    }
}
impl fmt::Display for RuleDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclNode(pub u32);
impl Into<u32> for DeclNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for DeclNode {
    fn from(x: u32) -> Self {
        DeclNode(x)
    }
}
impl fmt::Display for DeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclListNode(pub u32);
impl Into<u32> for DeclListNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for DeclListNode {
    fn from(x: u32) -> Self {
        DeclListNode(x)
    }
}
impl fmt::Display for DeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ModuleNode(pub u32);
impl Into<u32> for ModuleNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ModuleNode {
    fn from(x: u32) -> Self {
        ModuleNode(x)
    }
}
impl fmt::Display for ModuleNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Loc(pub u32);
impl Into<u32> for Loc {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Loc {
    fn from(x: u32) -> Self {
        Loc(x)
    }
}
impl fmt::Display for Loc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleChildNode(pub u32);
impl Into<u32> for RuleChildNode {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for RuleChildNode {
    fn from(x: u32) -> Self {
        RuleChildNode(x)
    }
}
impl fmt::Display for RuleChildNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Type(pub u32);
impl Into<u32> for Type {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Type {
    fn from(x: u32) -> Self {
        Type(x)
    }
}
impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeList(pub u32);
impl Into<u32> for TypeList {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for TypeList {
    fn from(x: u32) -> Self {
        TypeList(x)
    }
}
impl fmt::Display for TypeList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Pred(pub u32);
impl Into<u32> for Pred {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Pred {
    fn from(x: u32) -> Self {
        Pred(x)
    }
}
impl fmt::Display for Pred {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Func(pub u32);
impl Into<u32> for Func {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Func {
    fn from(x: u32) -> Self {
        Func(x)
    }
}
impl fmt::Display for Func {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Structure(pub u32);
impl Into<u32> for Structure {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Structure {
    fn from(x: u32) -> Self {
        Structure(x)
    }
}
impl fmt::Display for Structure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct El(pub u32);
impl Into<u32> for El {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for El {
    fn from(x: u32) -> Self {
        El(x)
    }
}
impl fmt::Display for El {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElList(pub u32);
impl Into<u32> for ElList {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for ElList {
    fn from(x: u32) -> Self {
        ElList(x)
    }
}
impl fmt::Display for ElList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Morphism(pub u32);
impl Into<u32> for Morphism {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Morphism {
    fn from(x: u32) -> Self {
        Morphism(x)
    }
}
impl fmt::Display for Morphism {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Chain(pub u32);
impl Into<u32> for Chain {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Chain {
    fn from(x: u32) -> Self {
        Chain(x)
    }
}
impl fmt::Display for Chain {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct SymbolKind(pub u32);
impl Into<u32> for SymbolKind {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for SymbolKind {
    fn from(x: u32) -> Self {
        SymbolKind(x)
    }
}
impl fmt::Display for SymbolKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Nat(pub u32);
impl Into<u32> for Nat {
    fn into(self) -> u32 {
        self.0
    }
}
impl From<u32> for Nat {
    fn from(x: u32) -> Self {
        Nat(x)
    }
}
impl fmt::Display for Nat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Absurd();
#[derive(Clone, Hash, Debug)]
struct AbsurdTable {
    index_all: BTreeSet<()>,
    index_dirty: BTreeSet<()>,

    index_dirty_prev: Vec<BTreeSet<()>>,
}
impl AbsurdTable {
    #[allow(unused)]
    const WEIGHT: usize = 0;
    fn new() -> Self {
        Self {
            index_all: BTreeSet::new(),
            index_dirty: BTreeSet::new(),
            index_dirty_prev: Vec::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Absurd) -> bool {
        if self.index_all.insert(Self::permute(t)) {
            self.index_dirty.insert(Self::permute(t));

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Absurd) -> bool {
        if self.index_dirty.insert(Self::permute(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Absurd) -> bool {
        self.index_all.contains(&Self::permute(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty, &mut self.index_dirty);
        self.index_dirty_prev.push(tmp_dirty);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty.is_empty()
    }
    #[allow(unused)]
    fn permute(t: Absurd) -> () {
        ()
    }
    #[allow(unused)]
    fn permute_inverse(t: ()) -> Absurd {
        Absurd()
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Absurd> {
        let min = ();
        let max = ();
        self.index_all
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Absurd> {
        let min = ();
        let max = ();
        self.index_dirty
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse)
    }
    fn recall_previous_dirt(&mut self) {
        let mut tmp_dirty_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_prev, &mut self.index_dirty_prev);

        for tuple in tmp_dirty_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse(tuple);
            if true {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for AbsurdTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("absurd"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDecl(pub TypeDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct TypeDeclTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<TypeDecl>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDecl>>,
}
impl TypeDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeDecl) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TypeDecl) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeDecl) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeDecl) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeDecl {
        TypeDecl(TypeDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = TypeDecl> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(
        &mut self,
        tm: TypeDeclNode,
    ) -> impl '_ + Iterator<Item = TypeDecl> {
        let ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        type_decl_node_equalities: &mut Unification<TypeDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == type_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TypeDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeName(pub ArgDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeNameTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeName>>,
    element_index_ident: BTreeMap<Ident, Vec<ArgDeclNodeName>>,
}
impl ArgDeclNodeNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeName) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ArgDeclNodeName) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeName) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeName) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeName {
        ArgDeclNodeName(ArgDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(
        &mut self,
        tm: ArgDeclNode,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(
        &mut self,
        tm: Ident,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_node_equalities: &mut Unification<ArgDeclNode>,
        ident_equalities: &mut Unification<Ident>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == arg_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ArgDeclNodeNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeType(pub ArgDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeType>>,
    element_index_ident: BTreeMap<Ident, Vec<ArgDeclNodeType>>,
}
impl ArgDeclNodeTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ArgDeclNodeType) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeType {
        ArgDeclNodeType(ArgDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ArgDeclNodeType) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ArgDeclNodeType {
        ArgDeclNodeType(ArgDeclNode::from(t.1), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(
        &mut self,
        tm: ArgDeclNode,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(
        &mut self,
        tm: Ident,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_node_equalities: &mut Unification<ArgDeclNode>,
        ident_equalities: &mut Unification<Ident>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == arg_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ArgDeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilArgDeclListNode(pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilArgDeclListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<NilArgDeclListNode>>,
}
impl NilArgDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilArgDeclListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilArgDeclListNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilArgDeclListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilArgDeclListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilArgDeclListNode {
        NilArgDeclListNode(ArgDeclListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
    ) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == arg_decl_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsArgDeclListNode(pub ArgDeclListNode, pub ArgDeclNode, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsArgDeclListNodeTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ConsArgDeclListNode>>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ConsArgDeclListNode>>,
}
impl ConsArgDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_arg_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsArgDeclListNode) -> bool {
        if self.index_all_1_0_2.insert(Self::permute_1_0_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_arg_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsArgDeclListNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsArgDeclListNode) -> bool {
        self.index_all_1_0_2.contains(&Self::permute_1_0_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsArgDeclListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsArgDeclListNode {
        ConsArgDeclListNode(
            ArgDeclListNode::from(t.0),
            ArgDeclNode::from(t.1),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsArgDeclListNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsArgDeclListNode {
        ConsArgDeclListNode(
            ArgDeclListNode::from(t.1),
            ArgDeclNode::from(t.0),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsArgDeclListNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsArgDeclListNode {
        ConsArgDeclListNode(
            ArgDeclListNode::from(t.1),
            ArgDeclNode::from(t.2),
            ArgDeclListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ArgDeclNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(
        &mut self,
        tm: ArgDeclNode,
    ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
        let ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
        arg_decl_node_equalities: &mut Unification<ArgDeclNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == arg_decl_list_node_equalities.root(tuple.0)
                && tuple.1 == arg_decl_node_equalities.root(tuple.1)
                && tuple.2 == arg_decl_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDecl(pub PredDeclNode, pub Ident, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct PredDeclTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<PredDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<PredDecl>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDecl>>,
}
impl PredDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredDecl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredDecl) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredDecl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredDecl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredDecl {
        PredDecl(
            PredDeclNode::from(t.0),
            Ident::from(t.1),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: PredDecl) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> PredDecl {
        PredDecl(
            PredDeclNode::from(t.1),
            Ident::from(t.0),
            ArgDeclListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: PredDecl) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> PredDecl {
        PredDecl(
            PredDeclNode::from(t.1),
            Ident::from(t.2),
            ArgDeclListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = PredDecl> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = PredDecl> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = PredDecl> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(
        &mut self,
        tm: PredDeclNode,
    ) -> impl '_ + Iterator<Item = PredDecl> {
        let ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
        ident_equalities: &mut Unification<Ident>,
        pred_decl_node_equalities: &mut Unification<PredDeclNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == pred_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == arg_decl_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDecl(pub FuncDeclNode, pub Ident, pub ArgDeclListNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct FuncDeclTable {
    index_all_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_dirty_0_1_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_all_1_0_2_3: BTreeSet<(u32, u32, u32, u32)>,
    index_all_2_0_1_3: BTreeSet<(u32, u32, u32, u32)>,
    index_all_3_0_1_2: BTreeSet<(u32, u32, u32, u32)>,

    index_dirty_0_1_2_3_prev: Vec<BTreeSet<(u32, u32, u32, u32)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<FuncDecl>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<FuncDecl>>,
}
impl FuncDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 24;
    fn new() -> Self {
        Self {
            index_all_0_1_2_3: BTreeSet::new(),
            index_dirty_0_1_2_3: BTreeSet::new(),
            index_all_1_0_2_3: BTreeSet::new(),
            index_all_2_0_1_3: BTreeSet::new(),
            index_all_3_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_3_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_func_decl_node: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncDecl) -> bool {
        if self.index_all_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
            self.index_dirty_0_1_2_3.insert(Self::permute_0_1_2_3(t));
            self.index_all_1_0_2_3.insert(Self::permute_1_0_2_3(t));
            self.index_all_2_0_1_3.insert(Self::permute_2_0_1_3(t));
            self.index_all_3_0_1_2.insert(Self::permute_3_0_1_2(t));

            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.2, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.3, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncDecl) -> bool {
        if self.index_dirty_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncDecl) -> bool {
        self.index_all_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2_3.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2_3 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_3, &mut self.index_dirty_0_1_2_3);
        self.index_dirty_0_1_2_3_prev.push(tmp_dirty_0_1_2_3);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2_3.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2_3(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.0),
            Ident::from(t.1),
            ArgDeclListNode::from(t.2),
            Ident::from(t.3),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2_3(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2_3(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.1),
            Ident::from(t.0),
            ArgDeclListNode::from(t.2),
            Ident::from(t.3),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1_3(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into(), t.3.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1_3(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.1),
            Ident::from(t.2),
            ArgDeclListNode::from(t.0),
            Ident::from(t.3),
        )
    }
    #[allow(unused)]
    fn permute_3_0_1_2(t: FuncDecl) -> (u32, u32, u32, u32) {
        (t.3.into(), t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_3_0_1_2(t: (u32, u32, u32, u32)) -> FuncDecl {
        FuncDecl(
            FuncDeclNode::from(t.1),
            Ident::from(t.2),
            ArgDeclListNode::from(t.3),
            Ident::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncDecl> {
        let min = (u32::MIN, u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2_3)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1_3
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1_3)
    }
    #[allow(dead_code)]
    fn iter_all_3(&self, arg3: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
        let arg3 = arg3.0;
        let min = (arg3, u32::MIN, u32::MIN, u32::MIN);
        let max = (arg3, u32::MAX, u32::MAX, u32::MAX);
        self.index_all_3_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_3_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = FuncDecl> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(*t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(*t));
                self.index_all_1_0_2_3.remove(&Self::permute_1_0_2_3(*t));
                self.index_all_2_0_1_3.remove(&Self::permute_2_0_1_3(*t));
                self.index_all_3_0_1_2.remove(&Self::permute_3_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(
        &mut self,
        tm: FuncDeclNode,
    ) -> impl '_ + Iterator<Item = FuncDecl> {
        let ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(*t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(*t));
                self.index_all_1_0_2_3.remove(&Self::permute_1_0_2_3(*t));
                self.index_all_2_0_1_3.remove(&Self::permute_2_0_1_3(*t));
                self.index_all_3_0_1_2.remove(&Self::permute_3_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2_3.remove(&Self::permute_0_1_2_3(*t)) {
                self.index_dirty_0_1_2_3.remove(&Self::permute_0_1_2_3(*t));
                self.index_all_1_0_2_3.remove(&Self::permute_1_0_2_3(*t));
                self.index_all_2_0_1_3.remove(&Self::permute_2_0_1_3(*t));
                self.index_all_3_0_1_2.remove(&Self::permute_3_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
        func_decl_node_equalities: &mut Unification<FuncDeclNode>,
        ident_equalities: &mut Unification<Ident>,
    ) {
        let mut tmp_dirty_0_1_2_3_prev = Vec::new();
        std::mem::swap(
            &mut tmp_dirty_0_1_2_3_prev,
            &mut self.index_dirty_0_1_2_3_prev,
        );

        for tuple in tmp_dirty_0_1_2_3_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2_3(tuple);
            if true
                && tuple.0 == func_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == arg_decl_list_node_equalities.root(tuple.2)
                && tuple.3 == ident_equalities.root(tuple.3)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTermListNode(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct NilTermListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<NilTermListNode>>,
}
impl NilTermListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilTermListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilTermListNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilTermListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilTermListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilTermListNode {
        NilTermListNode(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilTermListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilTermListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = NilTermListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = NilTermListNode> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_list_node_equalities: &mut Unification<TermListNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTermListNode(pub TermListNode, pub TermNode, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct ConsTermListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<ConsTermListNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<ConsTermListNode>>,
}
impl ConsTermListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsTermListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsTermListNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsTermListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.0),
            TermNode::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.1),
            TermNode::from(t.0),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsTermListNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsTermListNode {
        ConsTermListNode(
            TermListNode::from(t.1),
            TermNode::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = ConsTermListNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_list_node_equalities: &mut Unification<TermListNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
                && tuple.2 == term_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NoneTermNode(pub OptTermNode);
#[derive(Clone, Hash, Debug)]
struct NoneTermNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<NoneTermNode>>,
}
impl NoneTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NoneTermNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NoneTermNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NoneTermNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NoneTermNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NoneTermNode {
        NoneTermNode(OptTermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NoneTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NoneTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = NoneTermNode> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, opt_term_node_equalities: &mut Unification<OptTermNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == opt_term_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NoneTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("none_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SomeTermNode(pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct SomeTermNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<SomeTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SomeTermNode>>,
}
impl SomeTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SomeTermNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SomeTermNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SomeTermNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SomeTermNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SomeTermNode {
        SomeTermNode(OptTermNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SomeTermNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SomeTermNode {
        SomeTermNode(OptTermNode::from(t.1), TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SomeTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SomeTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = SomeTermNode> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = SomeTermNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SomeTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("some_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarTermNode(pub TermNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct VarTermNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<VarTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarTermNode>>,
}
impl VarTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarTermNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarTermNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarTermNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarTermNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarTermNode {
        VarTermNode(TermNode::from(t.0), Ident::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: VarTermNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> VarTermNode {
        VarTermNode(TermNode::from(t.1), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarTermNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = VarTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = VarTermNode> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = VarTermNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardTermNode(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct WildcardTermNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<WildcardTermNode>>,
}
impl WildcardTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: WildcardTermNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: WildcardTermNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: WildcardTermNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: WildcardTermNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> WildcardTermNode {
        WildcardTermNode(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = WildcardTermNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_node_equalities: &mut Unification<TermNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for WildcardTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AppTermNode(pub TermNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct AppTermNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<AppTermNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<AppTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<AppTermNode>>,
}
impl AppTermNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: AppTermNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: AppTermNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: AppTermNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: AppTermNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: AppTermNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.1),
            Ident::from(t.0),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: AppTermNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> AppTermNode {
        AppTermNode(
            TermNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = AppTermNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = AppTermNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = AppTermNode> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = AppTermNode> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = AppTermNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        term_list_node_equalities: &mut Unification<TermListNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == term_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for AppTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("app_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualIfAtomNode(pub IfAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualIfAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<EqualIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<EqualIfAtomNode>>,
}
impl EqualIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EqualIfAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: EqualIfAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EqualIfAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.0),
            TermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.1),
            TermNode::from(t.0),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: EqualIfAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> EqualIfAtomNode {
        EqualIfAtomNode(
            IfAtomNode::from(t.1),
            TermNode::from(t.2),
            TermNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
                && tuple.2 == term_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for EqualIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedIfAtomNode(pub IfAtomNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedIfAtomNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<DefinedIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedIfAtomNode>>,
}
impl DefinedIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedIfAtomNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DefinedIfAtomNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedIfAtomNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DefinedIfAtomNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DefinedIfAtomNode {
        DefinedIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: DefinedIfAtomNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> DefinedIfAtomNode {
        DefinedIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DefinedIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredIfAtomNode(pub IfAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredIfAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<PredIfAtomNode>>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<PredIfAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredIfAtomNode>>,
}
impl PredIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredIfAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredIfAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredIfAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.1),
            Ident::from(t.0),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: PredIfAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> PredIfAtomNode {
        PredIfAtomNode(
            IfAtomNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = PredIfAtomNode> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == term_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarIfAtomNode(pub IfAtomNode, pub TermNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct VarIfAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<VarIfAtomNode>>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<VarIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarIfAtomNode>>,
}
impl VarIfAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarIfAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarIfAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarIfAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: VarIfAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> VarIfAtomNode {
        VarIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1), Ident::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: VarIfAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> VarIfAtomNode {
        VarIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.0), Ident::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: VarIfAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> VarIfAtomNode {
        VarIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.2), Ident::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: Ident) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = VarIfAtomNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
                && tuple.2 == ident_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualThenAtomNode(pub ThenAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualThenAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<EqualThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<EqualThenAtomNode>>,
}
impl EqualThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: EqualThenAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: EqualThenAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: EqualThenAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.0),
            TermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.1),
            TermNode::from(t.0),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: EqualThenAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> EqualThenAtomNode {
        EqualThenAtomNode(
            ThenAtomNode::from(t.1),
            TermNode::from(t.2),
            TermNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_node_equalities: &mut Unification<TermNode>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == term_node_equalities.root(tuple.1)
                && tuple.2 == term_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for EqualThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedThenAtomNode(pub ThenAtomNode, pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedThenAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<DefinedThenAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<DefinedThenAtomNode>>,
}
impl DefinedThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedThenAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_opt_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DefinedThenAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedThenAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.0),
            OptTermNode::from(t.1),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.1),
            OptTermNode::from(t.0),
            TermNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: DefinedThenAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> DefinedThenAtomNode {
        DefinedThenAtomNode(
            ThenAtomNode::from(t.1),
            OptTermNode::from(t.2),
            TermNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: OptTermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        term_node_equalities: &mut Unification<TermNode>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == opt_term_node_equalities.root(tuple.1)
                && tuple.2 == term_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DefinedThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredThenAtomNode(pub ThenAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredThenAtomNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<PredThenAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<PredThenAtomNode>>,
}
impl PredThenAtomNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredThenAtomNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredThenAtomNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredThenAtomNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.0),
            Ident::from(t.1),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.1),
            Ident::from(t.0),
            TermListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: PredThenAtomNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> PredThenAtomNode {
        PredThenAtomNode(
            ThenAtomNode::from(t.1),
            Ident::from(t.2),
            TermListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(
        &mut self,
        tm: Ident,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = PredThenAtomNode> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        term_list_node_equalities: &mut Unification<TermListNode>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == term_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfStmtNode(pub StmtNode, pub IfAtomNode);
#[derive(Clone, Hash, Debug)]
struct IfStmtNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<IfStmtNode>>,
}
impl IfStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfStmtNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_if_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: IfStmtNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfStmtNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfStmtNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfStmtNode {
        IfStmtNode(StmtNode::from(t.0), IfAtomNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: IfStmtNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> IfStmtNode {
        IfStmtNode(StmtNode::from(t.1), IfAtomNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = IfStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: IfAtomNode) -> impl '_ + Iterator<Item = IfStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = IfStmtNode> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = IfStmtNode> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        stmt_node_equalities: &mut Unification<StmtNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == if_atom_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for IfStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenStmtNode(pub StmtNode, pub ThenAtomNode);
#[derive(Clone, Hash, Debug)]
struct ThenStmtNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_stmt_node: BTreeMap<StmtNode, Vec<ThenStmtNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenStmtNode>>,
}
impl ThenStmtNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenStmtNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_then_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ThenStmtNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenStmtNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenStmtNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenStmtNode {
        ThenStmtNode(StmtNode::from(t.0), ThenAtomNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ThenStmtNode) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ThenStmtNode {
        ThenStmtNode(StmtNode::from(t.1), ThenAtomNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ThenAtomNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = ThenStmtNode> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_node_equalities: &mut Unification<StmtNode>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == then_atom_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ThenStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilStmtListNode(pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct NilStmtListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<NilStmtListNode>>,
}
impl NilStmtListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilStmtListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilStmtListNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilStmtListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilStmtListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilStmtListNode {
        NilStmtListNode(StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = NilStmtListNode> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, stmt_list_node_equalities: &mut Unification<StmtListNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == stmt_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsStmtListNode(pub StmtListNode, pub StmtNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct ConsStmtListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<ConsStmtListNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<ConsStmtListNode>>,
}
impl ConsStmtListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsStmtListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsStmtListNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsStmtListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.0),
            StmtNode::from(t.1),
            StmtListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.1),
            StmtNode::from(t.0),
            StmtListNode::from(t.2),
        )
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsStmtListNode) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsStmtListNode {
        ConsStmtListNode(
            StmtListNode::from(t.1),
            StmtNode::from(t.2),
            StmtListNode::from(t.0),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = ConsStmtListNode> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
        stmt_node_equalities: &mut Unification<StmtNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == stmt_node_equalities.root(tuple.1)
                && tuple.2 == stmt_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDecl(pub RuleDeclNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct RuleDeclTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDecl>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleDecl>>,
}
impl RuleDeclTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_decl_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDecl) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleDecl) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDecl) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDecl) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDecl {
        RuleDecl(RuleDeclNode::from(t.0), StmtListNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleDecl) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleDecl {
        RuleDecl(RuleDeclNode::from(t.1), StmtListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDecl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDecl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = RuleDecl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleDecl> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = RuleDecl> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_decl_node_equalities.root(tuple.0)
                && tuple.1 == stmt_list_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeType(pub DeclNode, pub TypeDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeType>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<DeclNodeType>>,
}
impl DeclNodeTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclNodeType) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeType {
        DeclNodeType(DeclNode::from(t.0), TypeDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeType> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(
        &mut self,
        tm: TypeDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeType> {
        let ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_node_equalities: &mut Unification<DeclNode>,
        type_decl_node_equalities: &mut Unification<TypeDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_node_equalities.root(tuple.0)
                && tuple.1 == type_decl_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodePred(pub DeclNode, pub PredDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodePredTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodePred>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<DeclNodePred>>,
}
impl DeclNodePredTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodePred) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_pred_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclNodePred) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodePred) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodePred) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodePred {
        DeclNodePred(DeclNode::from(t.0), PredDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodePred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodePred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodePred> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(
        &mut self,
        tm: PredDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodePred> {
        let ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_node_equalities: &mut Unification<DeclNode>,
        pred_decl_node_equalities: &mut Unification<PredDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_node_equalities.root(tuple.0)
                && tuple.1 == pred_decl_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclNodePredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeFunc(pub DeclNode, pub FuncDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeFuncTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeFunc>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<DeclNodeFunc>>,
}
impl DeclNodeFuncTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_func_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeFunc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_func_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclNodeFunc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeFunc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeFunc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeFunc {
        DeclNodeFunc(DeclNode::from(t.0), FuncDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(
        &mut self,
        tm: FuncDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeFunc> {
        let ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_node_equalities: &mut Unification<DeclNode>,
        func_decl_node_equalities: &mut Unification<FuncDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_node_equalities.root(tuple.0)
                && tuple.1 == func_decl_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclNodeFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeRule(pub DeclNode, pub RuleDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeRuleTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeRule>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<DeclNodeRule>>,
}
impl DeclNodeRuleTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeRule) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclNodeRule) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeRule) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeRule) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeRule {
        DeclNodeRule(DeclNode::from(t.0), RuleDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeRule> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_node_equalities: &mut Unification<DeclNode>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_node_equalities.root(tuple.0)
                && tuple.1 == rule_decl_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclNodeRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilDeclListNode(pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilDeclListNodeTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<NilDeclListNode>>,
}
impl NilDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_decl_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilDeclListNode) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilDeclListNode) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilDeclListNode) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilDeclListNode) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilDeclListNode {
        NilDeclListNode(DeclListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(
        &mut self,
        tm: DeclListNode,
    ) -> impl '_ + Iterator<Item = NilDeclListNode> {
        let ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, decl_list_node_equalities: &mut Unification<DeclListNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == decl_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsDeclListNode(pub DeclListNode, pub DeclNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsDeclListNodeTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<ConsDeclListNode>>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<ConsDeclListNode>>,
}
impl ConsDeclListNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsDeclListNode) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.1, vec![t]);
                }
            };

            match self.element_index_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsDeclListNode) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsDeclListNode) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsDeclListNode) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsDeclListNode {
        ConsDeclListNode(
            DeclListNode::from(t.0),
            DeclNode::from(t.1),
            DeclListNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(
        &mut self,
        tm: DeclListNode,
    ) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = ConsDeclListNode> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_list_node_equalities: &mut Unification<DeclListNode>,
        decl_node_equalities: &mut Unification<DeclNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == decl_list_node_equalities.root(tuple.0)
                && tuple.1 == decl_node_equalities.root(tuple.1)
                && tuple.2 == decl_list_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclsModuleNode(pub ModuleNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct DeclsModuleNodeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclsModuleNode>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<DeclsModuleNode>>,
}
impl DeclsModuleNodeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_module_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclsModuleNode) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_module_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_decl_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclsModuleNode) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclsModuleNode) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclsModuleNode) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclsModuleNode {
        DeclsModuleNode(ModuleNode::from(t.0), DeclListNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(
        &mut self,
        tm: DeclListNode,
    ) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_module_node(
        &mut self,
        tm: ModuleNode,
    ) -> impl '_ + Iterator<Item = DeclsModuleNode> {
        let ts = match self.element_index_module_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_list_node_equalities: &mut Unification<DeclListNode>,
        module_node_equalities: &mut Unification<ModuleNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == module_node_equalities.root(tuple.0)
                && tuple.1 == decl_list_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclsModuleNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decls_module_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChild(pub RuleChildNode, pub RuleDeclNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChild>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleChild>>,
}
impl RuleChildTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChild) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_child_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChild) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChild) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChild) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChild {
        RuleChild(RuleChildNode::from(t.0), RuleDeclNode::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChild> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChild> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleChildNode) -> impl '_ + Iterator<Item = RuleChild> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: RuleChildNode,
        arg1: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleChild> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChild> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleChild> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_child_node_equalities.root(tuple.0)
                && tuple.1 == rule_decl_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredApp(pub Pred, pub ElList);
#[derive(Clone, Hash, Debug)]
struct PredAppTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<PredApp>>,
    element_index_pred: BTreeMap<Pred, Vec<PredApp>>,
}
impl PredAppTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_pred: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredApp) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredApp) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredApp) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: PredApp) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> PredApp {
        PredApp(Pred::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: PredApp) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> PredApp {
        PredApp(Pred::from(t.1), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredApp> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredApp> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredApp> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Pred, arg1: ElList) -> impl '_ + Iterator<Item = PredApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = PredApp> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = PredApp> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> impl '_ + Iterator<Item = PredApp> {
        let ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        pred_equalities: &mut Unification<Pred>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == pred_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElType(pub El, pub Type);
#[derive(Clone, Hash, Debug)]
struct ElTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<ElType>>,
    element_index_type: BTreeMap<Type, Vec<ElType>>,
}
impl ElTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElType) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElType {
        ElType(El::from(t.0), Type::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: Type) -> impl '_ + Iterator<Item = ElType> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ElType> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> impl '_ + Iterator<Item = ElType> {
        let ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        type_equalities: &mut Unification<Type>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == el_equalities.root(tuple.0)
                && tuple.1 == type_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElTypes(pub ElList, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ElTypesTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<ElTypes>>,
    element_index_type_list: BTreeMap<TypeList, Vec<ElTypes>>,
}
impl ElTypesTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElTypes) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElTypes) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElTypes) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElTypes) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElTypes {
        ElTypes(ElList::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElTypes) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElTypes {
        ElTypes(ElList::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: ElList, arg1: TypeList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = ElTypes> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = ElTypes> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> impl '_ + Iterator<Item = ElTypes> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == el_list_equalities.root(tuple.0)
                && tuple.1 == type_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEl(pub El);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_el: BTreeMap<El, Vec<ConstrainedEl>>,
}
impl ConstrainedElTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConstrainedEl) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConstrainedEl) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConstrainedEl) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ConstrainedEl) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ConstrainedEl {
        ConstrainedEl(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ConstrainedEl> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, el_equalities: &mut Unification<El>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == el_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConstrainedElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEls(pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElsTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_el_list: BTreeMap<ElList, Vec<ConstrainedEls>>,
}
impl ConstrainedElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConstrainedEls) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConstrainedEls) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConstrainedEls) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ConstrainedEls) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ConstrainedEls {
        ConstrainedEls(ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(
        &mut self,
        tm: ElList,
    ) -> impl '_ + Iterator<Item = ConstrainedEls> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, el_list_equalities: &mut Unification<ElList>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == el_list_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConstrainedElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InKer(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct InKerTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<InKer>>,
    element_index_morphism: BTreeMap<Morphism, Vec<InKer>>,
}
impl InKerTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: InKer) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: InKer) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: InKer) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: InKer) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> InKer {
        InKer(Morphism::from(t.0), El::from(t.1), El::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = InKer> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = InKer> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: El,
        arg2: El,
    ) -> impl '_ + Iterator<Item = InKer> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = InKer> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = InKer> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == el_equalities.root(tuple.1)
                && tuple.2 == el_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for InKerTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("in_ker"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElInImg(pub Morphism, pub El);
#[derive(Clone, Hash, Debug)]
struct ElInImgTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<ElInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<ElInImg>>,
}
impl ElInImgTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElInImg) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElInImg) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElInImg) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElInImg) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElInImg {
        ElInImg(Morphism::from(t.0), El::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElInImg> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElInImg> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = ElInImg> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = ElInImg> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ElInImg> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = ElInImg> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == el_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredTupleInImg(pub Morphism, pub Pred, pub ElList);
#[derive(Clone, Hash, Debug)]
struct PredTupleInImgTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<PredTupleInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<PredTupleInImg>>,
    element_index_pred: BTreeMap<Pred, Vec<PredTupleInImg>>,
}
impl PredTupleInImgTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_pred: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredTupleInImg) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_pred.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredTupleInImg) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredTupleInImg) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredTupleInImg) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredTupleInImg {
        PredTupleInImg(Morphism::from(t.0), Pred::from(t.1), ElList::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: Pred,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(
        &mut self,
        tm: ElList,
    ) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(
        &mut self,
        tm: Morphism,
    ) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> impl '_ + Iterator<Item = PredTupleInImg> {
        let ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        morphism_equalities: &mut Unification<Morphism>,
        pred_equalities: &mut Unification<Pred>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == pred_equalities.root(tuple.1)
                && tuple.2 == el_list_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredTupleInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_tuple_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncAppInImg(pub Morphism, pub Func, pub ElList);
#[derive(Clone, Hash, Debug)]
struct FuncAppInImgTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<FuncAppInImg>>,
    element_index_func: BTreeMap<Func, Vec<FuncAppInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<FuncAppInImg>>,
}
impl FuncAppInImgTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_func: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncAppInImg) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncAppInImg) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncAppInImg) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: FuncAppInImg) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> FuncAppInImg {
        FuncAppInImg(Morphism::from(t.0), Func::from(t.1), ElList::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Morphism,
        arg1: Func,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(
        &mut self,
        tm: ElList,
    ) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(
        &mut self,
        tm: Morphism,
    ) -> impl '_ + Iterator<Item = FuncAppInImg> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        func_equalities: &mut Unification<Func>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == func_equalities.root(tuple.1)
                && tuple.2 == el_list_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncAppInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_app_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedSymbol(pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DefinedSymbolTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<DefinedSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<DefinedSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<DefinedSymbol>>,
}
impl DefinedSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DefinedSymbol) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DefinedSymbol) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DefinedSymbol) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: DefinedSymbol) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> DefinedSymbol {
        DefinedSymbol(Ident::from(t.0), SymbolKind::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Ident,
        arg1: SymbolKind,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = DefinedSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        loc_equalities: &mut Unification<Loc>,
        symbol_kind_equalities: &mut Unification<SymbolKind>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == symbol_kind_equalities.root(tuple.1)
                && tuple.2 == loc_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DefinedSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol(pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbolTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol>>,
}
impl ShouldBeSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ShouldBeSymbol) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ShouldBeSymbol) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ShouldBeSymbol) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ShouldBeSymbol) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ShouldBeSymbol {
        ShouldBeSymbol(Ident::from(t.0), SymbolKind::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Ident,
        arg1: SymbolKind,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        loc_equalities: &mut Unification<Loc>,
        symbol_kind_equalities: &mut Unification<SymbolKind>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == symbol_kind_equalities.root(tuple.1)
                && tuple.2 == loc_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ShouldBeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredArgNumShouldMatchTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<PredArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<PredArgNumShouldMatch>>,
}
impl PredArgNumShouldMatchTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredArgNumShouldMatch) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredArgNumShouldMatch) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredArgNumShouldMatch) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: PredArgNumShouldMatch) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> PredArgNumShouldMatch {
        PredArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Nat,
        arg1: Nat,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(
        &mut self,
        tm: Loc,
    ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(
        &mut self,
        tm: Nat,
    ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        nat_equalities: &mut Unification<Nat>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == nat_equalities.root(tuple.0)
                && tuple.1 == nat_equalities.root(tuple.1)
                && tuple.2 == loc_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncArgNumShouldMatchTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<FuncArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<FuncArgNumShouldMatch>>,
}
impl FuncArgNumShouldMatchTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncArgNumShouldMatch) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncArgNumShouldMatch) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncArgNumShouldMatch) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: FuncArgNumShouldMatch) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> FuncArgNumShouldMatch {
        FuncArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Nat,
        arg1: Nat,
        arg2: Loc,
    ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(
        &mut self,
        tm: Loc,
    ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(
        &mut self,
        tm: Nat,
    ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        nat_equalities: &mut Unification<Nat>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == nat_equalities.root(tuple.0)
                && tuple.1 == nat_equalities.root(tuple.1)
                && tuple.2 == loc_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeTerm(pub TermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<VarBeforeTerm>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeTerm>>,
}
impl VarBeforeTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeTerm {
        VarBeforeTerm(TermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeTerm> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_node_equalities: &mut Unification<TermNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeTerms(pub TermListNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeTermsTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<VarBeforeTerms>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeTerms>>,
}
impl VarBeforeTermsTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeTerms) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeTerms) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeTerms) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeTerms) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeTerms {
        VarBeforeTerms(TermListNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeTerms> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_list_node_equalities: &mut Unification<TermListNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeTermsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_terms"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeOptTerm(pub OptTermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeOptTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<VarBeforeOptTerm>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeOptTerm>>,
}
impl VarBeforeOptTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeOptTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeOptTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeOptTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeOptTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeOptTerm {
        VarBeforeOptTerm(OptTermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeOptTerm> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeOptTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_opt_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeIfAtom(pub IfAtomNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeIfAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<VarBeforeIfAtom>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeIfAtom>>,
}
impl VarBeforeIfAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeIfAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeIfAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeIfAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeIfAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeIfAtom {
        VarBeforeIfAtom(IfAtomNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeIfAtom> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeIfAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_if_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeThenAtom(pub ThenAtomNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeThenAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<VarBeforeThenAtom>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeThenAtom>>,
}
impl VarBeforeThenAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_then_atom_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeThenAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeThenAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeThenAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeThenAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeThenAtom {
        VarBeforeThenAtom(ThenAtomNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeThenAtom> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeThenAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_then_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeStmt(pub StmtNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_stmt_node: BTreeMap<StmtNode, Vec<VarBeforeStmt>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeStmt>>,
}
impl VarBeforeStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeStmt) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeStmt {
        VarBeforeStmt(StmtNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeStmt> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_node_equalities: &mut Unification<StmtNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarBeforeStmts(pub StmtListNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarBeforeStmtsTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<VarBeforeStmts>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarBeforeStmts>>,
}
impl VarBeforeStmtsTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_stmt_list_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarBeforeStmts) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarBeforeStmts) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarBeforeStmts) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarBeforeStmts) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarBeforeStmts {
        VarBeforeStmts(StmtListNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarBeforeStmts> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarBeforeStmtsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_before_stmts"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInTerm(pub TermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<VarInTerm>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInTerm>>,
}
impl VarInTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInTerm {
        VarInTerm(TermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarInTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = VarInTerm> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInTerm> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_node_equalities: &mut Unification<TermNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInTerms(pub TermListNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInTermsTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<VarInTerms>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInTerms>>,
}
impl VarInTermsTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInTerms) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInTerms) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInTerms) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInTerms) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInTerms {
        VarInTerms(TermListNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInTerms> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInTerms> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = VarInTerms> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInTerms> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = VarInTerms> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInTerms> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_list_node_equalities: &mut Unification<TermListNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInTermsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_terms"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInOptTerm(pub OptTermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInOptTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<VarInOptTerm>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInOptTerm>>,
}
impl VarInOptTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInOptTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInOptTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInOptTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInOptTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInOptTerm {
        VarInOptTerm(OptTermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInOptTerm> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInOptTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_opt_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInIfAtom(pub IfAtomNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInIfAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<VarInIfAtom>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInIfAtom>>,
}
impl VarInIfAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInIfAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInIfAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInIfAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInIfAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInIfAtom {
        VarInIfAtom(IfAtomNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInIfAtom> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInIfAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_if_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInThenAtom(pub ThenAtomNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInThenAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<VarInThenAtom>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInThenAtom>>,
}
impl VarInThenAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_then_atom_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInThenAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInThenAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInThenAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInThenAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInThenAtom {
        VarInThenAtom(ThenAtomNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInThenAtom> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInThenAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_then_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInStmt(pub StmtNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarInStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_stmt_node: BTreeMap<StmtNode, Vec<VarInStmt>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInStmt>>,
}
impl VarInStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarInStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarInStmt) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarInStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: VarInStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> VarInStmt {
        VarInStmt(StmtNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarInStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarInStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = VarInStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInStmt> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = VarInStmt> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = VarInStmt> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_node_equalities: &mut Unification<StmtNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarInStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermShouldBeEpicOk(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct TermShouldBeEpicOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<TermShouldBeEpicOk>>,
}
impl TermShouldBeEpicOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermShouldBeEpicOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermShouldBeEpicOk) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermShouldBeEpicOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermShouldBeEpicOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermShouldBeEpicOk {
        TermShouldBeEpicOk(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_node_equalities: &mut Unification<TermNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsShouldBeEpicOk(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct TermsShouldBeEpicOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsShouldBeEpicOk>>,
}
impl TermsShouldBeEpicOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermsShouldBeEpicOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermsShouldBeEpicOk) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermsShouldBeEpicOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermsShouldBeEpicOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermsShouldBeEpicOk {
        TermsShouldBeEpicOk(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_list_node_equalities: &mut Unification<TermListNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermsShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSurjective(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSurjectiveTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_morphism: BTreeMap<Morphism, Vec<ShouldBeSurjective>>,
}
impl ShouldBeSurjectiveTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ShouldBeSurjective) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ShouldBeSurjective) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ShouldBeSurjective) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ShouldBeSurjective) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ShouldBeSurjective {
        ShouldBeSurjective(Morphism::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ShouldBeSurjective> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ShouldBeSurjective> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = ShouldBeSurjective> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(
        &mut self,
        tm: Morphism,
    ) -> impl '_ + Iterator<Item = ShouldBeSurjective> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, morphism_equalities: &mut Unification<Morphism>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == morphism_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ShouldBeSurjectiveTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_surjective"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermSurjectiveExempted(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct TermSurjectiveExemptedTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<TermSurjectiveExempted>>,
}
impl TermSurjectiveExemptedTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermSurjectiveExempted) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermSurjectiveExempted) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermSurjectiveExempted) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermSurjectiveExempted) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermSurjectiveExempted {
        TermSurjectiveExempted(TermNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermSurjectiveExempted> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = TermSurjectiveExempted> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_node_equalities: &mut Unification<TermNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermSurjectiveExemptedTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_surjective_exempted"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsSurjectiveExempted(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct TermsSurjectiveExemptedTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsSurjectiveExempted>>,
}
impl TermsSurjectiveExemptedTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermsSurjectiveExempted) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermsSurjectiveExempted) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermsSurjectiveExempted) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TermsSurjectiveExempted) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TermsSurjectiveExempted {
        TermsSurjectiveExempted(TermListNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermsSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermsSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsSurjectiveExempted> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = TermsSurjectiveExempted> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, term_list_node_equalities: &mut Unification<TermListNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == term_list_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermsSurjectiveExemptedTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_surjective_exempted"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElSurjectiveExempted(pub El);
#[derive(Clone, Hash, Debug)]
struct ElSurjectiveExemptedTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_el: BTreeMap<El, Vec<ElSurjectiveExempted>>,
}
impl ElSurjectiveExemptedTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElSurjectiveExempted) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElSurjectiveExempted) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElSurjectiveExempted) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ElSurjectiveExempted) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ElSurjectiveExempted {
        ElSurjectiveExempted(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElSurjectiveExempted> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElSurjectiveExempted> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ElSurjectiveExempted> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, el_equalities: &mut Unification<El>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == el_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElSurjectiveExemptedTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_surjective_exempted"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElShouldBeSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElShouldBeSurjectiveOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_el: BTreeMap<El, Vec<ElShouldBeSurjectiveOk>>,
}
impl ElShouldBeSurjectiveOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElShouldBeSurjectiveOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElShouldBeSurjectiveOk) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElShouldBeSurjectiveOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ElShouldBeSurjectiveOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ElShouldBeSurjectiveOk {
        ElShouldBeSurjectiveOk(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(
        &mut self,
        tm: El,
    ) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, el_equalities: &mut Unification<El>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == el_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElShouldBeSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_should_be_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElIsSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElIsSurjectiveOkTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_el: BTreeMap<El, Vec<ElIsSurjectiveOk>>,
}
impl ElIsSurjectiveOkTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElIsSurjectiveOk) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElIsSurjectiveOk) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElIsSurjectiveOk) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: ElIsSurjectiveOk) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> ElIsSurjectiveOk {
        ElIsSurjectiveOk(El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, el_equalities: &mut Unification<El>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == el_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElIsSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_is_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarTermInRule(pub TermNode, pub Ident, pub RuleDeclNode);
#[derive(Clone, Hash, Debug)]
struct VarTermInRuleTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<VarTermInRule>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<VarTermInRule>>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarTermInRule>>,
}
impl VarTermInRuleTable {
    #[allow(unused)]
    const WEIGHT: usize = 9;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: VarTermInRule) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_rule_decl_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: VarTermInRule) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: VarTermInRule) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: VarTermInRule) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> VarTermInRule {
        VarTermInRule(
            TermNode::from(t.0),
            Ident::from(t.1),
            RuleDeclNode::from(t.2),
        )
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = VarTermInRule> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = VarTermInRule> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: TermNode,
        arg1: Ident,
        arg2: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = VarTermInRule> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = VarTermInRule> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = VarTermInRule> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = VarTermInRule> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
                && tuple.2 == rule_decl_node_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarTermInRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_term_in_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAfterThen(pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct IfAfterThenTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_stmt_node: BTreeMap<StmtNode, Vec<IfAfterThen>>,
}
impl IfAfterThenTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAfterThen) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: IfAfterThen) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAfterThen) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: IfAfterThen) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> IfAfterThen {
        IfAfterThen(StmtNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAfterThen> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAfterThen> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = IfAfterThen> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = IfAfterThen> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, stmt_node_equalities: &mut Unification<StmtNode>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == stmt_node_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for IfAfterThenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_after_then"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RealVirtIdent(pub Ident, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct RealVirtIdentTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<RealVirtIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<RealVirtIdent>>,
}
impl RealVirtIdentTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RealVirtIdent) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RealVirtIdent) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RealVirtIdent) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RealVirtIdent) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RealVirtIdent {
        RealVirtIdent(Ident::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = RealVirtIdent> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RealVirtIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("real_virt_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleName(pub RuleDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct RuleNameTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<RuleName>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleName>>,
}
impl RuleNameTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleName) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleName) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleName) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleName) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleName {
        RuleName(RuleDeclNode::from(t.0), Ident::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleName> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleName> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = RuleName> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleName> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_decl_node_equalities.root(tuple.0)
                && tuple.1 == ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDeclNodeLoc(pub TypeDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TypeDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<TypeDeclNodeLoc>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDeclNodeLoc>>,
}
impl TypeDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_type_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TypeDeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeDeclNodeLoc {
        TypeDeclNodeLoc(TypeDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_decl_node(
        &mut self,
        tm: TypeDeclNode,
    ) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
        let ts = match self.element_index_type_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        type_decl_node_equalities: &mut Unification<TypeDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == type_decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TypeDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeLoc(pub ArgDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclNodeLoc>>,
}
impl ArgDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_arg_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ArgDeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclNodeLoc {
        ArgDeclNodeLoc(ArgDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_node(
        &mut self,
        tm: ArgDeclNode,
    ) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let ts = match self.element_index_arg_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_node_equalities: &mut Unification<ArgDeclNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == arg_decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ArgDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclListNodeLoc(pub ArgDeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ArgDeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclListNodeLoc>>,
}
impl ArgDeclListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ArgDeclListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ArgDeclListNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ArgDeclListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ArgDeclListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ArgDeclListNodeLoc {
        ArgDeclListNodeLoc(ArgDeclListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == arg_decl_list_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ArgDeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDeclNodeLoc(pub PredDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<PredDeclNodeLoc>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDeclNodeLoc>>,
}
impl PredDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_pred_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredDeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: PredDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> PredDeclNodeLoc {
        PredDeclNodeLoc(PredDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred_decl_node(
        &mut self,
        tm: PredDeclNode,
    ) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
        let ts = match self.element_index_pred_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        pred_decl_node_equalities: &mut Unification<PredDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == pred_decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDeclNodeLoc(pub FuncDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<FuncDeclNodeLoc>>,
}
impl FuncDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_func_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncDeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: FuncDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> FuncDeclNodeLoc {
        FuncDeclNodeLoc(FuncDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_func_decl_node(
        &mut self,
        tm: FuncDeclNode,
    ) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let ts = match self.element_index_func_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        func_decl_node_equalities: &mut Unification<FuncDeclNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == func_decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermNodeLoc(pub TermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<TermNodeLoc>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermNodeLoc>>,
}
impl TermNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermNodeLoc {
        TermNodeLoc(TermNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = TermNodeLoc> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListNodeLoc(pub TermListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<TermListNodeLoc>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListNodeLoc>>,
}
impl TermListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermListNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermListNodeLoc {
        TermListNodeLoc(TermListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = TermListNodeLoc> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermNodeLoc(pub OptTermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct OptTermNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<OptTermNodeLoc>>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermNodeLoc>>,
}
impl OptTermNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_opt_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: OptTermNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: OptTermNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: OptTermNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: OptTermNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> OptTermNodeLoc {
        OptTermNodeLoc(OptTermNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for OptTermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomNodeLoc(pub IfAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct IfAtomNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<IfAtomNodeLoc>>,
}
impl IfAtomNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAtomNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: IfAtomNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAtomNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfAtomNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfAtomNodeLoc {
        IfAtomNodeLoc(IfAtomNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for IfAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomNodeLoc(pub ThenAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ThenAtomNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<ThenAtomNodeLoc>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomNodeLoc>>,
}
impl ThenAtomNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenAtomNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ThenAtomNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenAtomNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenAtomNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenAtomNodeLoc {
        ThenAtomNodeLoc(ThenAtomNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ThenAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtNodeLoc(pub StmtNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<StmtNodeLoc>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtNodeLoc>>,
}
impl StmtNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: StmtNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtNodeLoc {
        StmtNodeLoc(StmtNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = StmtNodeLoc> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        stmt_node_equalities: &mut Unification<StmtNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for StmtNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListNodeLoc(pub StmtListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<StmtListNodeLoc>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<StmtListNodeLoc>>,
}
impl StmtListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: StmtListNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtListNodeLoc {
        StmtListNodeLoc(StmtListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for StmtListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDeclNodeLoc(pub RuleDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct RuleDeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<RuleDeclNodeLoc>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDeclNodeLoc>>,
}
impl RuleDeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleDeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleDeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleDeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleDeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleDeclNodeLoc {
        RuleDeclNodeLoc(RuleDeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeLoc(pub DeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclNodeLoc>>,
}
impl DeclNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclNodeLoc {
        DeclNodeLoc(DeclNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_node(
        &mut self,
        tm: DeclNode,
    ) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let ts = match self.element_index_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = DeclNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_node_equalities: &mut Unification<DeclNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclListNodeLoc(pub DeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclListNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclListNodeLoc>>,
}
impl DeclListNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_decl_list_node: BTreeMap::new(),
            element_index_loc: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: DeclListNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: DeclListNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: DeclListNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: DeclListNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> DeclListNodeLoc {
        DeclListNodeLoc(DeclListNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_decl_list_node(
        &mut self,
        tm: DeclListNode,
    ) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let ts = match self.element_index_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        decl_list_node_equalities: &mut Unification<DeclListNode>,
        loc_equalities: &mut Unification<Loc>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == decl_list_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNodeLoc(pub ModuleNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ModuleNodeLocTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_loc: BTreeMap<Loc, Vec<ModuleNodeLoc>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<ModuleNodeLoc>>,
}
impl ModuleNodeLocTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_loc: BTreeMap::new(),
            element_index_module_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ModuleNodeLoc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_module_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_loc.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ModuleNodeLoc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ModuleNodeLoc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ModuleNodeLoc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ModuleNodeLoc {
        ModuleNodeLoc(ModuleNode::from(t.0), Loc::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_loc(&mut self, tm: Loc) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let ts = match self.element_index_loc.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_module_node(
        &mut self,
        tm: ModuleNode,
    ) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
        let ts = match self.element_index_module_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        loc_equalities: &mut Unification<Loc>,
        module_node_equalities: &mut Unification<ModuleNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == module_node_equalities.root(tuple.0)
                && tuple.1 == loc_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ModuleNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("module_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildTerm(pub TermNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildTerm>>,
    element_index_term_node: BTreeMap<TermNode, Vec<RuleChildTerm>>,
}
impl RuleChildTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildTerm {
        RuleChildTerm(TermNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildTerm) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildTerm {
        RuleChildTerm(TermNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = RuleChildTerm> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildTermList(pub TermListNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildTermListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildTermList>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<RuleChildTermList>>,
}
impl RuleChildTermListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildTermList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildTermList) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildTermList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildTermList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildTermList {
        RuleChildTermList(TermListNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildTermList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildTermList {
        RuleChildTermList(TermListNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = RuleChildTermList> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildTermListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_term_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildOptTerm(pub OptTermNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildOptTermTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<RuleChildOptTerm>>,
    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildOptTerm>>,
}
impl RuleChildOptTermTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_rule_child_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildOptTerm) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildOptTerm) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildOptTerm) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildOptTerm) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildOptTerm {
        RuleChildOptTerm(OptTermNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildOptTerm) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildOptTerm {
        RuleChildOptTerm(OptTermNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildOptTerm> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildOptTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_opt_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildIfAtom(pub IfAtomNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildIfAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<RuleChildIfAtom>>,
    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildIfAtom>>,
}
impl RuleChildIfAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_rule_child_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildIfAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildIfAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildIfAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildIfAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildIfAtom {
        RuleChildIfAtom(IfAtomNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildIfAtom) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildIfAtom {
        RuleChildIfAtom(IfAtomNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildIfAtom> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildIfAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_if_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildThenAtom(pub ThenAtomNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildThenAtomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildThenAtom>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<RuleChildThenAtom>>,
}
impl RuleChildThenAtomTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildThenAtom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildThenAtom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildThenAtom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildThenAtom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildThenAtom {
        RuleChildThenAtom(ThenAtomNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildThenAtom) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildThenAtom {
        RuleChildThenAtom(ThenAtomNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = RuleChildThenAtom> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildThenAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_then_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildStmt(pub StmtNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildStmtTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<RuleChildStmt>>,
}
impl RuleChildStmtTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_stmt_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildStmt) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildStmt) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildStmt) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildStmt) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildStmt {
        RuleChildStmt(StmtNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildStmt) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildStmt {
        RuleChildStmt(StmtNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = RuleChildStmt> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        stmt_node_equalities: &mut Unification<StmtNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChildStmtList(pub StmtListNode, pub RuleChildNode);
#[derive(Clone, Hash, Debug)]
struct RuleChildStmtListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_rule_child_node: BTreeMap<RuleChildNode, Vec<RuleChildStmtList>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleChildStmtList>>,
}
impl RuleChildStmtListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_rule_child_node: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChildStmtList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_rule_child_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_child_node.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChildStmtList) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChildStmtList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChildStmtList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChildStmtList {
        RuleChildStmtList(StmtListNode::from(t.0), RuleChildNode::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: RuleChildStmtList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> RuleChildStmtList {
        RuleChildStmtList(StmtListNode::from(t.1), RuleChildNode::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: RuleChildNode) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_child_node(
        &mut self,
        tm: RuleChildNode,
    ) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let ts = match self.element_index_rule_child_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = RuleChildStmtList> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        rule_child_node_equalities: &mut Unification<RuleChildNode>,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == rule_child_node_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChildStmtListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_child_stmt_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTypeList(pub TypeList);
#[derive(Clone, Hash, Debug)]
struct NilTypeListTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_type_list: BTreeMap<TypeList, Vec<NilTypeList>>,
}
impl NilTypeListTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilTypeList) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilTypeList) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilTypeList) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilTypeList) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilTypeList {
        NilTypeList(TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilTypeList> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilTypeList> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = NilTypeList> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(
        &mut self,
        tm: TypeList,
    ) -> impl '_ + Iterator<Item = NilTypeList> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, type_list_equalities: &mut Unification<TypeList>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == type_list_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_type_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTypeList(pub Type, pub TypeList, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ConsTypeListTable {
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_type: BTreeMap<Type, Vec<ConsTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<ConsTypeList>>,
}
impl ConsTypeListTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_type: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsTypeList) -> bool {
        if self.index_all_1_0_2.insert(Self::permute_1_0_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsTypeList) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsTypeList) -> bool {
        self.index_all_1_0_2.contains(&Self::permute_1_0_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsTypeList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.0), TypeList::from(t.1), TypeList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsTypeList) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.1), TypeList::from(t.0), TypeList::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsTypeList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsTypeList {
        ConsTypeList(Type::from(t.1), TypeList::from(t.2), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsTypeList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Type, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg1, arg0, u32::MIN);
        let max = (arg1, arg0, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> impl '_ + Iterator<Item = ConsTypeList> {
        let ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(
        &mut self,
        tm: TypeList,
    ) -> impl '_ + Iterator<Item = ConsTypeList> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        type_equalities: &mut Unification<Type>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == type_equalities.root(tuple.0)
                && tuple.1 == type_list_equalities.root(tuple.1)
                && tuple.2 == type_list_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_type_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticType(pub Ident, pub Type);
#[derive(Clone, Hash, Debug)]
struct SemanticTypeTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<SemanticType>>,
    element_index_type: BTreeMap<Type, Vec<SemanticType>>,
}
impl SemanticTypeTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticType) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticType) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticType) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticType) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticType {
        SemanticType(Ident::from(t.0), Type::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticType> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticType> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = SemanticType> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> impl '_ + Iterator<Item = SemanticType> {
        let ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        type_equalities: &mut Unification<Type>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == type_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypes(pub ArgDeclListNode, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct SemanticArgTypesTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<SemanticArgTypes>>,
    element_index_type_list: BTreeMap<TypeList, Vec<SemanticArgTypes>>,
}
impl SemanticArgTypesTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_arg_decl_list_node: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticArgTypes) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_arg_decl_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticArgTypes) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticArgTypes) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticArgTypes) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticArgTypes {
        SemanticArgTypes(ArgDeclListNode::from(t.0), TypeList::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ArgDeclListNode,
        arg1: TypeList,
    ) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_arg_decl_list_node(
        &mut self,
        tm: ArgDeclListNode,
    ) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let ts = match self.element_index_arg_decl_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(
        &mut self,
        tm: TypeList,
    ) -> impl '_ + Iterator<Item = SemanticArgTypes> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        arg_decl_list_node_equalities: &mut Unification<ArgDeclListNode>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == arg_decl_list_node_equalities.root(tuple.0)
                && tuple.1 == type_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticArgTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_arg_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticPred(pub Ident, pub Pred);
#[derive(Clone, Hash, Debug)]
struct SemanticPredTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_ident: BTreeMap<Ident, Vec<SemanticPred>>,
    element_index_pred: BTreeMap<Pred, Vec<SemanticPred>>,
}
impl SemanticPredTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_ident: BTreeMap::new(),
            element_index_pred: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticPred) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_pred.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticPred) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticPred) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticPred) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticPred {
        SemanticPred(Ident::from(t.0), Pred::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticPred) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticPred {
        SemanticPred(Ident::from(t.1), Pred::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticPred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticPred> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticPred> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = SemanticPred> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
        let ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        ident_equalities: &mut Unification<Ident>,
        pred_equalities: &mut Unification<Pred>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == pred_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticPredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Arity(pub Pred, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ArityTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_pred: BTreeMap<Pred, Vec<Arity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Arity>>,
}
impl ArityTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_pred: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Arity) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_pred.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Arity) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Arity) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Arity) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Arity {
        Arity(Pred::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Arity) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Arity {
        Arity(Pred::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Arity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Arity> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = Arity> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Pred, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_pred(&mut self, tm: Pred) -> impl '_ + Iterator<Item = Arity> {
        let ts = match self.element_index_pred.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> impl '_ + Iterator<Item = Arity> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        pred_equalities: &mut Unification<Pred>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == pred_equalities.root(tuple.0)
                && tuple.1 == type_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticFunc(pub Ident, pub Func);
#[derive(Clone, Hash, Debug)]
struct SemanticFuncTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_func: BTreeMap<Func, Vec<SemanticFunc>>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticFunc>>,
}
impl SemanticFuncTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_func: BTreeMap::new(),
            element_index_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticFunc) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_ident.insert(t.0, vec![t]);
                }
            };

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticFunc) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticFunc) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticFunc) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticFunc {
        SemanticFunc(Ident::from(t.0), Func::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: SemanticFunc) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> SemanticFunc {
        SemanticFunc(Ident::from(t.1), Func::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticFunc> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = SemanticFunc> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
        let ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_ident(&mut self, tm: Ident) -> impl '_ + Iterator<Item = SemanticFunc> {
        let ts = match self.element_index_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        func_equalities: &mut Unification<Func>,
        ident_equalities: &mut Unification<Ident>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == ident_equalities.root(tuple.0)
                && tuple.1 == func_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Domain(pub Func, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct DomainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_func: BTreeMap<Func, Vec<Domain>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Domain>>,
}
impl DomainTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_func: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Domain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Domain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Domain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Domain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Domain {
        Domain(Func::from(t.0), TypeList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Domain) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Domain {
        Domain(Func::from(t.1), TypeList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Domain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Domain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Domain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> impl '_ + Iterator<Item = Domain> {
        let ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(&mut self, tm: TypeList) -> impl '_ + Iterator<Item = Domain> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        func_equalities: &mut Unification<Func>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == func_equalities.root(tuple.0)
                && tuple.1 == type_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("domain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Codomain(pub Func, pub Type);
#[derive(Clone, Hash, Debug)]
struct CodomainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_func: BTreeMap<Func, Vec<Codomain>>,
    element_index_type: BTreeMap<Type, Vec<Codomain>>,
}
impl CodomainTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_func: BTreeMap::new(),
            element_index_type: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Codomain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Codomain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Codomain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Codomain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Codomain {
        Codomain(Func::from(t.0), Type::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Codomain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Codomain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Codomain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> impl '_ + Iterator<Item = Codomain> {
        let ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type(&mut self, tm: Type) -> impl '_ + Iterator<Item = Codomain> {
        let ts = match self.element_index_type.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        func_equalities: &mut Unification<Func>,
        type_equalities: &mut Unification<Type>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == func_equalities.root(tuple.0)
                && tuple.1 == type_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for CodomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("codomain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElList(pub Structure, pub ElList);
#[derive(Clone, Hash, Debug)]
struct NilElListTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<NilElList>>,
    element_index_structure: BTreeMap<Structure, Vec<NilElList>>,
}
impl NilElListTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilElList) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilElList) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilElList) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: NilElList) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> NilElList {
        NilElList(Structure::from(t.0), ElList::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: NilElList) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> NilElList {
        NilElList(Structure::from(t.1), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilElList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilElList> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Structure) -> impl '_ + Iterator<Item = NilElList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Structure, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = NilElList> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = NilElList> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == structure_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_el_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElList(pub El, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConsElListTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<ConsElList>>,
    element_index_el_list: BTreeMap<ElList, Vec<ConsElList>>,
}
impl ConsElListTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ConsElList) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ConsElList) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ConsElList) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: ConsElList) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.0), ElList::from(t.1), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: ConsElList) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.1), ElList::from(t.0), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: ConsElList) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> ConsElList {
        ConsElList(El::from(t.1), ElList::from(t.2), ElList::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ConsElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ConsElList> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: El,
        arg1: ElList,
        arg2: ElList,
    ) -> impl '_ + Iterator<Item = ConsElList> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ConsElList> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = ConsElList> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        el_list_equalities: &mut Unification<ElList>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == el_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
                && tuple.2 == el_list_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ConsElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_el_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncApp(pub Func, pub ElList, pub El);
#[derive(Clone, Hash, Debug)]
struct FuncAppTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_2_0: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<FuncApp>>,
    element_index_el_list: BTreeMap<ElList, Vec<FuncApp>>,
    element_index_func: BTreeMap<Func, Vec<FuncApp>>,
}
impl FuncAppTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_2_0: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_func: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncApp) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_2_0.insert(Self::permute_1_2_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_func.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncApp) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncApp) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: FuncApp) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> FuncApp {
        FuncApp(Func::from(t.0), ElList::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_2_0(t: FuncApp) -> (u32, u32, u32) {
        (t.1.into(), t.2.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_2_0(t: (u32, u32, u32)) -> FuncApp {
        FuncApp(Func::from(t.2), ElList::from(t.0), El::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncApp> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncApp> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FuncApp> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Func, arg1: ElList) -> impl '_ + Iterator<Item = FuncApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Func,
        arg1: ElList,
        arg2: El,
    ) -> impl '_ + Iterator<Item = FuncApp> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg0, arg1, arg2);
        let max = (arg0, arg1, arg2);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = FuncApp> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn iter_all_1_2(&self, arg1: ElList, arg2: El) -> impl '_ + Iterator<Item = FuncApp> {
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg1, arg2, u32::MIN);
        let max = (arg1, arg2, u32::MAX);
        self.index_all_1_2_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_2_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = FuncApp> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = FuncApp> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_func(&mut self, tm: Func) -> impl '_ + Iterator<Item = FuncApp> {
        let ts = match self.element_index_func.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_2_0.remove(&Self::permute_1_2_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        el_list_equalities: &mut Unification<ElList>,
        func_equalities: &mut Unification<Func>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == func_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
                && tuple.2 == el_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Var(pub Structure, pub VirtIdent, pub El);
#[derive(Clone, Hash, Debug)]
struct VarTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<Var>>,
    element_index_structure: BTreeMap<Structure, Vec<Var>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<Var>>,
}
impl VarTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Var) -> bool {
        if self.index_all_2_0_1.insert(Self::permute_2_0_1(t)) {
            self.index_all_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Var) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Var) -> bool {
        self.index_all_2_0_1.contains(&Self::permute_2_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: Var) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> Var {
        Var(Structure::from(t.0), VirtIdent::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: Var) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> Var {
        Var(Structure::from(t.1), VirtIdent::from(t.2), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Var> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Var> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Structure, arg1: VirtIdent) -> impl '_ + Iterator<Item = Var> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1_2(
        &self,
        arg0: Structure,
        arg1: VirtIdent,
        arg2: El,
    ) -> impl '_ + Iterator<Item = Var> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, arg1);
        let max = (arg2, arg0, arg1);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = Var> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = Var> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> impl '_ + Iterator<Item = Var> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> impl '_ + Iterator<Item = Var> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t)) {
                self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        structure_equalities: &mut Unification<Structure>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == structure_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
                && tuple.2 == el_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for VarTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElStructure(pub El, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<ElStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElStructure>>,
}
impl ElStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElStructure {
        ElStructure(El::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElStructure {
        ElStructure(El::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: El, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = ElStructure> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = ElStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == el_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElsStructure(pub ElList, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElsStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<ElsStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElsStructure>>,
}
impl ElsStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ElsStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ElsStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ElsStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ElsStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ElsStructure {
        ElsStructure(ElList::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ElsStructure) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ElsStructure {
        ElsStructure(ElList::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ElsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ElsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ElList,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(
        &mut self,
        tm: ElList,
    ) -> impl '_ + Iterator<Item = ElsStructure> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = ElsStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == el_list_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ElsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("els_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Dom(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct DomTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_morphism: BTreeMap<Morphism, Vec<Dom>>,
    element_index_structure: BTreeMap<Structure, Vec<Dom>>,
}
impl DomTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Dom) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Dom) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Dom) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Dom) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Dom {
        Dom(Morphism::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Dom) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Dom {
        Dom(Morphism::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Dom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Dom> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Dom> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = Dom> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> impl '_ + Iterator<Item = Dom> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        morphism_equalities: &mut Unification<Morphism>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for DomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("dom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Cod(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct CodTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_morphism: BTreeMap<Morphism, Vec<Cod>>,
    element_index_structure: BTreeMap<Structure, Vec<Cod>>,
}
impl CodTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Cod) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Cod) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Cod) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Cod) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Cod {
        Cod(Morphism::from(t.0), Structure::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: Cod) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> Cod {
        Cod(Morphism::from(t.1), Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Cod> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Cod> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Cod> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = Cod> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(&mut self, tm: Structure) -> impl '_ + Iterator<Item = Cod> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        morphism_equalities: &mut Unification<Morphism>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for CodTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cod"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEl(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct MapElTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,
    index_all_2_0_1: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<MapEl>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEl>>,
}
impl MapElTable {
    #[allow(unused)]
    const WEIGHT: usize = 15;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_all_2_0_1: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MapEl) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));
            self.index_all_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: MapEl) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MapEl) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MapEl) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.0), El::from(t.1), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: MapEl) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.1), El::from(t.0), El::from(t.2))
    }
    #[allow(unused)]
    fn permute_2_0_1(t: MapEl) -> (u32, u32, u32) {
        (t.2.into(), t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_2_0_1(t: (u32, u32, u32)) -> MapEl {
        MapEl(Morphism::from(t.1), El::from(t.2), El::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MapEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MapEl> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_2(&self, arg0: Morphism, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg0 = arg0.0;
        let arg2 = arg2.0;
        let min = (arg2, arg0, u32::MIN);
        let max = (arg2, arg0, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
        let arg2 = arg2.0;
        let min = (arg2, u32::MIN, u32::MIN);
        let max = (arg2, u32::MAX, u32::MAX);
        self.index_all_2_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_2_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = MapEl> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = MapEl> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                self.index_all_2_0_1.remove(&Self::permute_2_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == el_equalities.root(tuple.1)
                && tuple.2 == el_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for MapElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEls(pub Morphism, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct MapElsTable {
    index_all_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_dirty_0_1_2: BTreeSet<(u32, u32, u32)>,
    index_all_1_0_2: BTreeSet<(u32, u32, u32)>,

    index_dirty_0_1_2_prev: Vec<BTreeSet<(u32, u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<MapEls>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEls>>,
}
impl MapElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 12;
    fn new() -> Self {
        Self {
            index_all_0_1_2: BTreeSet::new(),
            index_dirty_0_1_2: BTreeSet::new(),
            index_all_1_0_2: BTreeSet::new(),
            index_dirty_0_1_2_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: MapEls) -> bool {
        if self.index_all_0_1_2.insert(Self::permute_0_1_2(t)) {
            self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t));
            self.index_all_1_0_2.insert(Self::permute_1_0_2(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.2, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: MapEls) -> bool {
        if self.index_dirty_0_1_2.insert(Self::permute_0_1_2(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: MapEls) -> bool {
        self.index_all_0_1_2.contains(&Self::permute_0_1_2(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1_2.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1_2 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1_2, &mut self.index_dirty_0_1_2);
        self.index_dirty_0_1_2_prev.push(tmp_dirty_0_1_2);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1_2.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1_2(t: MapEls) -> (u32, u32, u32) {
        (t.0.into(), t.1.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1_2(t: (u32, u32, u32)) -> MapEls {
        MapEls(Morphism::from(t.0), ElList::from(t.1), ElList::from(t.2))
    }
    #[allow(unused)]
    fn permute_1_0_2(t: MapEls) -> (u32, u32, u32) {
        (t.1.into(), t.0.into(), t.2.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0_2(t: (u32, u32, u32)) -> MapEls {
        MapEls(Morphism::from(t.1), ElList::from(t.0), ElList::from(t.2))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = MapEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = MapEls> {
        let min = (u32::MIN, u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX, u32::MAX);
        self.index_dirty_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = MapEls> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN, u32::MIN);
        let max = (arg0, u32::MAX, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Morphism, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1, u32::MIN);
        let max = (arg0, arg1, u32::MAX);
        self.index_all_0_1_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1_2)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN, u32::MIN);
        let max = (arg1, u32::MAX, u32::MAX);
        self.index_all_1_0_2
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0_2)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = MapEls> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(&mut self, tm: Morphism) -> impl '_ + Iterator<Item = MapEls> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1_2.remove(&Self::permute_0_1_2(*t)) {
                self.index_dirty_0_1_2.remove(&Self::permute_0_1_2(*t));
                self.index_all_1_0_2.remove(&Self::permute_1_0_2(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_2_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_2_prev, &mut self.index_dirty_0_1_2_prev);

        for tuple in tmp_dirty_0_1_2_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1_2(tuple);
            if true
                && tuple.0 == morphism_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
                && tuple.2 == el_list_equalities.root(tuple.2)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for MapElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InitialStructure(pub Structure);
#[derive(Clone, Hash, Debug)]
struct InitialStructureTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_structure: BTreeMap<Structure, Vec<InitialStructure>>,
}
impl InitialStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: InitialStructure) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: InitialStructure) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: InitialStructure) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: InitialStructure) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> InitialStructure {
        InitialStructure(Structure::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = InitialStructure> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = InitialStructure> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Structure) -> impl '_ + Iterator<Item = InitialStructure> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = InitialStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, structure_equalities: &mut Unification<Structure>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == structure_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for InitialStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("initial_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InitialityMorphism(pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct InitialityMorphismTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_morphism: BTreeMap<Morphism, Vec<InitialityMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<InitialityMorphism>>,
}
impl InitialityMorphismTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_morphism: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: InitialityMorphism) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.0, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: InitialityMorphism) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: InitialityMorphism) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: InitialityMorphism) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> InitialityMorphism {
        InitialityMorphism(Structure::from(t.0), Morphism::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Structure) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: Structure,
        arg1: Morphism,
    ) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(
        &mut self,
        tm: Morphism,
    ) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = InitialityMorphism> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        morphism_equalities: &mut Unification<Morphism>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == structure_equalities.root(tuple.0)
                && tuple.1 == morphism_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for InitialityMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("initiality_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilChain(pub Chain);
#[derive(Clone, Hash, Debug)]
struct NilChainTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_chain: BTreeMap<Chain, Vec<NilChain>>,
}
impl NilChainTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: NilChain) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_chain.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: NilChain) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: NilChain) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: NilChain) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> NilChain {
        NilChain(Chain::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = NilChain> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = NilChain> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Chain) -> impl '_ + Iterator<Item = NilChain> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(&mut self, tm: Chain) -> impl '_ + Iterator<Item = NilChain> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, chain_equalities: &mut Unification<Chain>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == chain_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for NilChainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ChainTail(pub Chain, pub Chain);
#[derive(Clone, Hash, Debug)]
struct ChainTailTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<ChainTail>>,
}
impl ChainTailTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ChainTail) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_chain.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.0, vec![t]);
                }
            };

            match self.element_index_chain.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ChainTail) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ChainTail) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ChainTail) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ChainTail {
        ChainTail(Chain::from(t.0), Chain::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: ChainTail) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> ChainTail {
        ChainTail(Chain::from(t.1), Chain::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ChainTail> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ChainTail> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Chain) -> impl '_ + Iterator<Item = ChainTail> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Chain, arg1: Chain) -> impl '_ + Iterator<Item = ChainTail> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Chain) -> impl '_ + Iterator<Item = ChainTail> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(&mut self, tm: Chain) -> impl '_ + Iterator<Item = ChainTail> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, chain_equalities: &mut Unification<Chain>) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == chain_equalities.root(tuple.0)
                && tuple.1 == chain_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ChainTailTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("chain_tail"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ChainHeadStructure(pub Chain, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ChainHeadStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<ChainHeadStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ChainHeadStructure>>,
}
impl ChainHeadStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ChainHeadStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_chain.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ChainHeadStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ChainHeadStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ChainHeadStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ChainHeadStructure {
        ChainHeadStructure(Chain::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Chain) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: Chain,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(
        &mut self,
        tm: Chain,
    ) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = ChainHeadStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == chain_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ChainHeadStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("chain_head_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ChainHeadTransition(pub Chain, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct ChainHeadTransitionTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<ChainHeadTransition>>,
    element_index_morphism: BTreeMap<Morphism, Vec<ChainHeadTransition>>,
}
impl ChainHeadTransitionTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_morphism: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ChainHeadTransition) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_chain.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.0, vec![t]);
                }
            };

            match self.element_index_morphism.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_morphism.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ChainHeadTransition) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ChainHeadTransition) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ChainHeadTransition) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ChainHeadTransition {
        ChainHeadTransition(Chain::from(t.0), Morphism::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ChainHeadTransition> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ChainHeadTransition> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Chain) -> impl '_ + Iterator<Item = ChainHeadTransition> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(
        &mut self,
        tm: Chain,
    ) -> impl '_ + Iterator<Item = ChainHeadTransition> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_morphism(
        &mut self,
        tm: Morphism,
    ) -> impl '_ + Iterator<Item = ChainHeadTransition> {
        let ts = match self.element_index_morphism.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        morphism_equalities: &mut Unification<Morphism>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == chain_equalities.root(tuple.0)
                && tuple.1 == morphism_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ChainHeadTransitionTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("chain_head_transition"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct TypeSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<TypeSymbol>>,
}
impl TypeSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TypeSymbol) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: TypeSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> TypeSymbol {
        TypeSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = TypeSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, symbol_kind_equalities: &mut Unification<SymbolKind>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == symbol_kind_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TypeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct PredSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<PredSymbol>>,
}
impl PredSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: PredSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: PredSymbol) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: PredSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: PredSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> PredSymbol {
        PredSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = PredSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = PredSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = PredSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, symbol_kind_equalities: &mut Unification<SymbolKind>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == symbol_kind_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for PredSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct FuncSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<FuncSymbol>>,
}
impl FuncSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: FuncSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: FuncSymbol) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: FuncSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: FuncSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> FuncSymbol {
        FuncSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = FuncSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = FuncSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = FuncSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, symbol_kind_equalities: &mut Unification<SymbolKind>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == symbol_kind_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for FuncSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct RuleSymbolTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<RuleSymbol>>,
}
impl RuleSymbolTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_symbol_kind: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleSymbol) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_symbol_kind.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleSymbol) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleSymbol) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: RuleSymbol) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> RuleSymbol {
        RuleSymbol(SymbolKind::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleSymbol> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_symbol_kind(
        &mut self,
        tm: SymbolKind,
    ) -> impl '_ + Iterator<Item = RuleSymbol> {
        let ts = match self.element_index_symbol_kind.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, symbol_kind_equalities: &mut Unification<SymbolKind>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == symbol_kind_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Zero(pub Nat);
#[derive(Clone, Hash, Debug)]
struct ZeroTable {
    index_all_0: BTreeSet<(u32,)>,
    index_dirty_0: BTreeSet<(u32,)>,

    index_dirty_0_prev: Vec<BTreeSet<(u32,)>>,

    element_index_nat: BTreeMap<Nat, Vec<Zero>>,
}
impl ZeroTable {
    #[allow(unused)]
    const WEIGHT: usize = 3;
    fn new() -> Self {
        Self {
            index_all_0: BTreeSet::new(),
            index_dirty_0: BTreeSet::new(),
            index_dirty_0_prev: Vec::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Zero) -> bool {
        if self.index_all_0.insert(Self::permute_0(t)) {
            self.index_dirty_0.insert(Self::permute_0(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Zero) -> bool {
        if self.index_dirty_0.insert(Self::permute_0(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Zero) -> bool {
        self.index_all_0.contains(&Self::permute_0(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0, &mut self.index_dirty_0);
        self.index_dirty_0_prev.push(tmp_dirty_0);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0.is_empty()
    }
    #[allow(unused)]
    fn permute_0(t: Zero) -> (u32,) {
        (t.0.into(),)
    }
    #[allow(unused)]
    fn permute_inverse_0(t: (u32,)) -> Zero {
        Zero(Nat::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Zero> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Zero> {
        let min = (u32::MIN,);
        let max = (u32::MAX,);
        self.index_dirty_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Zero> {
        let arg0 = arg0.0;
        let min = (arg0,);
        let max = (arg0,);
        self.index_all_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> impl '_ + Iterator<Item = Zero> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0.remove(&Self::permute_0(*t)) {
                self.index_dirty_0.remove(&Self::permute_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, nat_equalities: &mut Unification<Nat>) {
        let mut tmp_dirty_0_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_prev, &mut self.index_dirty_0_prev);

        for tuple in tmp_dirty_0_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0(tuple);
            if true && tuple.0 == nat_equalities.root(tuple.0) {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ZeroTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("zero"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Succ(pub Nat, pub Nat);
#[derive(Clone, Hash, Debug)]
struct SuccTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_nat: BTreeMap<Nat, Vec<Succ>>,
}
impl SuccTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_nat: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: Succ) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: Succ) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: Succ) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: Succ) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> Succ {
        Succ(Nat::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = Succ> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = Succ> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Succ> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(&self, arg0: Nat, arg1: Nat) -> impl '_ + Iterator<Item = Succ> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> impl '_ + Iterator<Item = Succ> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(&mut self, nat_equalities: &mut Unification<Nat>) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == nat_equalities.root(tuple.0)
                && tuple.1 == nat_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SuccTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("succ"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeListLen(pub TypeList, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TypeListLenTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_nat: BTreeMap<Nat, Vec<TypeListLen>>,
    element_index_type_list: BTreeMap<TypeList, Vec<TypeListLen>>,
}
impl TypeListLenTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_nat: BTreeMap::new(),
            element_index_type_list: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TypeListLen) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_type_list.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TypeListLen) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TypeListLen) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TypeListLen) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TypeListLen {
        TypeListLen(TypeList::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TypeListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TypeListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = TypeListLen> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> impl '_ + Iterator<Item = TypeListLen> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_type_list(
        &mut self,
        tm: TypeList,
    ) -> impl '_ + Iterator<Item = TypeListLen> {
        let ts = match self.element_index_type_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        nat_equalities: &mut Unification<Nat>,
        type_list_equalities: &mut Unification<TypeList>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == type_list_equalities.root(tuple.0)
                && tuple.1 == nat_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TypeListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListLen(pub TermListNode, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TermListLenTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_nat: BTreeMap<Nat, Vec<TermListLen>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListLen>>,
}
impl TermListLenTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_nat: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermListLen) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_nat.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermListLen) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermListLen) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermListLen) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermListLen {
        TermListLen(TermListNode::from(t.0), Nat::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermListLen> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListLen> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_nat(&mut self, tm: Nat) -> impl '_ + Iterator<Item = TermListLen> {
        let ts = match self.element_index_nat.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = TermListLen> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        nat_equalities: &mut Unification<Nat>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == nat_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleChain(pub RuleDeclNode, pub Chain);
#[derive(Clone, Hash, Debug)]
struct RuleChainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<RuleChain>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleChain>>,
}
impl RuleChainTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: RuleChain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_chain.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: RuleChain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: RuleChain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: RuleChain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> RuleChain {
        RuleChain(RuleDeclNode::from(t.0), Chain::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = RuleChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = RuleChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleChain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(&mut self, tm: Chain) -> impl '_ + Iterator<Item = RuleChain> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = RuleChain> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_decl_node_equalities.root(tuple.0)
                && tuple.1 == chain_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for RuleChainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListChain(pub StmtListNode, pub Chain);
#[derive(Clone, Hash, Debug)]
struct StmtListChainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,
    index_all_1_0: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<StmtListChain>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<StmtListChain>>,
}
impl StmtListChainTable {
    #[allow(unused)]
    const WEIGHT: usize = 8;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_all_1_0: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtListChain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));
            self.index_all_1_0.insert(Self::permute_1_0(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_chain.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: StmtListChain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtListChain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtListChain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtListChain {
        StmtListChain(StmtListNode::from(t.0), Chain::from(t.1))
    }
    #[allow(unused)]
    fn permute_1_0(t: StmtListChain) -> (u32, u32) {
        (t.1.into(), t.0.into())
    }
    #[allow(unused)]
    fn permute_inverse_1_0(t: (u32, u32)) -> StmtListChain {
        StmtListChain(StmtListNode::from(t.1), Chain::from(t.0))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtListChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtListChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = StmtListChain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_1(&self, arg1: Chain) -> impl '_ + Iterator<Item = StmtListChain> {
        let arg1 = arg1.0;
        let min = (arg1, u32::MIN);
        let max = (arg1, u32::MAX);
        self.index_all_1_0
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_1_0)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(&mut self, tm: Chain) -> impl '_ + Iterator<Item = StmtListChain> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = StmtListChain> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                self.index_all_1_0.remove(&Self::permute_1_0(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == chain_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for StmtListChainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_list_chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtStructure(pub StmtNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct StmtStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<StmtStructure>>,
}
impl StmtStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_stmt_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: StmtStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: StmtStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: StmtStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: StmtStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> StmtStructure {
        StmtStructure(StmtNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = StmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = StmtStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = StmtStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_node(
        &mut self,
        tm: StmtNode,
    ) -> impl '_ + Iterator<Item = StmtStructure> {
        let ts = match self.element_index_stmt_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = StmtStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        stmt_node_equalities: &mut Unification<StmtNode>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for StmtStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomStructure(pub IfAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct IfAtomStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<IfAtomStructure>>,
}
impl IfAtomStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_if_atom_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: IfAtomStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_if_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: IfAtomStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: IfAtomStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: IfAtomStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> IfAtomStructure {
        IfAtomStructure(IfAtomNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: IfAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_if_atom_node(
        &mut self,
        tm: IfAtomNode,
    ) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let ts = match self.element_index_if_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = IfAtomStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        if_atom_node_equalities: &mut Unification<IfAtomNode>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == if_atom_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for IfAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomStructure(pub ThenAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ThenAtomStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_structure: BTreeMap<Structure, Vec<ThenAtomStructure>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomStructure>>,
}
impl ThenAtomStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_structure: BTreeMap::new(),
            element_index_then_atom_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: ThenAtomStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_then_atom_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: ThenAtomStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: ThenAtomStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: ThenAtomStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> ThenAtomStructure {
        ThenAtomStructure(ThenAtomNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: ThenAtomNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_then_atom_node(
        &mut self,
        tm: ThenAtomNode,
    ) -> impl '_ + Iterator<Item = ThenAtomStructure> {
        let ts = match self.element_index_then_atom_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        structure_equalities: &mut Unification<Structure>,
        then_atom_node_equalities: &mut Unification<ThenAtomNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == then_atom_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for ThenAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermStructure(pub TermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_structure: BTreeMap<Structure, Vec<TermStructure>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermStructure>>,
}
impl TermStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermStructure {
        TermStructure(TermNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = TermStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = TermStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = TermStructure> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        structure_equalities: &mut Unification<Structure>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsStructure(pub TermListNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermsStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_structure: BTreeMap<Structure, Vec<TermsStructure>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsStructure>>,
}
impl TermsStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_structure: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: TermsStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: TermsStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: TermsStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: TermsStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> TermsStructure {
        TermsStructure(TermListNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = TermsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = TermsStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: TermListNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = TermsStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = TermsStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = TermsStructure> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        structure_equalities: &mut Unification<Structure>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for TermsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermStructure(pub OptTermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct OptTermStructureTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<OptTermStructure>>,
}
impl OptTermStructureTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_opt_term_node: BTreeMap::new(),
            element_index_structure: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: OptTermStructure) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_opt_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_structure.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: OptTermStructure) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: OptTermStructure) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: OptTermStructure) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> OptTermStructure {
        OptTermStructure(OptTermNode::from(t.0), Structure::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = OptTermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = OptTermStructure> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermStructure> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: OptTermNode,
        arg1: Structure,
    ) -> impl '_ + Iterator<Item = OptTermStructure> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_opt_term_node(
        &mut self,
        tm: OptTermNode,
    ) -> impl '_ + Iterator<Item = OptTermStructure> {
        let ts = match self.element_index_opt_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_structure(
        &mut self,
        tm: Structure,
    ) -> impl '_ + Iterator<Item = OptTermStructure> {
        let ts = match self.element_index_structure.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        opt_term_node_equalities: &mut Unification<OptTermNode>,
        structure_equalities: &mut Unification<Structure>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == opt_term_node_equalities.root(tuple.0)
                && tuple.1 == structure_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for OptTermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEl(pub TermNode, pub El);
#[derive(Clone, Hash, Debug)]
struct SemanticElTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el: BTreeMap<El, Vec<SemanticEl>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SemanticEl>>,
}
impl SemanticElTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el: BTreeMap::new(),
            element_index_term_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticEl) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticEl) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticEl) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticEl) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticEl {
        SemanticEl(TermNode::from(t.0), El::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticEl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticEl> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = SemanticEl> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el(&mut self, tm: El) -> impl '_ + Iterator<Item = SemanticEl> {
        let ts = match self.element_index_el.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = SemanticEl> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_equalities: &mut Unification<El>,
        term_node_equalities: &mut Unification<TermNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == el_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEls(pub TermListNode, pub ElList);
#[derive(Clone, Hash, Debug)]
struct SemanticElsTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_el_list: BTreeMap<ElList, Vec<SemanticEls>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<SemanticEls>>,
}
impl SemanticElsTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_el_list: BTreeMap::new(),
            element_index_term_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: SemanticEls) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_el_list.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: SemanticEls) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: SemanticEls) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: SemanticEls) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> SemanticEls {
        SemanticEls(TermListNode::from(t.0), ElList::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = SemanticEls> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = SemanticEls> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = SemanticEls> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_el_list(&mut self, tm: ElList) -> impl '_ + Iterator<Item = SemanticEls> {
        let ts = match self.element_index_el_list.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_term_list_node(
        &mut self,
        tm: TermListNode,
    ) -> impl '_ + Iterator<Item = SemanticEls> {
        let ts = match self.element_index_term_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        el_list_equalities: &mut Unification<ElList>,
        term_list_node_equalities: &mut Unification<TermListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_list_node_equalities.root(tuple.0)
                && tuple.1 == el_list_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for SemanticElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardVirtIdent(pub TermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct WildcardVirtIdentTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_term_node: BTreeMap<TermNode, Vec<WildcardVirtIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<WildcardVirtIdent>>,
}
impl WildcardVirtIdentTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_term_node: BTreeMap::new(),
            element_index_virt_ident: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: WildcardVirtIdent) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_term_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_virt_ident.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: WildcardVirtIdent) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: WildcardVirtIdent) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: WildcardVirtIdent) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> WildcardVirtIdent {
        WildcardVirtIdent(TermNode::from(t.0), VirtIdent::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = WildcardVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = WildcardVirtIdent> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardVirtIdent> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_term_node(
        &mut self,
        tm: TermNode,
    ) -> impl '_ + Iterator<Item = WildcardVirtIdent> {
        let ts = match self.element_index_term_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_virt_ident(
        &mut self,
        tm: VirtIdent,
    ) -> impl '_ + Iterator<Item = WildcardVirtIdent> {
        let ts = match self.element_index_virt_ident.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        term_node_equalities: &mut Unification<TermNode>,
        virt_ident_equalities: &mut Unification<VirtIdent>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == term_node_equalities.root(tuple.0)
                && tuple.1 == virt_ident_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for WildcardVirtIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_virt_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct GroupedRuleChain(pub RuleDeclNode, pub Chain);
#[derive(Clone, Hash, Debug)]
struct GroupedRuleChainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<GroupedRuleChain>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<GroupedRuleChain>>,
}
impl GroupedRuleChainTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_rule_decl_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: GroupedRuleChain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_rule_decl_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_chain.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: GroupedRuleChain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: GroupedRuleChain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: GroupedRuleChain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> GroupedRuleChain {
        GroupedRuleChain(RuleDeclNode::from(t.0), Chain::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = GroupedRuleChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = GroupedRuleChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = GroupedRuleChain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(
        &mut self,
        tm: Chain,
    ) -> impl '_ + Iterator<Item = GroupedRuleChain> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_rule_decl_node(
        &mut self,
        tm: RuleDeclNode,
    ) -> impl '_ + Iterator<Item = GroupedRuleChain> {
        let ts = match self.element_index_rule_decl_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        rule_decl_node_equalities: &mut Unification<RuleDeclNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == rule_decl_node_equalities.root(tuple.0)
                && tuple.1 == chain_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for GroupedRuleChainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("grouped_rule_chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct GroupedStmtListChain(pub StmtListNode, pub Chain);
#[derive(Clone, Hash, Debug)]
struct GroupedStmtListChainTable {
    index_all_0_1: BTreeSet<(u32, u32)>,
    index_dirty_0_1: BTreeSet<(u32, u32)>,

    index_dirty_0_1_prev: Vec<BTreeSet<(u32, u32)>>,

    element_index_chain: BTreeMap<Chain, Vec<GroupedStmtListChain>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<GroupedStmtListChain>>,
}
impl GroupedStmtListChainTable {
    #[allow(unused)]
    const WEIGHT: usize = 6;
    fn new() -> Self {
        Self {
            index_all_0_1: BTreeSet::new(),
            index_dirty_0_1: BTreeSet::new(),
            index_dirty_0_1_prev: Vec::new(),
            element_index_chain: BTreeMap::new(),
            element_index_stmt_list_node: BTreeMap::new(),
        }
    }
    #[allow(dead_code)]
    fn insert(&mut self, t: GroupedStmtListChain) -> bool {
        if self.index_all_0_1.insert(Self::permute_0_1(t)) {
            self.index_dirty_0_1.insert(Self::permute_0_1(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_stmt_list_node.insert(t.0, vec![t]);
                }
            };

            match self.element_index_chain.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => {
                    self.element_index_chain.insert(t.1, vec![t]);
                }
            };

            true
        } else {
            false
        }
    }
    fn insert_dirt(&mut self, t: GroupedStmtListChain) -> bool {
        if self.index_dirty_0_1.insert(Self::permute_0_1(t)) {
            true
        } else {
            false
        }
    }
    #[allow(dead_code)]
    fn contains(&self, t: GroupedStmtListChain) -> bool {
        self.index_all_0_1.contains(&Self::permute_0_1(t))
    }
    fn drop_dirt(&mut self) {
        self.index_dirty_0_1.clear();
    }
    fn retire_dirt(&mut self) {
        let mut tmp_dirty_0_1 = BTreeSet::new();
        std::mem::swap(&mut tmp_dirty_0_1, &mut self.index_dirty_0_1);
        self.index_dirty_0_1_prev.push(tmp_dirty_0_1);
    }
    fn is_dirty(&self) -> bool {
        !self.index_dirty_0_1.is_empty()
    }
    #[allow(unused)]
    fn permute_0_1(t: GroupedStmtListChain) -> (u32, u32) {
        (t.0.into(), t.1.into())
    }
    #[allow(unused)]
    fn permute_inverse_0_1(t: (u32, u32)) -> GroupedStmtListChain {
        GroupedStmtListChain(StmtListNode::from(t.0), Chain::from(t.1))
    }
    #[allow(dead_code)]
    fn iter_all(&self) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_dirty(&self) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let min = (u32::MIN, u32::MIN);
        let max = (u32::MAX, u32::MAX);
        self.index_dirty_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let arg0 = arg0.0;
        let min = (arg0, u32::MIN);
        let max = (arg0, u32::MAX);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn iter_all_0_1(
        &self,
        arg0: StmtListNode,
        arg1: Chain,
    ) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let arg0 = arg0.0;
        let arg1 = arg1.0;
        let min = (arg0, arg1);
        let max = (arg0, arg1);
        self.index_all_0_1
            .range((Bound::Included(&min), Bound::Included(&max)))
            .copied()
            .map(Self::permute_inverse_0_1)
    }
    #[allow(dead_code)]
    fn drain_with_element_chain(
        &mut self,
        tm: Chain,
    ) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let ts = match self.element_index_chain.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    #[allow(dead_code)]
    fn drain_with_element_stmt_list_node(
        &mut self,
        tm: StmtListNode,
    ) -> impl '_ + Iterator<Item = GroupedStmtListChain> {
        let ts = match self.element_index_stmt_list_node.remove(&tm) {
            None => Vec::new(),
            Some(tuples) => tuples,
        };

        ts.into_iter().filter(|t| {
            if self.index_all_0_1.remove(&Self::permute_0_1(*t)) {
                self.index_dirty_0_1.remove(&Self::permute_0_1(*t));
                true
            } else {
                false
            }
        })
    }
    fn recall_previous_dirt(
        &mut self,
        chain_equalities: &mut Unification<Chain>,
        stmt_list_node_equalities: &mut Unification<StmtListNode>,
    ) {
        let mut tmp_dirty_0_1_prev = Vec::new();
        std::mem::swap(&mut tmp_dirty_0_1_prev, &mut self.index_dirty_0_1_prev);

        for tuple in tmp_dirty_0_1_prev.into_iter().flatten() {
            #[allow(unused_mut)]
            let mut tuple = Self::permute_inverse_0_1(tuple);
            if true
                && tuple.0 == stmt_list_node_equalities.root(tuple.0)
                && tuple.1 == chain_equalities.root(tuple.1)
            {
                self.insert_dirt(tuple);
            }
        }
    }
}
impl fmt::Display for GroupedStmtListChainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("grouped_stmt_list_chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)
    }
}

#[derive(Debug, Clone)]
struct ModelDelta {
    new_absurd: Vec<Absurd>,
    new_type_decl: Vec<TypeDecl>,
    new_arg_decl_node_name: Vec<ArgDeclNodeName>,
    new_arg_decl_node_type: Vec<ArgDeclNodeType>,
    new_nil_arg_decl_list_node: Vec<NilArgDeclListNode>,
    new_cons_arg_decl_list_node: Vec<ConsArgDeclListNode>,
    new_pred_decl: Vec<PredDecl>,
    new_func_decl: Vec<FuncDecl>,
    new_nil_term_list_node: Vec<NilTermListNode>,
    new_cons_term_list_node: Vec<ConsTermListNode>,
    new_none_term_node: Vec<NoneTermNode>,
    new_some_term_node: Vec<SomeTermNode>,
    new_var_term_node: Vec<VarTermNode>,
    new_wildcard_term_node: Vec<WildcardTermNode>,
    new_app_term_node: Vec<AppTermNode>,
    new_equal_if_atom_node: Vec<EqualIfAtomNode>,
    new_defined_if_atom_node: Vec<DefinedIfAtomNode>,
    new_pred_if_atom_node: Vec<PredIfAtomNode>,
    new_var_if_atom_node: Vec<VarIfAtomNode>,
    new_equal_then_atom_node: Vec<EqualThenAtomNode>,
    new_defined_then_atom_node: Vec<DefinedThenAtomNode>,
    new_pred_then_atom_node: Vec<PredThenAtomNode>,
    new_if_stmt_node: Vec<IfStmtNode>,
    new_then_stmt_node: Vec<ThenStmtNode>,
    new_nil_stmt_list_node: Vec<NilStmtListNode>,
    new_cons_stmt_list_node: Vec<ConsStmtListNode>,
    new_rule_decl: Vec<RuleDecl>,
    new_decl_node_type: Vec<DeclNodeType>,
    new_decl_node_pred: Vec<DeclNodePred>,
    new_decl_node_func: Vec<DeclNodeFunc>,
    new_decl_node_rule: Vec<DeclNodeRule>,
    new_nil_decl_list_node: Vec<NilDeclListNode>,
    new_cons_decl_list_node: Vec<ConsDeclListNode>,
    new_decls_module_node: Vec<DeclsModuleNode>,
    new_rule_child: Vec<RuleChild>,
    new_pred_app: Vec<PredApp>,
    new_el_type: Vec<ElType>,
    new_el_types: Vec<ElTypes>,
    new_constrained_el: Vec<ConstrainedEl>,
    new_constrained_els: Vec<ConstrainedEls>,
    new_in_ker: Vec<InKer>,
    new_el_in_img: Vec<ElInImg>,
    new_pred_tuple_in_img: Vec<PredTupleInImg>,
    new_func_app_in_img: Vec<FuncAppInImg>,
    new_defined_symbol: Vec<DefinedSymbol>,
    new_should_be_symbol: Vec<ShouldBeSymbol>,
    new_pred_arg_num_should_match: Vec<PredArgNumShouldMatch>,
    new_func_arg_num_should_match: Vec<FuncArgNumShouldMatch>,
    new_var_before_term: Vec<VarBeforeTerm>,
    new_var_before_terms: Vec<VarBeforeTerms>,
    new_var_before_opt_term: Vec<VarBeforeOptTerm>,
    new_var_before_if_atom: Vec<VarBeforeIfAtom>,
    new_var_before_then_atom: Vec<VarBeforeThenAtom>,
    new_var_before_stmt: Vec<VarBeforeStmt>,
    new_var_before_stmts: Vec<VarBeforeStmts>,
    new_var_in_term: Vec<VarInTerm>,
    new_var_in_terms: Vec<VarInTerms>,
    new_var_in_opt_term: Vec<VarInOptTerm>,
    new_var_in_if_atom: Vec<VarInIfAtom>,
    new_var_in_then_atom: Vec<VarInThenAtom>,
    new_var_in_stmt: Vec<VarInStmt>,
    new_term_should_be_epic_ok: Vec<TermShouldBeEpicOk>,
    new_terms_should_be_epic_ok: Vec<TermsShouldBeEpicOk>,
    new_should_be_surjective: Vec<ShouldBeSurjective>,
    new_term_surjective_exempted: Vec<TermSurjectiveExempted>,
    new_terms_surjective_exempted: Vec<TermsSurjectiveExempted>,
    new_el_surjective_exempted: Vec<ElSurjectiveExempted>,
    new_el_should_be_surjective_ok: Vec<ElShouldBeSurjectiveOk>,
    new_el_is_surjective_ok: Vec<ElIsSurjectiveOk>,
    new_var_term_in_rule: Vec<VarTermInRule>,
    new_if_after_then: Vec<IfAfterThen>,
    new_real_virt_ident: Vec<RealVirtIdent>,
    new_rule_name: Vec<RuleName>,
    new_type_decl_node_loc: Vec<TypeDeclNodeLoc>,
    new_arg_decl_node_loc: Vec<ArgDeclNodeLoc>,
    new_arg_decl_list_node_loc: Vec<ArgDeclListNodeLoc>,
    new_pred_decl_node_loc: Vec<PredDeclNodeLoc>,
    new_func_decl_node_loc: Vec<FuncDeclNodeLoc>,
    new_term_node_loc: Vec<TermNodeLoc>,
    new_term_list_node_loc: Vec<TermListNodeLoc>,
    new_opt_term_node_loc: Vec<OptTermNodeLoc>,
    new_if_atom_node_loc: Vec<IfAtomNodeLoc>,
    new_then_atom_node_loc: Vec<ThenAtomNodeLoc>,
    new_stmt_node_loc: Vec<StmtNodeLoc>,
    new_stmt_list_node_loc: Vec<StmtListNodeLoc>,
    new_rule_decl_node_loc: Vec<RuleDeclNodeLoc>,
    new_decl_node_loc: Vec<DeclNodeLoc>,
    new_decl_list_node_loc: Vec<DeclListNodeLoc>,
    new_module_node_loc: Vec<ModuleNodeLoc>,
    new_rule_child_term: Vec<RuleChildTerm>,
    new_rule_child_term_list: Vec<RuleChildTermList>,
    new_rule_child_opt_term: Vec<RuleChildOptTerm>,
    new_rule_child_if_atom: Vec<RuleChildIfAtom>,
    new_rule_child_then_atom: Vec<RuleChildThenAtom>,
    new_rule_child_stmt: Vec<RuleChildStmt>,
    new_rule_child_stmt_list: Vec<RuleChildStmtList>,
    new_nil_type_list: Vec<NilTypeList>,
    new_cons_type_list: Vec<ConsTypeList>,
    new_semantic_type: Vec<SemanticType>,
    new_semantic_arg_types: Vec<SemanticArgTypes>,
    new_semantic_pred: Vec<SemanticPred>,
    new_arity: Vec<Arity>,
    new_semantic_func: Vec<SemanticFunc>,
    new_domain: Vec<Domain>,
    new_codomain: Vec<Codomain>,
    new_nil_el_list: Vec<NilElList>,
    new_cons_el_list: Vec<ConsElList>,
    new_func_app: Vec<FuncApp>,
    new_var: Vec<Var>,
    new_el_structure: Vec<ElStructure>,
    new_els_structure: Vec<ElsStructure>,
    new_dom: Vec<Dom>,
    new_cod: Vec<Cod>,
    new_map_el: Vec<MapEl>,
    new_map_els: Vec<MapEls>,
    new_initial_structure: Vec<InitialStructure>,
    new_initiality_morphism: Vec<InitialityMorphism>,
    new_nil_chain: Vec<NilChain>,
    new_chain_tail: Vec<ChainTail>,
    new_chain_head_structure: Vec<ChainHeadStructure>,
    new_chain_head_transition: Vec<ChainHeadTransition>,
    new_type_symbol: Vec<TypeSymbol>,
    new_pred_symbol: Vec<PredSymbol>,
    new_func_symbol: Vec<FuncSymbol>,
    new_rule_symbol: Vec<RuleSymbol>,
    new_zero: Vec<Zero>,
    new_succ: Vec<Succ>,
    new_type_list_len: Vec<TypeListLen>,
    new_term_list_len: Vec<TermListLen>,
    new_rule_chain: Vec<RuleChain>,
    new_stmt_list_chain: Vec<StmtListChain>,
    new_stmt_structure: Vec<StmtStructure>,
    new_if_atom_structure: Vec<IfAtomStructure>,
    new_then_atom_structure: Vec<ThenAtomStructure>,
    new_term_structure: Vec<TermStructure>,
    new_terms_structure: Vec<TermsStructure>,
    new_opt_term_structure: Vec<OptTermStructure>,
    new_semantic_el: Vec<SemanticEl>,
    new_semantic_els: Vec<SemanticEls>,
    new_wildcard_virt_ident: Vec<WildcardVirtIdent>,
    new_grouped_rule_chain: Vec<GroupedRuleChain>,
    new_grouped_stmt_list_chain: Vec<GroupedStmtListChain>,
    new_ident_equalities: Vec<(Ident, Ident)>,
    new_virt_ident_equalities: Vec<(VirtIdent, VirtIdent)>,
    new_type_decl_node_equalities: Vec<(TypeDeclNode, TypeDeclNode)>,
    new_arg_decl_node_equalities: Vec<(ArgDeclNode, ArgDeclNode)>,
    new_arg_decl_list_node_equalities: Vec<(ArgDeclListNode, ArgDeclListNode)>,
    new_pred_decl_node_equalities: Vec<(PredDeclNode, PredDeclNode)>,
    new_func_decl_node_equalities: Vec<(FuncDeclNode, FuncDeclNode)>,
    new_term_node_equalities: Vec<(TermNode, TermNode)>,
    new_term_list_node_equalities: Vec<(TermListNode, TermListNode)>,
    new_opt_term_node_equalities: Vec<(OptTermNode, OptTermNode)>,
    new_if_atom_node_equalities: Vec<(IfAtomNode, IfAtomNode)>,
    new_then_atom_node_equalities: Vec<(ThenAtomNode, ThenAtomNode)>,
    new_stmt_node_equalities: Vec<(StmtNode, StmtNode)>,
    new_stmt_list_node_equalities: Vec<(StmtListNode, StmtListNode)>,
    new_rule_decl_node_equalities: Vec<(RuleDeclNode, RuleDeclNode)>,
    new_decl_node_equalities: Vec<(DeclNode, DeclNode)>,
    new_decl_list_node_equalities: Vec<(DeclListNode, DeclListNode)>,
    new_module_node_equalities: Vec<(ModuleNode, ModuleNode)>,
    new_loc_equalities: Vec<(Loc, Loc)>,
    new_rule_child_node_equalities: Vec<(RuleChildNode, RuleChildNode)>,
    new_type_equalities: Vec<(Type, Type)>,
    new_type_list_equalities: Vec<(TypeList, TypeList)>,
    new_pred_equalities: Vec<(Pred, Pred)>,
    new_func_equalities: Vec<(Func, Func)>,
    new_structure_equalities: Vec<(Structure, Structure)>,
    new_el_equalities: Vec<(El, El)>,
    new_el_list_equalities: Vec<(ElList, ElList)>,
    new_morphism_equalities: Vec<(Morphism, Morphism)>,
    new_chain_equalities: Vec<(Chain, Chain)>,
    new_symbol_kind_equalities: Vec<(SymbolKind, SymbolKind)>,
    new_nat_equalities: Vec<(Nat, Nat)>,
    new_ident_number: usize,
    new_virt_ident_number: usize,
    new_type_decl_node_number: usize,
    new_arg_decl_node_number: usize,
    new_arg_decl_list_node_number: usize,
    new_pred_decl_node_number: usize,
    new_func_decl_node_number: usize,
    new_term_node_number: usize,
    new_term_list_node_number: usize,
    new_opt_term_node_number: usize,
    new_if_atom_node_number: usize,
    new_then_atom_node_number: usize,
    new_stmt_node_number: usize,
    new_stmt_list_node_number: usize,
    new_rule_decl_node_number: usize,
    new_decl_node_number: usize,
    new_decl_list_node_number: usize,
    new_module_node_number: usize,
    new_loc_number: usize,
    new_rule_child_node_number: usize,
    new_type_number: usize,
    new_type_list_number: usize,
    new_pred_number: usize,
    new_func_number: usize,
    new_structure_number: usize,
    new_el_number: usize,
    new_el_list_number: usize,
    new_morphism_number: usize,
    new_chain_number: usize,
    new_symbol_kind_number: usize,
    new_nat_number: usize,
}
/// A model of the `Eqlog` theory.
#[derive(Debug, Clone)]
pub struct Eqlog {
    ident_equalities: Unification<Ident>,
    ident_all: BTreeSet<Ident>,
    ident_dirty: BTreeSet<Ident>,
    ident_dirty_prev: Vec<BTreeSet<Ident>>,
    ident_weights: Vec<usize>,

    virt_ident_equalities: Unification<VirtIdent>,
    virt_ident_all: BTreeSet<VirtIdent>,
    virt_ident_dirty: BTreeSet<VirtIdent>,
    virt_ident_dirty_prev: Vec<BTreeSet<VirtIdent>>,
    virt_ident_weights: Vec<usize>,

    type_decl_node_equalities: Unification<TypeDeclNode>,
    type_decl_node_all: BTreeSet<TypeDeclNode>,
    type_decl_node_dirty: BTreeSet<TypeDeclNode>,
    type_decl_node_dirty_prev: Vec<BTreeSet<TypeDeclNode>>,
    type_decl_node_weights: Vec<usize>,

    arg_decl_node_equalities: Unification<ArgDeclNode>,
    arg_decl_node_all: BTreeSet<ArgDeclNode>,
    arg_decl_node_dirty: BTreeSet<ArgDeclNode>,
    arg_decl_node_dirty_prev: Vec<BTreeSet<ArgDeclNode>>,
    arg_decl_node_weights: Vec<usize>,

    arg_decl_list_node_equalities: Unification<ArgDeclListNode>,
    arg_decl_list_node_all: BTreeSet<ArgDeclListNode>,
    arg_decl_list_node_dirty: BTreeSet<ArgDeclListNode>,
    arg_decl_list_node_dirty_prev: Vec<BTreeSet<ArgDeclListNode>>,
    arg_decl_list_node_weights: Vec<usize>,

    pred_decl_node_equalities: Unification<PredDeclNode>,
    pred_decl_node_all: BTreeSet<PredDeclNode>,
    pred_decl_node_dirty: BTreeSet<PredDeclNode>,
    pred_decl_node_dirty_prev: Vec<BTreeSet<PredDeclNode>>,
    pred_decl_node_weights: Vec<usize>,

    func_decl_node_equalities: Unification<FuncDeclNode>,
    func_decl_node_all: BTreeSet<FuncDeclNode>,
    func_decl_node_dirty: BTreeSet<FuncDeclNode>,
    func_decl_node_dirty_prev: Vec<BTreeSet<FuncDeclNode>>,
    func_decl_node_weights: Vec<usize>,

    term_node_equalities: Unification<TermNode>,
    term_node_all: BTreeSet<TermNode>,
    term_node_dirty: BTreeSet<TermNode>,
    term_node_dirty_prev: Vec<BTreeSet<TermNode>>,
    term_node_weights: Vec<usize>,

    term_list_node_equalities: Unification<TermListNode>,
    term_list_node_all: BTreeSet<TermListNode>,
    term_list_node_dirty: BTreeSet<TermListNode>,
    term_list_node_dirty_prev: Vec<BTreeSet<TermListNode>>,
    term_list_node_weights: Vec<usize>,

    opt_term_node_equalities: Unification<OptTermNode>,
    opt_term_node_all: BTreeSet<OptTermNode>,
    opt_term_node_dirty: BTreeSet<OptTermNode>,
    opt_term_node_dirty_prev: Vec<BTreeSet<OptTermNode>>,
    opt_term_node_weights: Vec<usize>,

    if_atom_node_equalities: Unification<IfAtomNode>,
    if_atom_node_all: BTreeSet<IfAtomNode>,
    if_atom_node_dirty: BTreeSet<IfAtomNode>,
    if_atom_node_dirty_prev: Vec<BTreeSet<IfAtomNode>>,
    if_atom_node_weights: Vec<usize>,

    then_atom_node_equalities: Unification<ThenAtomNode>,
    then_atom_node_all: BTreeSet<ThenAtomNode>,
    then_atom_node_dirty: BTreeSet<ThenAtomNode>,
    then_atom_node_dirty_prev: Vec<BTreeSet<ThenAtomNode>>,
    then_atom_node_weights: Vec<usize>,

    stmt_node_equalities: Unification<StmtNode>,
    stmt_node_all: BTreeSet<StmtNode>,
    stmt_node_dirty: BTreeSet<StmtNode>,
    stmt_node_dirty_prev: Vec<BTreeSet<StmtNode>>,
    stmt_node_weights: Vec<usize>,

    stmt_list_node_equalities: Unification<StmtListNode>,
    stmt_list_node_all: BTreeSet<StmtListNode>,
    stmt_list_node_dirty: BTreeSet<StmtListNode>,
    stmt_list_node_dirty_prev: Vec<BTreeSet<StmtListNode>>,
    stmt_list_node_weights: Vec<usize>,

    rule_decl_node_equalities: Unification<RuleDeclNode>,
    rule_decl_node_all: BTreeSet<RuleDeclNode>,
    rule_decl_node_dirty: BTreeSet<RuleDeclNode>,
    rule_decl_node_dirty_prev: Vec<BTreeSet<RuleDeclNode>>,
    rule_decl_node_weights: Vec<usize>,

    decl_node_equalities: Unification<DeclNode>,
    decl_node_all: BTreeSet<DeclNode>,
    decl_node_dirty: BTreeSet<DeclNode>,
    decl_node_dirty_prev: Vec<BTreeSet<DeclNode>>,
    decl_node_weights: Vec<usize>,

    decl_list_node_equalities: Unification<DeclListNode>,
    decl_list_node_all: BTreeSet<DeclListNode>,
    decl_list_node_dirty: BTreeSet<DeclListNode>,
    decl_list_node_dirty_prev: Vec<BTreeSet<DeclListNode>>,
    decl_list_node_weights: Vec<usize>,

    module_node_equalities: Unification<ModuleNode>,
    module_node_all: BTreeSet<ModuleNode>,
    module_node_dirty: BTreeSet<ModuleNode>,
    module_node_dirty_prev: Vec<BTreeSet<ModuleNode>>,
    module_node_weights: Vec<usize>,

    loc_equalities: Unification<Loc>,
    loc_all: BTreeSet<Loc>,
    loc_dirty: BTreeSet<Loc>,
    loc_dirty_prev: Vec<BTreeSet<Loc>>,
    loc_weights: Vec<usize>,

    rule_child_node_equalities: Unification<RuleChildNode>,
    rule_child_node_all: BTreeSet<RuleChildNode>,
    rule_child_node_dirty: BTreeSet<RuleChildNode>,
    rule_child_node_dirty_prev: Vec<BTreeSet<RuleChildNode>>,
    rule_child_node_weights: Vec<usize>,

    type_equalities: Unification<Type>,
    type_all: BTreeSet<Type>,
    type_dirty: BTreeSet<Type>,
    type_dirty_prev: Vec<BTreeSet<Type>>,
    type_weights: Vec<usize>,

    type_list_equalities: Unification<TypeList>,
    type_list_all: BTreeSet<TypeList>,
    type_list_dirty: BTreeSet<TypeList>,
    type_list_dirty_prev: Vec<BTreeSet<TypeList>>,
    type_list_weights: Vec<usize>,

    pred_equalities: Unification<Pred>,
    pred_all: BTreeSet<Pred>,
    pred_dirty: BTreeSet<Pred>,
    pred_dirty_prev: Vec<BTreeSet<Pred>>,
    pred_weights: Vec<usize>,

    func_equalities: Unification<Func>,
    func_all: BTreeSet<Func>,
    func_dirty: BTreeSet<Func>,
    func_dirty_prev: Vec<BTreeSet<Func>>,
    func_weights: Vec<usize>,

    structure_equalities: Unification<Structure>,
    structure_all: BTreeSet<Structure>,
    structure_dirty: BTreeSet<Structure>,
    structure_dirty_prev: Vec<BTreeSet<Structure>>,
    structure_weights: Vec<usize>,

    el_equalities: Unification<El>,
    el_all: BTreeSet<El>,
    el_dirty: BTreeSet<El>,
    el_dirty_prev: Vec<BTreeSet<El>>,
    el_weights: Vec<usize>,

    el_list_equalities: Unification<ElList>,
    el_list_all: BTreeSet<ElList>,
    el_list_dirty: BTreeSet<ElList>,
    el_list_dirty_prev: Vec<BTreeSet<ElList>>,
    el_list_weights: Vec<usize>,

    morphism_equalities: Unification<Morphism>,
    morphism_all: BTreeSet<Morphism>,
    morphism_dirty: BTreeSet<Morphism>,
    morphism_dirty_prev: Vec<BTreeSet<Morphism>>,
    morphism_weights: Vec<usize>,

    chain_equalities: Unification<Chain>,
    chain_all: BTreeSet<Chain>,
    chain_dirty: BTreeSet<Chain>,
    chain_dirty_prev: Vec<BTreeSet<Chain>>,
    chain_weights: Vec<usize>,

    symbol_kind_equalities: Unification<SymbolKind>,
    symbol_kind_all: BTreeSet<SymbolKind>,
    symbol_kind_dirty: BTreeSet<SymbolKind>,
    symbol_kind_dirty_prev: Vec<BTreeSet<SymbolKind>>,
    symbol_kind_weights: Vec<usize>,

    nat_equalities: Unification<Nat>,
    nat_all: BTreeSet<Nat>,
    nat_dirty: BTreeSet<Nat>,
    nat_dirty_prev: Vec<BTreeSet<Nat>>,
    nat_weights: Vec<usize>,

    absurd: AbsurdTable,
    type_decl: TypeDeclTable,
    arg_decl_node_name: ArgDeclNodeNameTable,
    arg_decl_node_type: ArgDeclNodeTypeTable,
    nil_arg_decl_list_node: NilArgDeclListNodeTable,
    cons_arg_decl_list_node: ConsArgDeclListNodeTable,
    pred_decl: PredDeclTable,
    func_decl: FuncDeclTable,
    nil_term_list_node: NilTermListNodeTable,
    cons_term_list_node: ConsTermListNodeTable,
    none_term_node: NoneTermNodeTable,
    some_term_node: SomeTermNodeTable,
    var_term_node: VarTermNodeTable,
    wildcard_term_node: WildcardTermNodeTable,
    app_term_node: AppTermNodeTable,
    equal_if_atom_node: EqualIfAtomNodeTable,
    defined_if_atom_node: DefinedIfAtomNodeTable,
    pred_if_atom_node: PredIfAtomNodeTable,
    var_if_atom_node: VarIfAtomNodeTable,
    equal_then_atom_node: EqualThenAtomNodeTable,
    defined_then_atom_node: DefinedThenAtomNodeTable,
    pred_then_atom_node: PredThenAtomNodeTable,
    if_stmt_node: IfStmtNodeTable,
    then_stmt_node: ThenStmtNodeTable,
    nil_stmt_list_node: NilStmtListNodeTable,
    cons_stmt_list_node: ConsStmtListNodeTable,
    rule_decl: RuleDeclTable,
    decl_node_type: DeclNodeTypeTable,
    decl_node_pred: DeclNodePredTable,
    decl_node_func: DeclNodeFuncTable,
    decl_node_rule: DeclNodeRuleTable,
    nil_decl_list_node: NilDeclListNodeTable,
    cons_decl_list_node: ConsDeclListNodeTable,
    decls_module_node: DeclsModuleNodeTable,
    rule_child: RuleChildTable,
    pred_app: PredAppTable,
    el_type: ElTypeTable,
    el_types: ElTypesTable,
    constrained_el: ConstrainedElTable,
    constrained_els: ConstrainedElsTable,
    in_ker: InKerTable,
    el_in_img: ElInImgTable,
    pred_tuple_in_img: PredTupleInImgTable,
    func_app_in_img: FuncAppInImgTable,
    defined_symbol: DefinedSymbolTable,
    should_be_symbol: ShouldBeSymbolTable,
    pred_arg_num_should_match: PredArgNumShouldMatchTable,
    func_arg_num_should_match: FuncArgNumShouldMatchTable,
    var_before_term: VarBeforeTermTable,
    var_before_terms: VarBeforeTermsTable,
    var_before_opt_term: VarBeforeOptTermTable,
    var_before_if_atom: VarBeforeIfAtomTable,
    var_before_then_atom: VarBeforeThenAtomTable,
    var_before_stmt: VarBeforeStmtTable,
    var_before_stmts: VarBeforeStmtsTable,
    var_in_term: VarInTermTable,
    var_in_terms: VarInTermsTable,
    var_in_opt_term: VarInOptTermTable,
    var_in_if_atom: VarInIfAtomTable,
    var_in_then_atom: VarInThenAtomTable,
    var_in_stmt: VarInStmtTable,
    term_should_be_epic_ok: TermShouldBeEpicOkTable,
    terms_should_be_epic_ok: TermsShouldBeEpicOkTable,
    should_be_surjective: ShouldBeSurjectiveTable,
    term_surjective_exempted: TermSurjectiveExemptedTable,
    terms_surjective_exempted: TermsSurjectiveExemptedTable,
    el_surjective_exempted: ElSurjectiveExemptedTable,
    el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable,
    el_is_surjective_ok: ElIsSurjectiveOkTable,
    var_term_in_rule: VarTermInRuleTable,
    if_after_then: IfAfterThenTable,
    real_virt_ident: RealVirtIdentTable,
    rule_name: RuleNameTable,
    type_decl_node_loc: TypeDeclNodeLocTable,
    arg_decl_node_loc: ArgDeclNodeLocTable,
    arg_decl_list_node_loc: ArgDeclListNodeLocTable,
    pred_decl_node_loc: PredDeclNodeLocTable,
    func_decl_node_loc: FuncDeclNodeLocTable,
    term_node_loc: TermNodeLocTable,
    term_list_node_loc: TermListNodeLocTable,
    opt_term_node_loc: OptTermNodeLocTable,
    if_atom_node_loc: IfAtomNodeLocTable,
    then_atom_node_loc: ThenAtomNodeLocTable,
    stmt_node_loc: StmtNodeLocTable,
    stmt_list_node_loc: StmtListNodeLocTable,
    rule_decl_node_loc: RuleDeclNodeLocTable,
    decl_node_loc: DeclNodeLocTable,
    decl_list_node_loc: DeclListNodeLocTable,
    module_node_loc: ModuleNodeLocTable,
    rule_child_term: RuleChildTermTable,
    rule_child_term_list: RuleChildTermListTable,
    rule_child_opt_term: RuleChildOptTermTable,
    rule_child_if_atom: RuleChildIfAtomTable,
    rule_child_then_atom: RuleChildThenAtomTable,
    rule_child_stmt: RuleChildStmtTable,
    rule_child_stmt_list: RuleChildStmtListTable,
    nil_type_list: NilTypeListTable,
    cons_type_list: ConsTypeListTable,
    semantic_type: SemanticTypeTable,
    semantic_arg_types: SemanticArgTypesTable,
    semantic_pred: SemanticPredTable,
    arity: ArityTable,
    semantic_func: SemanticFuncTable,
    domain: DomainTable,
    codomain: CodomainTable,
    nil_el_list: NilElListTable,
    cons_el_list: ConsElListTable,
    func_app: FuncAppTable,
    var: VarTable,
    el_structure: ElStructureTable,
    els_structure: ElsStructureTable,
    dom: DomTable,
    cod: CodTable,
    map_el: MapElTable,
    map_els: MapElsTable,
    initial_structure: InitialStructureTable,
    initiality_morphism: InitialityMorphismTable,
    nil_chain: NilChainTable,
    chain_tail: ChainTailTable,
    chain_head_structure: ChainHeadStructureTable,
    chain_head_transition: ChainHeadTransitionTable,
    type_symbol: TypeSymbolTable,
    pred_symbol: PredSymbolTable,
    func_symbol: FuncSymbolTable,
    rule_symbol: RuleSymbolTable,
    zero: ZeroTable,
    succ: SuccTable,
    type_list_len: TypeListLenTable,
    term_list_len: TermListLenTable,
    rule_chain: RuleChainTable,
    stmt_list_chain: StmtListChainTable,
    stmt_structure: StmtStructureTable,
    if_atom_structure: IfAtomStructureTable,
    then_atom_structure: ThenAtomStructureTable,
    term_structure: TermStructureTable,
    terms_structure: TermsStructureTable,
    opt_term_structure: OptTermStructureTable,
    semantic_el: SemanticElTable,
    semantic_els: SemanticElsTable,
    wildcard_virt_ident: WildcardVirtIdentTable,
    grouped_rule_chain: GroupedRuleChainTable,
    grouped_stmt_list_chain: GroupedStmtListChainTable,
    empty_join_is_dirty: bool,
    empty_join_is_dirty_prev: bool,
    delta: Option<Box<ModelDelta>>,
}
type Model = Eqlog;
impl ModelDelta {
    fn new() -> ModelDelta {
        ModelDelta {
            new_absurd: Vec::new(),
            new_type_decl: Vec::new(),
            new_arg_decl_node_name: Vec::new(),
            new_arg_decl_node_type: Vec::new(),
            new_nil_arg_decl_list_node: Vec::new(),
            new_cons_arg_decl_list_node: Vec::new(),
            new_pred_decl: Vec::new(),
            new_func_decl: Vec::new(),
            new_nil_term_list_node: Vec::new(),
            new_cons_term_list_node: Vec::new(),
            new_none_term_node: Vec::new(),
            new_some_term_node: Vec::new(),
            new_var_term_node: Vec::new(),
            new_wildcard_term_node: Vec::new(),
            new_app_term_node: Vec::new(),
            new_equal_if_atom_node: Vec::new(),
            new_defined_if_atom_node: Vec::new(),
            new_pred_if_atom_node: Vec::new(),
            new_var_if_atom_node: Vec::new(),
            new_equal_then_atom_node: Vec::new(),
            new_defined_then_atom_node: Vec::new(),
            new_pred_then_atom_node: Vec::new(),
            new_if_stmt_node: Vec::new(),
            new_then_stmt_node: Vec::new(),
            new_nil_stmt_list_node: Vec::new(),
            new_cons_stmt_list_node: Vec::new(),
            new_rule_decl: Vec::new(),
            new_decl_node_type: Vec::new(),
            new_decl_node_pred: Vec::new(),
            new_decl_node_func: Vec::new(),
            new_decl_node_rule: Vec::new(),
            new_nil_decl_list_node: Vec::new(),
            new_cons_decl_list_node: Vec::new(),
            new_decls_module_node: Vec::new(),
            new_rule_child: Vec::new(),
            new_pred_app: Vec::new(),
            new_el_type: Vec::new(),
            new_el_types: Vec::new(),
            new_constrained_el: Vec::new(),
            new_constrained_els: Vec::new(),
            new_in_ker: Vec::new(),
            new_el_in_img: Vec::new(),
            new_pred_tuple_in_img: Vec::new(),
            new_func_app_in_img: Vec::new(),
            new_defined_symbol: Vec::new(),
            new_should_be_symbol: Vec::new(),
            new_pred_arg_num_should_match: Vec::new(),
            new_func_arg_num_should_match: Vec::new(),
            new_var_before_term: Vec::new(),
            new_var_before_terms: Vec::new(),
            new_var_before_opt_term: Vec::new(),
            new_var_before_if_atom: Vec::new(),
            new_var_before_then_atom: Vec::new(),
            new_var_before_stmt: Vec::new(),
            new_var_before_stmts: Vec::new(),
            new_var_in_term: Vec::new(),
            new_var_in_terms: Vec::new(),
            new_var_in_opt_term: Vec::new(),
            new_var_in_if_atom: Vec::new(),
            new_var_in_then_atom: Vec::new(),
            new_var_in_stmt: Vec::new(),
            new_term_should_be_epic_ok: Vec::new(),
            new_terms_should_be_epic_ok: Vec::new(),
            new_should_be_surjective: Vec::new(),
            new_term_surjective_exempted: Vec::new(),
            new_terms_surjective_exempted: Vec::new(),
            new_el_surjective_exempted: Vec::new(),
            new_el_should_be_surjective_ok: Vec::new(),
            new_el_is_surjective_ok: Vec::new(),
            new_var_term_in_rule: Vec::new(),
            new_if_after_then: Vec::new(),
            new_real_virt_ident: Vec::new(),
            new_rule_name: Vec::new(),
            new_type_decl_node_loc: Vec::new(),
            new_arg_decl_node_loc: Vec::new(),
            new_arg_decl_list_node_loc: Vec::new(),
            new_pred_decl_node_loc: Vec::new(),
            new_func_decl_node_loc: Vec::new(),
            new_term_node_loc: Vec::new(),
            new_term_list_node_loc: Vec::new(),
            new_opt_term_node_loc: Vec::new(),
            new_if_atom_node_loc: Vec::new(),
            new_then_atom_node_loc: Vec::new(),
            new_stmt_node_loc: Vec::new(),
            new_stmt_list_node_loc: Vec::new(),
            new_rule_decl_node_loc: Vec::new(),
            new_decl_node_loc: Vec::new(),
            new_decl_list_node_loc: Vec::new(),
            new_module_node_loc: Vec::new(),
            new_rule_child_term: Vec::new(),
            new_rule_child_term_list: Vec::new(),
            new_rule_child_opt_term: Vec::new(),
            new_rule_child_if_atom: Vec::new(),
            new_rule_child_then_atom: Vec::new(),
            new_rule_child_stmt: Vec::new(),
            new_rule_child_stmt_list: Vec::new(),
            new_nil_type_list: Vec::new(),
            new_cons_type_list: Vec::new(),
            new_semantic_type: Vec::new(),
            new_semantic_arg_types: Vec::new(),
            new_semantic_pred: Vec::new(),
            new_arity: Vec::new(),
            new_semantic_func: Vec::new(),
            new_domain: Vec::new(),
            new_codomain: Vec::new(),
            new_nil_el_list: Vec::new(),
            new_cons_el_list: Vec::new(),
            new_func_app: Vec::new(),
            new_var: Vec::new(),
            new_el_structure: Vec::new(),
            new_els_structure: Vec::new(),
            new_dom: Vec::new(),
            new_cod: Vec::new(),
            new_map_el: Vec::new(),
            new_map_els: Vec::new(),
            new_initial_structure: Vec::new(),
            new_initiality_morphism: Vec::new(),
            new_nil_chain: Vec::new(),
            new_chain_tail: Vec::new(),
            new_chain_head_structure: Vec::new(),
            new_chain_head_transition: Vec::new(),
            new_type_symbol: Vec::new(),
            new_pred_symbol: Vec::new(),
            new_func_symbol: Vec::new(),
            new_rule_symbol: Vec::new(),
            new_zero: Vec::new(),
            new_succ: Vec::new(),
            new_type_list_len: Vec::new(),
            new_term_list_len: Vec::new(),
            new_rule_chain: Vec::new(),
            new_stmt_list_chain: Vec::new(),
            new_stmt_structure: Vec::new(),
            new_if_atom_structure: Vec::new(),
            new_then_atom_structure: Vec::new(),
            new_term_structure: Vec::new(),
            new_terms_structure: Vec::new(),
            new_opt_term_structure: Vec::new(),
            new_semantic_el: Vec::new(),
            new_semantic_els: Vec::new(),
            new_wildcard_virt_ident: Vec::new(),
            new_grouped_rule_chain: Vec::new(),
            new_grouped_stmt_list_chain: Vec::new(),
            new_ident_equalities: Vec::new(),
            new_virt_ident_equalities: Vec::new(),
            new_type_decl_node_equalities: Vec::new(),
            new_arg_decl_node_equalities: Vec::new(),
            new_arg_decl_list_node_equalities: Vec::new(),
            new_pred_decl_node_equalities: Vec::new(),
            new_func_decl_node_equalities: Vec::new(),
            new_term_node_equalities: Vec::new(),
            new_term_list_node_equalities: Vec::new(),
            new_opt_term_node_equalities: Vec::new(),
            new_if_atom_node_equalities: Vec::new(),
            new_then_atom_node_equalities: Vec::new(),
            new_stmt_node_equalities: Vec::new(),
            new_stmt_list_node_equalities: Vec::new(),
            new_rule_decl_node_equalities: Vec::new(),
            new_decl_node_equalities: Vec::new(),
            new_decl_list_node_equalities: Vec::new(),
            new_module_node_equalities: Vec::new(),
            new_loc_equalities: Vec::new(),
            new_rule_child_node_equalities: Vec::new(),
            new_type_equalities: Vec::new(),
            new_type_list_equalities: Vec::new(),
            new_pred_equalities: Vec::new(),
            new_func_equalities: Vec::new(),
            new_structure_equalities: Vec::new(),
            new_el_equalities: Vec::new(),
            new_el_list_equalities: Vec::new(),
            new_morphism_equalities: Vec::new(),
            new_chain_equalities: Vec::new(),
            new_symbol_kind_equalities: Vec::new(),
            new_nat_equalities: Vec::new(),
            new_ident_number: 0,
            new_virt_ident_number: 0,
            new_type_decl_node_number: 0,
            new_arg_decl_node_number: 0,
            new_arg_decl_list_node_number: 0,
            new_pred_decl_node_number: 0,
            new_func_decl_node_number: 0,
            new_term_node_number: 0,
            new_term_list_node_number: 0,
            new_opt_term_node_number: 0,
            new_if_atom_node_number: 0,
            new_then_atom_node_number: 0,
            new_stmt_node_number: 0,
            new_stmt_list_node_number: 0,
            new_rule_decl_node_number: 0,
            new_decl_node_number: 0,
            new_decl_list_node_number: 0,
            new_module_node_number: 0,
            new_loc_number: 0,
            new_rule_child_node_number: 0,
            new_type_number: 0,
            new_type_list_number: 0,
            new_pred_number: 0,
            new_func_number: 0,
            new_structure_number: 0,
            new_el_number: 0,
            new_el_list_number: 0,
            new_morphism_number: 0,
            new_chain_number: 0,
            new_symbol_kind_number: 0,
            new_nat_number: 0,
        }
    }
    fn apply(&mut self, model: &mut Model) {
        self.apply_new_elements(model);
        self.apply_equalities(model);
        self.apply_tuples(model);
    }
    #[allow(unused)]
    fn apply_new_elements(&mut self, model: &mut Model) {
        let old_ident_number = model.ident_equalities.len();
        let new_ident_number = old_ident_number + self.new_ident_number;
        model.ident_equalities.increase_size_to(new_ident_number);
        for i in old_ident_number..new_ident_number {
            let el = Ident::from(i as u32);
            model.ident_dirty.insert(el);
            model.ident_all.insert(el);
        }

        model.ident_weights.resize(new_ident_number, 0);

        self.new_ident_number = 0;

        let old_virt_ident_number = model.virt_ident_equalities.len();
        let new_virt_ident_number = old_virt_ident_number + self.new_virt_ident_number;
        model
            .virt_ident_equalities
            .increase_size_to(new_virt_ident_number);
        for i in old_virt_ident_number..new_virt_ident_number {
            let el = VirtIdent::from(i as u32);
            model.virt_ident_dirty.insert(el);
            model.virt_ident_all.insert(el);
        }

        model.virt_ident_weights.resize(new_virt_ident_number, 0);

        self.new_virt_ident_number = 0;

        let old_type_decl_node_number = model.type_decl_node_equalities.len();
        let new_type_decl_node_number = old_type_decl_node_number + self.new_type_decl_node_number;
        model
            .type_decl_node_equalities
            .increase_size_to(new_type_decl_node_number);
        for i in old_type_decl_node_number..new_type_decl_node_number {
            let el = TypeDeclNode::from(i as u32);
            model.type_decl_node_dirty.insert(el);
            model.type_decl_node_all.insert(el);
        }

        model
            .type_decl_node_weights
            .resize(new_type_decl_node_number, 0);

        self.new_type_decl_node_number = 0;

        let old_arg_decl_node_number = model.arg_decl_node_equalities.len();
        let new_arg_decl_node_number = old_arg_decl_node_number + self.new_arg_decl_node_number;
        model
            .arg_decl_node_equalities
            .increase_size_to(new_arg_decl_node_number);
        for i in old_arg_decl_node_number..new_arg_decl_node_number {
            let el = ArgDeclNode::from(i as u32);
            model.arg_decl_node_dirty.insert(el);
            model.arg_decl_node_all.insert(el);
        }

        model
            .arg_decl_node_weights
            .resize(new_arg_decl_node_number, 0);

        self.new_arg_decl_node_number = 0;

        let old_arg_decl_list_node_number = model.arg_decl_list_node_equalities.len();
        let new_arg_decl_list_node_number =
            old_arg_decl_list_node_number + self.new_arg_decl_list_node_number;
        model
            .arg_decl_list_node_equalities
            .increase_size_to(new_arg_decl_list_node_number);
        for i in old_arg_decl_list_node_number..new_arg_decl_list_node_number {
            let el = ArgDeclListNode::from(i as u32);
            model.arg_decl_list_node_dirty.insert(el);
            model.arg_decl_list_node_all.insert(el);
        }

        model
            .arg_decl_list_node_weights
            .resize(new_arg_decl_list_node_number, 0);

        self.new_arg_decl_list_node_number = 0;

        let old_pred_decl_node_number = model.pred_decl_node_equalities.len();
        let new_pred_decl_node_number = old_pred_decl_node_number + self.new_pred_decl_node_number;
        model
            .pred_decl_node_equalities
            .increase_size_to(new_pred_decl_node_number);
        for i in old_pred_decl_node_number..new_pred_decl_node_number {
            let el = PredDeclNode::from(i as u32);
            model.pred_decl_node_dirty.insert(el);
            model.pred_decl_node_all.insert(el);
        }

        model
            .pred_decl_node_weights
            .resize(new_pred_decl_node_number, 0);

        self.new_pred_decl_node_number = 0;

        let old_func_decl_node_number = model.func_decl_node_equalities.len();
        let new_func_decl_node_number = old_func_decl_node_number + self.new_func_decl_node_number;
        model
            .func_decl_node_equalities
            .increase_size_to(new_func_decl_node_number);
        for i in old_func_decl_node_number..new_func_decl_node_number {
            let el = FuncDeclNode::from(i as u32);
            model.func_decl_node_dirty.insert(el);
            model.func_decl_node_all.insert(el);
        }

        model
            .func_decl_node_weights
            .resize(new_func_decl_node_number, 0);

        self.new_func_decl_node_number = 0;

        let old_term_node_number = model.term_node_equalities.len();
        let new_term_node_number = old_term_node_number + self.new_term_node_number;
        model
            .term_node_equalities
            .increase_size_to(new_term_node_number);
        for i in old_term_node_number..new_term_node_number {
            let el = TermNode::from(i as u32);
            model.term_node_dirty.insert(el);
            model.term_node_all.insert(el);
        }

        model.term_node_weights.resize(new_term_node_number, 0);

        self.new_term_node_number = 0;

        let old_term_list_node_number = model.term_list_node_equalities.len();
        let new_term_list_node_number = old_term_list_node_number + self.new_term_list_node_number;
        model
            .term_list_node_equalities
            .increase_size_to(new_term_list_node_number);
        for i in old_term_list_node_number..new_term_list_node_number {
            let el = TermListNode::from(i as u32);
            model.term_list_node_dirty.insert(el);
            model.term_list_node_all.insert(el);
        }

        model
            .term_list_node_weights
            .resize(new_term_list_node_number, 0);

        self.new_term_list_node_number = 0;

        let old_opt_term_node_number = model.opt_term_node_equalities.len();
        let new_opt_term_node_number = old_opt_term_node_number + self.new_opt_term_node_number;
        model
            .opt_term_node_equalities
            .increase_size_to(new_opt_term_node_number);
        for i in old_opt_term_node_number..new_opt_term_node_number {
            let el = OptTermNode::from(i as u32);
            model.opt_term_node_dirty.insert(el);
            model.opt_term_node_all.insert(el);
        }

        model
            .opt_term_node_weights
            .resize(new_opt_term_node_number, 0);

        self.new_opt_term_node_number = 0;

        let old_if_atom_node_number = model.if_atom_node_equalities.len();
        let new_if_atom_node_number = old_if_atom_node_number + self.new_if_atom_node_number;
        model
            .if_atom_node_equalities
            .increase_size_to(new_if_atom_node_number);
        for i in old_if_atom_node_number..new_if_atom_node_number {
            let el = IfAtomNode::from(i as u32);
            model.if_atom_node_dirty.insert(el);
            model.if_atom_node_all.insert(el);
        }

        model
            .if_atom_node_weights
            .resize(new_if_atom_node_number, 0);

        self.new_if_atom_node_number = 0;

        let old_then_atom_node_number = model.then_atom_node_equalities.len();
        let new_then_atom_node_number = old_then_atom_node_number + self.new_then_atom_node_number;
        model
            .then_atom_node_equalities
            .increase_size_to(new_then_atom_node_number);
        for i in old_then_atom_node_number..new_then_atom_node_number {
            let el = ThenAtomNode::from(i as u32);
            model.then_atom_node_dirty.insert(el);
            model.then_atom_node_all.insert(el);
        }

        model
            .then_atom_node_weights
            .resize(new_then_atom_node_number, 0);

        self.new_then_atom_node_number = 0;

        let old_stmt_node_number = model.stmt_node_equalities.len();
        let new_stmt_node_number = old_stmt_node_number + self.new_stmt_node_number;
        model
            .stmt_node_equalities
            .increase_size_to(new_stmt_node_number);
        for i in old_stmt_node_number..new_stmt_node_number {
            let el = StmtNode::from(i as u32);
            model.stmt_node_dirty.insert(el);
            model.stmt_node_all.insert(el);
        }

        model.stmt_node_weights.resize(new_stmt_node_number, 0);

        self.new_stmt_node_number = 0;

        let old_stmt_list_node_number = model.stmt_list_node_equalities.len();
        let new_stmt_list_node_number = old_stmt_list_node_number + self.new_stmt_list_node_number;
        model
            .stmt_list_node_equalities
            .increase_size_to(new_stmt_list_node_number);
        for i in old_stmt_list_node_number..new_stmt_list_node_number {
            let el = StmtListNode::from(i as u32);
            model.stmt_list_node_dirty.insert(el);
            model.stmt_list_node_all.insert(el);
        }

        model
            .stmt_list_node_weights
            .resize(new_stmt_list_node_number, 0);

        self.new_stmt_list_node_number = 0;

        let old_rule_decl_node_number = model.rule_decl_node_equalities.len();
        let new_rule_decl_node_number = old_rule_decl_node_number + self.new_rule_decl_node_number;
        model
            .rule_decl_node_equalities
            .increase_size_to(new_rule_decl_node_number);
        for i in old_rule_decl_node_number..new_rule_decl_node_number {
            let el = RuleDeclNode::from(i as u32);
            model.rule_decl_node_dirty.insert(el);
            model.rule_decl_node_all.insert(el);
        }

        model
            .rule_decl_node_weights
            .resize(new_rule_decl_node_number, 0);

        self.new_rule_decl_node_number = 0;

        let old_decl_node_number = model.decl_node_equalities.len();
        let new_decl_node_number = old_decl_node_number + self.new_decl_node_number;
        model
            .decl_node_equalities
            .increase_size_to(new_decl_node_number);
        for i in old_decl_node_number..new_decl_node_number {
            let el = DeclNode::from(i as u32);
            model.decl_node_dirty.insert(el);
            model.decl_node_all.insert(el);
        }

        model.decl_node_weights.resize(new_decl_node_number, 0);

        self.new_decl_node_number = 0;

        let old_decl_list_node_number = model.decl_list_node_equalities.len();
        let new_decl_list_node_number = old_decl_list_node_number + self.new_decl_list_node_number;
        model
            .decl_list_node_equalities
            .increase_size_to(new_decl_list_node_number);
        for i in old_decl_list_node_number..new_decl_list_node_number {
            let el = DeclListNode::from(i as u32);
            model.decl_list_node_dirty.insert(el);
            model.decl_list_node_all.insert(el);
        }

        model
            .decl_list_node_weights
            .resize(new_decl_list_node_number, 0);

        self.new_decl_list_node_number = 0;

        let old_module_node_number = model.module_node_equalities.len();
        let new_module_node_number = old_module_node_number + self.new_module_node_number;
        model
            .module_node_equalities
            .increase_size_to(new_module_node_number);
        for i in old_module_node_number..new_module_node_number {
            let el = ModuleNode::from(i as u32);
            model.module_node_dirty.insert(el);
            model.module_node_all.insert(el);
        }

        model.module_node_weights.resize(new_module_node_number, 0);

        self.new_module_node_number = 0;

        let old_loc_number = model.loc_equalities.len();
        let new_loc_number = old_loc_number + self.new_loc_number;
        model.loc_equalities.increase_size_to(new_loc_number);
        for i in old_loc_number..new_loc_number {
            let el = Loc::from(i as u32);
            model.loc_dirty.insert(el);
            model.loc_all.insert(el);
        }

        model.loc_weights.resize(new_loc_number, 0);

        self.new_loc_number = 0;

        let old_rule_child_node_number = model.rule_child_node_equalities.len();
        let new_rule_child_node_number =
            old_rule_child_node_number + self.new_rule_child_node_number;
        model
            .rule_child_node_equalities
            .increase_size_to(new_rule_child_node_number);
        for i in old_rule_child_node_number..new_rule_child_node_number {
            let el = RuleChildNode::from(i as u32);
            model.rule_child_node_dirty.insert(el);
            model.rule_child_node_all.insert(el);
        }

        model
            .rule_child_node_weights
            .resize(new_rule_child_node_number, 0);

        self.new_rule_child_node_number = 0;

        let old_type_number = model.type_equalities.len();
        let new_type_number = old_type_number + self.new_type_number;
        model.type_equalities.increase_size_to(new_type_number);
        for i in old_type_number..new_type_number {
            let el = Type::from(i as u32);
            model.type_dirty.insert(el);
            model.type_all.insert(el);
        }

        model.type_weights.resize(new_type_number, 0);

        self.new_type_number = 0;

        let old_type_list_number = model.type_list_equalities.len();
        let new_type_list_number = old_type_list_number + self.new_type_list_number;
        model
            .type_list_equalities
            .increase_size_to(new_type_list_number);
        for i in old_type_list_number..new_type_list_number {
            let el = TypeList::from(i as u32);
            model.type_list_dirty.insert(el);
            model.type_list_all.insert(el);
        }

        model.type_list_weights.resize(new_type_list_number, 0);

        self.new_type_list_number = 0;

        let old_pred_number = model.pred_equalities.len();
        let new_pred_number = old_pred_number + self.new_pred_number;
        model.pred_equalities.increase_size_to(new_pred_number);
        for i in old_pred_number..new_pred_number {
            let el = Pred::from(i as u32);
            model.pred_dirty.insert(el);
            model.pred_all.insert(el);
        }

        model.pred_weights.resize(new_pred_number, 0);

        self.new_pred_number = 0;

        let old_func_number = model.func_equalities.len();
        let new_func_number = old_func_number + self.new_func_number;
        model.func_equalities.increase_size_to(new_func_number);
        for i in old_func_number..new_func_number {
            let el = Func::from(i as u32);
            model.func_dirty.insert(el);
            model.func_all.insert(el);
        }

        model.func_weights.resize(new_func_number, 0);

        self.new_func_number = 0;

        let old_structure_number = model.structure_equalities.len();
        let new_structure_number = old_structure_number + self.new_structure_number;
        model
            .structure_equalities
            .increase_size_to(new_structure_number);
        for i in old_structure_number..new_structure_number {
            let el = Structure::from(i as u32);
            model.structure_dirty.insert(el);
            model.structure_all.insert(el);
        }

        model.structure_weights.resize(new_structure_number, 0);

        self.new_structure_number = 0;

        let old_el_number = model.el_equalities.len();
        let new_el_number = old_el_number + self.new_el_number;
        model.el_equalities.increase_size_to(new_el_number);
        for i in old_el_number..new_el_number {
            let el = El::from(i as u32);
            model.el_dirty.insert(el);
            model.el_all.insert(el);
        }

        model.el_weights.resize(new_el_number, 0);

        self.new_el_number = 0;

        let old_el_list_number = model.el_list_equalities.len();
        let new_el_list_number = old_el_list_number + self.new_el_list_number;
        model
            .el_list_equalities
            .increase_size_to(new_el_list_number);
        for i in old_el_list_number..new_el_list_number {
            let el = ElList::from(i as u32);
            model.el_list_dirty.insert(el);
            model.el_list_all.insert(el);
        }

        model.el_list_weights.resize(new_el_list_number, 0);

        self.new_el_list_number = 0;

        let old_morphism_number = model.morphism_equalities.len();
        let new_morphism_number = old_morphism_number + self.new_morphism_number;
        model
            .morphism_equalities
            .increase_size_to(new_morphism_number);
        for i in old_morphism_number..new_morphism_number {
            let el = Morphism::from(i as u32);
            model.morphism_dirty.insert(el);
            model.morphism_all.insert(el);
        }

        model.morphism_weights.resize(new_morphism_number, 0);

        self.new_morphism_number = 0;

        let old_chain_number = model.chain_equalities.len();
        let new_chain_number = old_chain_number + self.new_chain_number;
        model.chain_equalities.increase_size_to(new_chain_number);
        for i in old_chain_number..new_chain_number {
            let el = Chain::from(i as u32);
            model.chain_dirty.insert(el);
            model.chain_all.insert(el);
        }

        model.chain_weights.resize(new_chain_number, 0);

        self.new_chain_number = 0;

        let old_symbol_kind_number = model.symbol_kind_equalities.len();
        let new_symbol_kind_number = old_symbol_kind_number + self.new_symbol_kind_number;
        model
            .symbol_kind_equalities
            .increase_size_to(new_symbol_kind_number);
        for i in old_symbol_kind_number..new_symbol_kind_number {
            let el = SymbolKind::from(i as u32);
            model.symbol_kind_dirty.insert(el);
            model.symbol_kind_all.insert(el);
        }

        model.symbol_kind_weights.resize(new_symbol_kind_number, 0);

        self.new_symbol_kind_number = 0;

        let old_nat_number = model.nat_equalities.len();
        let new_nat_number = old_nat_number + self.new_nat_number;
        model.nat_equalities.increase_size_to(new_nat_number);
        for i in old_nat_number..new_nat_number {
            let el = Nat::from(i as u32);
            model.nat_dirty.insert(el);
            model.nat_all.insert(el);
        }

        model.nat_weights.resize(new_nat_number, 0);

        self.new_nat_number = 0;
    }
    #[allow(unused)]
    fn apply_equalities(&mut self, model: &mut Model) {
        for (mut lhs, mut rhs) in self.new_ident_equalities.drain(..) {
            lhs = model.ident_equalities.root(lhs);
            rhs = model.ident_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.ident_weights[lhs.0 as usize];
            let rhs_weight = model.ident_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.ident_equalities.union_roots_into(child, root);
            model.ident_all.remove(&child);
            model.ident_dirty.remove(&child);

            self.new_type_decl
                .extend(
                    model
                        .type_decl
                        .drain_with_element_ident(child)
                        .inspect(|t| {
                            let weight0 = model
                                .type_decl_node_weights
                                .get_mut(t.0 .0 as usize)
                                .unwrap();
                            *weight0 -= TypeDeclTable::WEIGHT;

                            let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= TypeDeclTable::WEIGHT;
                        }),
                );

            self.new_arg_decl_node_name.extend(
                model
                    .arg_decl_node_name
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeNameTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeNameTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_node_type.extend(
                model
                    .arg_decl_node_type
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeTypeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeTypeTable::WEIGHT;
                    }),
            );

            self.new_pred_decl
                .extend(
                    model
                        .pred_decl
                        .drain_with_element_ident(child)
                        .inspect(|t| {
                            let weight0 = model
                                .pred_decl_node_weights
                                .get_mut(t.0 .0 as usize)
                                .unwrap();
                            *weight0 -= PredDeclTable::WEIGHT;

                            let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= PredDeclTable::WEIGHT;

                            let weight2 = model
                                .arg_decl_list_node_weights
                                .get_mut(t.2 .0 as usize)
                                .unwrap();
                            *weight2 -= PredDeclTable::WEIGHT;
                        }),
                );

            self.new_func_decl
                .extend(
                    model
                        .func_decl
                        .drain_with_element_ident(child)
                        .inspect(|t| {
                            let weight0 = model
                                .func_decl_node_weights
                                .get_mut(t.0 .0 as usize)
                                .unwrap();
                            *weight0 -= FuncDeclTable::WEIGHT;

                            let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= FuncDeclTable::WEIGHT;

                            let weight2 = model
                                .arg_decl_list_node_weights
                                .get_mut(t.2 .0 as usize)
                                .unwrap();
                            *weight2 -= FuncDeclTable::WEIGHT;

                            let weight3 = model.ident_weights.get_mut(t.3 .0 as usize).unwrap();
                            *weight3 -= FuncDeclTable::WEIGHT;
                        }),
                );

            self.new_var_term_node.extend(
                model
                    .var_term_node
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarTermNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarTermNodeTable::WEIGHT;
                    }),
            );

            self.new_app_term_node.extend(
                model
                    .app_term_node
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= AppTermNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= AppTermNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= AppTermNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_if_atom_node.extend(
                model
                    .pred_if_atom_node
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredIfAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredIfAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_if_atom_node.extend(
                model
                    .var_if_atom_node
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarIfAtomNodeTable::WEIGHT;

                        let weight2 = model.ident_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= VarIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_then_atom_node.extend(
                model
                    .pred_then_atom_node
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredThenAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredThenAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_symbol.extend(
                model
                    .defined_symbol
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DefinedSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DefinedSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedSymbolTable::WEIGHT;
                    }),
            );

            self.new_should_be_symbol.extend(
                model
                    .should_be_symbol
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ShouldBeSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ShouldBeSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ShouldBeSymbolTable::WEIGHT;
                    }),
            );

            self.new_var_term_in_rule.extend(
                model
                    .var_term_in_rule
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarTermInRuleTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarTermInRuleTable::WEIGHT;

                        let weight2 = model
                            .rule_decl_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= VarTermInRuleTable::WEIGHT;
                    }),
            );

            self.new_real_virt_ident.extend(
                model
                    .real_virt_ident
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RealVirtIdentTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RealVirtIdentTable::WEIGHT;
                    }),
            );

            self.new_rule_name
                .extend(
                    model
                        .rule_name
                        .drain_with_element_ident(child)
                        .inspect(|t| {
                            let weight0 = model
                                .rule_decl_node_weights
                                .get_mut(t.0 .0 as usize)
                                .unwrap();
                            *weight0 -= RuleNameTable::WEIGHT;

                            let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= RuleNameTable::WEIGHT;
                        }),
                );

            self.new_semantic_type.extend(
                model
                    .semantic_type
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticTypeTable::WEIGHT;

                        let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticTypeTable::WEIGHT;
                    }),
            );

            self.new_semantic_pred.extend(
                model
                    .semantic_pred
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticPredTable::WEIGHT;

                        let weight1 = model.pred_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticPredTable::WEIGHT;
                    }),
            );

            self.new_semantic_func.extend(
                model
                    .semantic_func
                    .drain_with_element_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticFuncTable::WEIGHT;

                        let weight1 = model.func_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticFuncTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_virt_ident_equalities.drain(..) {
            lhs = model.virt_ident_equalities.root(lhs);
            rhs = model.virt_ident_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.virt_ident_weights[lhs.0 as usize];
            let rhs_weight = model.virt_ident_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.virt_ident_equalities.union_roots_into(child, root);
            model.virt_ident_all.remove(&child);
            model.virt_ident_dirty.remove(&child);

            self.new_var_before_term.extend(
                model
                    .var_before_term
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeTermTable::WEIGHT;
                    }),
            );

            self.new_var_before_terms.extend(
                model
                    .var_before_terms
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeTermsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeTermsTable::WEIGHT;
                    }),
            );

            self.new_var_before_opt_term.extend(
                model
                    .var_before_opt_term
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeOptTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeOptTermTable::WEIGHT;
                    }),
            );

            self.new_var_before_if_atom.extend(
                model
                    .var_before_if_atom
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeIfAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeIfAtomTable::WEIGHT;
                    }),
            );

            self.new_var_before_then_atom.extend(
                model
                    .var_before_then_atom
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeThenAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeThenAtomTable::WEIGHT;
                    }),
            );

            self.new_var_before_stmt.extend(
                model
                    .var_before_stmt
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeStmtTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeStmtTable::WEIGHT;
                    }),
            );

            self.new_var_before_stmts.extend(
                model
                    .var_before_stmts
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeStmtsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeStmtsTable::WEIGHT;
                    }),
            );

            self.new_var_in_term.extend(
                model
                    .var_in_term
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInTermTable::WEIGHT;
                    }),
            );

            self.new_var_in_terms.extend(
                model
                    .var_in_terms
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInTermsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInTermsTable::WEIGHT;
                    }),
            );

            self.new_var_in_opt_term.extend(
                model
                    .var_in_opt_term
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInOptTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInOptTermTable::WEIGHT;
                    }),
            );

            self.new_var_in_if_atom.extend(
                model
                    .var_in_if_atom
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInIfAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInIfAtomTable::WEIGHT;
                    }),
            );

            self.new_var_in_then_atom.extend(
                model
                    .var_in_then_atom
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInThenAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInThenAtomTable::WEIGHT;
                    }),
            );

            self.new_var_in_stmt.extend(
                model
                    .var_in_stmt
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInStmtTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInStmtTable::WEIGHT;
                    }),
            );

            self.new_real_virt_ident.extend(
                model
                    .real_virt_ident
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RealVirtIdentTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RealVirtIdentTable::WEIGHT;
                    }),
            );

            self.new_var
                .extend(model.var.drain_with_element_virt_ident(child).inspect(|t| {
                    let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= VarTable::WEIGHT;

                    let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= VarTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= VarTable::WEIGHT;
                }));

            self.new_wildcard_virt_ident.extend(
                model
                    .wildcard_virt_ident
                    .drain_with_element_virt_ident(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= WildcardVirtIdentTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= WildcardVirtIdentTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_type_decl_node_equalities.drain(..) {
            lhs = model.type_decl_node_equalities.root(lhs);
            rhs = model.type_decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.type_decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.type_decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .type_decl_node_equalities
                .union_roots_into(child, root);
            model.type_decl_node_all.remove(&child);
            model.type_decl_node_dirty.remove(&child);

            self.new_type_decl.extend(
                model
                    .type_decl
                    .drain_with_element_type_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .type_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TypeDeclTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TypeDeclTable::WEIGHT;
                    }),
            );

            self.new_decl_node_type.extend(
                model
                    .decl_node_type
                    .drain_with_element_type_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeTypeTable::WEIGHT;

                        let weight1 = model
                            .type_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeTypeTable::WEIGHT;
                    }),
            );

            self.new_type_decl_node_loc.extend(
                model
                    .type_decl_node_loc
                    .drain_with_element_type_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .type_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TypeDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TypeDeclNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_arg_decl_node_equalities.drain(..) {
            lhs = model.arg_decl_node_equalities.root(lhs);
            rhs = model.arg_decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.arg_decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.arg_decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.arg_decl_node_equalities.union_roots_into(child, root);
            model.arg_decl_node_all.remove(&child);
            model.arg_decl_node_dirty.remove(&child);

            self.new_arg_decl_node_name.extend(
                model
                    .arg_decl_node_name
                    .drain_with_element_arg_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeNameTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeNameTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_node_type.extend(
                model
                    .arg_decl_node_type
                    .drain_with_element_arg_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeTypeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeTypeTable::WEIGHT;
                    }),
            );

            self.new_cons_arg_decl_list_node.extend(
                model
                    .cons_arg_decl_list_node
                    .drain_with_element_arg_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsArgDeclListNodeTable::WEIGHT;

                        let weight1 = model
                            .arg_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= ConsArgDeclListNodeTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsArgDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_node_loc.extend(
                model
                    .arg_decl_node_loc
                    .drain_with_element_arg_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_arg_decl_list_node_equalities.drain(..) {
            lhs = model.arg_decl_list_node_equalities.root(lhs);
            rhs = model.arg_decl_list_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.arg_decl_list_node_weights[lhs.0 as usize];
            let rhs_weight = model.arg_decl_list_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .arg_decl_list_node_equalities
                .union_roots_into(child, root);
            model.arg_decl_list_node_all.remove(&child);
            model.arg_decl_list_node_dirty.remove(&child);

            self.new_nil_arg_decl_list_node.extend(
                model
                    .nil_arg_decl_list_node
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= NilArgDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_cons_arg_decl_list_node.extend(
                model
                    .cons_arg_decl_list_node
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsArgDeclListNodeTable::WEIGHT;

                        let weight1 = model
                            .arg_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= ConsArgDeclListNodeTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsArgDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_decl.extend(
                model
                    .pred_decl
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .pred_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredDeclTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredDeclTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredDeclTable::WEIGHT;
                    }),
            );

            self.new_func_decl.extend(
                model
                    .func_decl
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .func_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= FuncDeclTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncDeclTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= FuncDeclTable::WEIGHT;

                        let weight3 = model.ident_weights.get_mut(t.3 .0 as usize).unwrap();
                        *weight3 -= FuncDeclTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_list_node_loc.extend(
                model
                    .arg_decl_list_node_loc
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_semantic_arg_types.extend(
                model
                    .semantic_arg_types
                    .drain_with_element_arg_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SemanticArgTypesTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticArgTypesTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_pred_decl_node_equalities.drain(..) {
            lhs = model.pred_decl_node_equalities.root(lhs);
            rhs = model.pred_decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.pred_decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.pred_decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .pred_decl_node_equalities
                .union_roots_into(child, root);
            model.pred_decl_node_all.remove(&child);
            model.pred_decl_node_dirty.remove(&child);

            self.new_pred_decl.extend(
                model
                    .pred_decl
                    .drain_with_element_pred_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .pred_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredDeclTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredDeclTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredDeclTable::WEIGHT;
                    }),
            );

            self.new_decl_node_pred.extend(
                model
                    .decl_node_pred
                    .drain_with_element_pred_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodePredTable::WEIGHT;

                        let weight1 = model
                            .pred_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodePredTable::WEIGHT;
                    }),
            );

            self.new_pred_decl_node_loc.extend(
                model
                    .pred_decl_node_loc
                    .drain_with_element_pred_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .pred_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredDeclNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_func_decl_node_equalities.drain(..) {
            lhs = model.func_decl_node_equalities.root(lhs);
            rhs = model.func_decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.func_decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.func_decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .func_decl_node_equalities
                .union_roots_into(child, root);
            model.func_decl_node_all.remove(&child);
            model.func_decl_node_dirty.remove(&child);

            self.new_func_decl.extend(
                model
                    .func_decl
                    .drain_with_element_func_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .func_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= FuncDeclTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncDeclTable::WEIGHT;

                        let weight2 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= FuncDeclTable::WEIGHT;

                        let weight3 = model.ident_weights.get_mut(t.3 .0 as usize).unwrap();
                        *weight3 -= FuncDeclTable::WEIGHT;
                    }),
            );

            self.new_decl_node_func.extend(
                model
                    .decl_node_func
                    .drain_with_element_func_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeFuncTable::WEIGHT;

                        let weight1 = model
                            .func_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeFuncTable::WEIGHT;
                    }),
            );

            self.new_func_decl_node_loc.extend(
                model
                    .func_decl_node_loc
                    .drain_with_element_func_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .func_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= FuncDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncDeclNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_term_node_equalities.drain(..) {
            lhs = model.term_node_equalities.root(lhs);
            rhs = model.term_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.term_node_weights[lhs.0 as usize];
            let rhs_weight = model.term_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.term_node_equalities.union_roots_into(child, root);
            model.term_node_all.remove(&child);
            model.term_node_dirty.remove(&child);

            self.new_cons_term_list_node.extend(
                model
                    .cons_term_list_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsTermListNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsTermListNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsTermListNodeTable::WEIGHT;
                    }),
            );

            self.new_some_term_node.extend(
                model
                    .some_term_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SomeTermNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SomeTermNodeTable::WEIGHT;
                    }),
            );

            self.new_var_term_node.extend(
                model
                    .var_term_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarTermNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarTermNodeTable::WEIGHT;
                    }),
            );

            self.new_wildcard_term_node.extend(
                model
                    .wildcard_term_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= WildcardTermNodeTable::WEIGHT;
                    }),
            );

            self.new_app_term_node.extend(
                model
                    .app_term_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= AppTermNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= AppTermNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= AppTermNodeTable::WEIGHT;
                    }),
            );

            self.new_equal_if_atom_node.extend(
                model
                    .equal_if_atom_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= EqualIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= EqualIfAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= EqualIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_if_atom_node.extend(
                model
                    .defined_if_atom_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DefinedIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DefinedIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_if_atom_node.extend(
                model
                    .var_if_atom_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarIfAtomNodeTable::WEIGHT;

                        let weight2 = model.ident_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= VarIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_equal_then_atom_node.extend(
                model
                    .equal_then_atom_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= EqualThenAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= EqualThenAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= EqualThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_then_atom_node.extend(
                model
                    .defined_then_atom_node
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight1 = model
                            .opt_term_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_term.extend(
                model
                    .var_before_term
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeTermTable::WEIGHT;
                    }),
            );

            self.new_var_in_term.extend(
                model
                    .var_in_term
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInTermTable::WEIGHT;
                    }),
            );

            self.new_term_should_be_epic_ok.extend(
                model
                    .term_should_be_epic_ok
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermShouldBeEpicOkTable::WEIGHT;
                    }),
            );

            self.new_term_surjective_exempted.extend(
                model
                    .term_surjective_exempted
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermSurjectiveExemptedTable::WEIGHT;
                    }),
            );

            self.new_var_term_in_rule.extend(
                model
                    .var_term_in_rule
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarTermInRuleTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarTermInRuleTable::WEIGHT;

                        let weight2 = model
                            .rule_decl_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= VarTermInRuleTable::WEIGHT;
                    }),
            );

            self.new_term_node_loc.extend(
                model
                    .term_node_loc
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_term.extend(
                model
                    .rule_child_term
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildTermTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTermTable::WEIGHT;
                    }),
            );

            self.new_term_structure.extend(
                model
                    .term_structure
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermStructureTable::WEIGHT;
                    }),
            );

            self.new_semantic_el.extend(
                model
                    .semantic_el
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticElTable::WEIGHT;

                        let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticElTable::WEIGHT;
                    }),
            );

            self.new_wildcard_virt_ident.extend(
                model
                    .wildcard_virt_ident
                    .drain_with_element_term_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= WildcardVirtIdentTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= WildcardVirtIdentTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_term_list_node_equalities.drain(..) {
            lhs = model.term_list_node_equalities.root(lhs);
            rhs = model.term_list_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.term_list_node_weights[lhs.0 as usize];
            let rhs_weight = model.term_list_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .term_list_node_equalities
                .union_roots_into(child, root);
            model.term_list_node_all.remove(&child);
            model.term_list_node_dirty.remove(&child);

            self.new_nil_term_list_node.extend(
                model
                    .nil_term_list_node
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= NilTermListNodeTable::WEIGHT;
                    }),
            );

            self.new_cons_term_list_node.extend(
                model
                    .cons_term_list_node
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsTermListNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsTermListNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsTermListNodeTable::WEIGHT;
                    }),
            );

            self.new_app_term_node.extend(
                model
                    .app_term_node
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= AppTermNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= AppTermNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= AppTermNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_if_atom_node.extend(
                model
                    .pred_if_atom_node
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredIfAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredIfAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_then_atom_node.extend(
                model
                    .pred_then_atom_node
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredThenAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredThenAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_terms.extend(
                model
                    .var_before_terms
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeTermsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeTermsTable::WEIGHT;
                    }),
            );

            self.new_var_in_terms.extend(
                model
                    .var_in_terms
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInTermsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInTermsTable::WEIGHT;
                    }),
            );

            self.new_terms_should_be_epic_ok.extend(
                model
                    .terms_should_be_epic_ok
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermsShouldBeEpicOkTable::WEIGHT;
                    }),
            );

            self.new_terms_surjective_exempted.extend(
                model
                    .terms_surjective_exempted
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermsSurjectiveExemptedTable::WEIGHT;
                    }),
            );

            self.new_term_list_node_loc.extend(
                model
                    .term_list_node_loc
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_term_list.extend(
                model
                    .rule_child_term_list
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildTermListTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTermListTable::WEIGHT;
                    }),
            );

            self.new_term_list_len.extend(
                model
                    .term_list_len
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermListLenTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermListLenTable::WEIGHT;
                    }),
            );

            self.new_terms_structure.extend(
                model
                    .terms_structure
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermsStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermsStructureTable::WEIGHT;
                    }),
            );

            self.new_semantic_els.extend(
                model
                    .semantic_els
                    .drain_with_element_term_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SemanticElsTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticElsTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_opt_term_node_equalities.drain(..) {
            lhs = model.opt_term_node_equalities.root(lhs);
            rhs = model.opt_term_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.opt_term_node_weights[lhs.0 as usize];
            let rhs_weight = model.opt_term_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.opt_term_node_equalities.union_roots_into(child, root);
            model.opt_term_node_all.remove(&child);
            model.opt_term_node_dirty.remove(&child);

            self.new_none_term_node.extend(
                model
                    .none_term_node
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= NoneTermNodeTable::WEIGHT;
                    }),
            );

            self.new_some_term_node.extend(
                model
                    .some_term_node
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SomeTermNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SomeTermNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_then_atom_node.extend(
                model
                    .defined_then_atom_node
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight1 = model
                            .opt_term_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_opt_term.extend(
                model
                    .var_before_opt_term
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeOptTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeOptTermTable::WEIGHT;
                    }),
            );

            self.new_var_in_opt_term.extend(
                model
                    .var_in_opt_term
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInOptTermTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInOptTermTable::WEIGHT;
                    }),
            );

            self.new_opt_term_node_loc.extend(
                model
                    .opt_term_node_loc
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= OptTermNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= OptTermNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_opt_term.extend(
                model
                    .rule_child_opt_term
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildOptTermTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildOptTermTable::WEIGHT;
                    }),
            );

            self.new_opt_term_structure.extend(
                model
                    .opt_term_structure
                    .drain_with_element_opt_term_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= OptTermStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= OptTermStructureTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_if_atom_node_equalities.drain(..) {
            lhs = model.if_atom_node_equalities.root(lhs);
            rhs = model.if_atom_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.if_atom_node_weights[lhs.0 as usize];
            let rhs_weight = model.if_atom_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.if_atom_node_equalities.union_roots_into(child, root);
            model.if_atom_node_all.remove(&child);
            model.if_atom_node_dirty.remove(&child);

            self.new_equal_if_atom_node.extend(
                model
                    .equal_if_atom_node
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= EqualIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= EqualIfAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= EqualIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_if_atom_node.extend(
                model
                    .defined_if_atom_node
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DefinedIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DefinedIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_if_atom_node.extend(
                model
                    .pred_if_atom_node
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredIfAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredIfAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_var_if_atom_node.extend(
                model
                    .var_if_atom_node
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarIfAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarIfAtomNodeTable::WEIGHT;

                        let weight2 = model.ident_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= VarIfAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_if_stmt_node.extend(
                model
                    .if_stmt_node
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfStmtNodeTable::WEIGHT;

                        let weight1 = model.if_atom_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfStmtNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_if_atom.extend(
                model
                    .var_before_if_atom
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeIfAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeIfAtomTable::WEIGHT;
                    }),
            );

            self.new_var_in_if_atom.extend(
                model
                    .var_in_if_atom
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInIfAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInIfAtomTable::WEIGHT;
                    }),
            );

            self.new_if_atom_node_loc.extend(
                model
                    .if_atom_node_loc
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfAtomNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfAtomNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_if_atom.extend(
                model
                    .rule_child_if_atom
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildIfAtomTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildIfAtomTable::WEIGHT;
                    }),
            );

            self.new_if_atom_structure.extend(
                model
                    .if_atom_structure
                    .drain_with_element_if_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfAtomStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfAtomStructureTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_then_atom_node_equalities.drain(..) {
            lhs = model.then_atom_node_equalities.root(lhs);
            rhs = model.then_atom_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.then_atom_node_weights[lhs.0 as usize];
            let rhs_weight = model.then_atom_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .then_atom_node_equalities
                .union_roots_into(child, root);
            model.then_atom_node_all.remove(&child);
            model.then_atom_node_dirty.remove(&child);

            self.new_equal_then_atom_node.extend(
                model
                    .equal_then_atom_node
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= EqualThenAtomNodeTable::WEIGHT;

                        let weight1 = model.term_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= EqualThenAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= EqualThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_defined_then_atom_node.extend(
                model
                    .defined_then_atom_node
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight1 = model
                            .opt_term_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DefinedThenAtomNodeTable::WEIGHT;

                        let weight2 = model.term_node_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_pred_then_atom_node.extend(
                model
                    .pred_then_atom_node
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredThenAtomNodeTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredThenAtomNodeTable::WEIGHT;

                        let weight2 = model
                            .term_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= PredThenAtomNodeTable::WEIGHT;
                    }),
            );

            self.new_then_stmt_node.extend(
                model
                    .then_stmt_node
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ThenStmtNodeTable::WEIGHT;

                        let weight1 = model
                            .then_atom_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= ThenStmtNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_then_atom.extend(
                model
                    .var_before_then_atom
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeThenAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeThenAtomTable::WEIGHT;
                    }),
            );

            self.new_var_in_then_atom.extend(
                model
                    .var_in_then_atom
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarInThenAtomTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInThenAtomTable::WEIGHT;
                    }),
            );

            self.new_then_atom_node_loc.extend(
                model
                    .then_atom_node_loc
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ThenAtomNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ThenAtomNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_then_atom.extend(
                model
                    .rule_child_then_atom
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildThenAtomTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildThenAtomTable::WEIGHT;
                    }),
            );

            self.new_then_atom_structure.extend(
                model
                    .then_atom_structure
                    .drain_with_element_then_atom_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ThenAtomStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ThenAtomStructureTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_stmt_node_equalities.drain(..) {
            lhs = model.stmt_node_equalities.root(lhs);
            rhs = model.stmt_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.stmt_node_weights[lhs.0 as usize];
            let rhs_weight = model.stmt_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.stmt_node_equalities.union_roots_into(child, root);
            model.stmt_node_all.remove(&child);
            model.stmt_node_dirty.remove(&child);

            self.new_if_stmt_node.extend(
                model
                    .if_stmt_node
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfStmtNodeTable::WEIGHT;

                        let weight1 = model.if_atom_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfStmtNodeTable::WEIGHT;
                    }),
            );

            self.new_then_stmt_node.extend(
                model
                    .then_stmt_node
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ThenStmtNodeTable::WEIGHT;

                        let weight1 = model
                            .then_atom_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= ThenStmtNodeTable::WEIGHT;
                    }),
            );

            self.new_cons_stmt_list_node.extend(
                model
                    .cons_stmt_list_node
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsStmtListNodeTable::WEIGHT;

                        let weight1 = model.stmt_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsStmtListNodeTable::WEIGHT;

                        let weight2 = model
                            .stmt_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsStmtListNodeTable::WEIGHT;
                    }),
            );

            self.new_var_before_stmt.extend(
                model
                    .var_before_stmt
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarBeforeStmtTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeStmtTable::WEIGHT;
                    }),
            );

            self.new_var_in_stmt.extend(
                model
                    .var_in_stmt
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarInStmtTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarInStmtTable::WEIGHT;
                    }),
            );

            self.new_if_after_then.extend(
                model
                    .if_after_then
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfAfterThenTable::WEIGHT;
                    }),
            );

            self.new_stmt_node_loc.extend(
                model
                    .stmt_node_loc
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= StmtNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_stmt.extend(
                model
                    .rule_child_stmt
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildStmtTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildStmtTable::WEIGHT;
                    }),
            );

            self.new_stmt_structure.extend(
                model
                    .stmt_structure
                    .drain_with_element_stmt_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= StmtStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtStructureTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_stmt_list_node_equalities.drain(..) {
            lhs = model.stmt_list_node_equalities.root(lhs);
            rhs = model.stmt_list_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.stmt_list_node_weights[lhs.0 as usize];
            let rhs_weight = model.stmt_list_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .stmt_list_node_equalities
                .union_roots_into(child, root);
            model.stmt_list_node_all.remove(&child);
            model.stmt_list_node_dirty.remove(&child);

            self.new_nil_stmt_list_node.extend(
                model
                    .nil_stmt_list_node
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= NilStmtListNodeTable::WEIGHT;
                    }),
            );

            self.new_cons_stmt_list_node.extend(
                model
                    .cons_stmt_list_node
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsStmtListNodeTable::WEIGHT;

                        let weight1 = model.stmt_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsStmtListNodeTable::WEIGHT;

                        let weight2 = model
                            .stmt_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsStmtListNodeTable::WEIGHT;
                    }),
            );

            self.new_rule_decl.extend(
                model
                    .rule_decl
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleDeclTable::WEIGHT;

                        let weight1 = model
                            .stmt_list_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleDeclTable::WEIGHT;
                    }),
            );

            self.new_var_before_stmts.extend(
                model
                    .var_before_stmts
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= VarBeforeStmtsTable::WEIGHT;

                        let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarBeforeStmtsTable::WEIGHT;
                    }),
            );

            self.new_stmt_list_node_loc.extend(
                model
                    .stmt_list_node_loc
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= StmtListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_child_stmt_list.extend(
                model
                    .rule_child_stmt_list
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildStmtListTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildStmtListTable::WEIGHT;
                    }),
            );

            self.new_stmt_list_chain.extend(
                model
                    .stmt_list_chain
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= StmtListChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtListChainTable::WEIGHT;
                    }),
            );

            self.new_grouped_stmt_list_chain.extend(
                model
                    .grouped_stmt_list_chain
                    .drain_with_element_stmt_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= GroupedStmtListChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= GroupedStmtListChainTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_rule_decl_node_equalities.drain(..) {
            lhs = model.rule_decl_node_equalities.root(lhs);
            rhs = model.rule_decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.rule_decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.rule_decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .rule_decl_node_equalities
                .union_roots_into(child, root);
            model.rule_decl_node_all.remove(&child);
            model.rule_decl_node_dirty.remove(&child);

            self.new_rule_decl.extend(
                model
                    .rule_decl
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleDeclTable::WEIGHT;

                        let weight1 = model
                            .stmt_list_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleDeclTable::WEIGHT;
                    }),
            );

            self.new_decl_node_rule.extend(
                model
                    .decl_node_rule
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeRuleTable::WEIGHT;

                        let weight1 = model
                            .rule_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeRuleTable::WEIGHT;
                    }),
            );

            self.new_rule_child.extend(
                model
                    .rule_child
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_child_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildTable::WEIGHT;

                        let weight1 = model
                            .rule_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTable::WEIGHT;
                    }),
            );

            self.new_var_term_in_rule.extend(
                model
                    .var_term_in_rule
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= VarTermInRuleTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= VarTermInRuleTable::WEIGHT;

                        let weight2 = model
                            .rule_decl_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= VarTermInRuleTable::WEIGHT;
                    }),
            );

            self.new_rule_name.extend(
                model
                    .rule_name
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleNameTable::WEIGHT;

                        let weight1 = model.ident_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RuleNameTable::WEIGHT;
                    }),
            );

            self.new_rule_decl_node_loc.extend(
                model
                    .rule_decl_node_loc
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RuleDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_chain.extend(
                model
                    .rule_chain
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RuleChainTable::WEIGHT;
                    }),
            );

            self.new_grouped_rule_chain.extend(
                model
                    .grouped_rule_chain
                    .drain_with_element_rule_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= GroupedRuleChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= GroupedRuleChainTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_decl_node_equalities.drain(..) {
            lhs = model.decl_node_equalities.root(lhs);
            rhs = model.decl_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.decl_node_weights[lhs.0 as usize];
            let rhs_weight = model.decl_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.decl_node_equalities.union_roots_into(child, root);
            model.decl_node_all.remove(&child);
            model.decl_node_dirty.remove(&child);

            self.new_decl_node_type.extend(
                model
                    .decl_node_type
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeTypeTable::WEIGHT;

                        let weight1 = model
                            .type_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeTypeTable::WEIGHT;
                    }),
            );

            self.new_decl_node_pred.extend(
                model
                    .decl_node_pred
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodePredTable::WEIGHT;

                        let weight1 = model
                            .pred_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodePredTable::WEIGHT;
                    }),
            );

            self.new_decl_node_func.extend(
                model
                    .decl_node_func
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeFuncTable::WEIGHT;

                        let weight1 = model
                            .func_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeFuncTable::WEIGHT;
                    }),
            );

            self.new_decl_node_rule.extend(
                model
                    .decl_node_rule
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeRuleTable::WEIGHT;

                        let weight1 = model
                            .rule_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclNodeRuleTable::WEIGHT;
                    }),
            );

            self.new_cons_decl_list_node.extend(
                model
                    .cons_decl_list_node
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsDeclListNodeTable::WEIGHT;

                        let weight1 = model.decl_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsDeclListNodeTable::WEIGHT;

                        let weight2 = model
                            .decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_decl_node_loc.extend(
                model
                    .decl_node_loc
                    .drain_with_element_decl_node(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DeclNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_decl_list_node_equalities.drain(..) {
            lhs = model.decl_list_node_equalities.root(lhs);
            rhs = model.decl_list_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.decl_list_node_weights[lhs.0 as usize];
            let rhs_weight = model.decl_list_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .decl_list_node_equalities
                .union_roots_into(child, root);
            model.decl_list_node_all.remove(&child);
            model.decl_list_node_dirty.remove(&child);

            self.new_nil_decl_list_node.extend(
                model
                    .nil_decl_list_node
                    .drain_with_element_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= NilDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_cons_decl_list_node.extend(
                model
                    .cons_decl_list_node
                    .drain_with_element_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ConsDeclListNodeTable::WEIGHT;

                        let weight1 = model.decl_node_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsDeclListNodeTable::WEIGHT;

                        let weight2 = model
                            .decl_list_node_weights
                            .get_mut(t.2 .0 as usize)
                            .unwrap();
                        *weight2 -= ConsDeclListNodeTable::WEIGHT;
                    }),
            );

            self.new_decls_module_node.extend(
                model
                    .decls_module_node
                    .drain_with_element_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model.module_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclsModuleNodeTable::WEIGHT;

                        let weight1 = model
                            .decl_list_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclsModuleNodeTable::WEIGHT;
                    }),
            );

            self.new_decl_list_node_loc.extend(
                model
                    .decl_list_node_loc
                    .drain_with_element_decl_list_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= DeclListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DeclListNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_module_node_equalities.drain(..) {
            lhs = model.module_node_equalities.root(lhs);
            rhs = model.module_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.module_node_weights[lhs.0 as usize];
            let rhs_weight = model.module_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.module_node_equalities.union_roots_into(child, root);
            model.module_node_all.remove(&child);
            model.module_node_dirty.remove(&child);

            self.new_decls_module_node.extend(
                model
                    .decls_module_node
                    .drain_with_element_module_node(child)
                    .inspect(|t| {
                        let weight0 = model.module_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclsModuleNodeTable::WEIGHT;

                        let weight1 = model
                            .decl_list_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= DeclsModuleNodeTable::WEIGHT;
                    }),
            );

            self.new_module_node_loc.extend(
                model
                    .module_node_loc
                    .drain_with_element_module_node(child)
                    .inspect(|t| {
                        let weight0 = model.module_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ModuleNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ModuleNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_loc_equalities.drain(..) {
            lhs = model.loc_equalities.root(lhs);
            rhs = model.loc_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.loc_weights[lhs.0 as usize];
            let rhs_weight = model.loc_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.loc_equalities.union_roots_into(child, root);
            model.loc_all.remove(&child);
            model.loc_dirty.remove(&child);

            self.new_defined_symbol.extend(
                model
                    .defined_symbol
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DefinedSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DefinedSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedSymbolTable::WEIGHT;
                    }),
            );

            self.new_should_be_symbol.extend(
                model
                    .should_be_symbol
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ShouldBeSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ShouldBeSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ShouldBeSymbolTable::WEIGHT;
                    }),
            );

            self.new_pred_arg_num_should_match.extend(
                model
                    .pred_arg_num_should_match
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredArgNumShouldMatchTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredArgNumShouldMatchTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= PredArgNumShouldMatchTable::WEIGHT;
                    }),
            );

            self.new_func_arg_num_should_match.extend(
                model
                    .func_arg_num_should_match
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncArgNumShouldMatchTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncArgNumShouldMatchTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= FuncArgNumShouldMatchTable::WEIGHT;
                    }),
            );

            self.new_type_decl_node_loc.extend(
                model
                    .type_decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .type_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TypeDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TypeDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_node_loc.extend(
                model
                    .arg_decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_arg_decl_list_node_loc.extend(
                model
                    .arg_decl_list_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ArgDeclListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArgDeclListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_pred_decl_node_loc.extend(
                model
                    .pred_decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .pred_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= PredDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_func_decl_node_loc.extend(
                model
                    .func_decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .func_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= FuncDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_term_node_loc.extend(
                model
                    .term_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermNodeLocTable::WEIGHT;
                    }),
            );

            self.new_term_list_node_loc.extend(
                model
                    .term_list_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_opt_term_node_loc.extend(
                model
                    .opt_term_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= OptTermNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= OptTermNodeLocTable::WEIGHT;
                    }),
            );

            self.new_if_atom_node_loc.extend(
                model
                    .if_atom_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfAtomNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfAtomNodeLocTable::WEIGHT;
                    }),
            );

            self.new_then_atom_node_loc.extend(
                model
                    .then_atom_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ThenAtomNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ThenAtomNodeLocTable::WEIGHT;
                    }),
            );

            self.new_stmt_node_loc.extend(
                model
                    .stmt_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= StmtNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtNodeLocTable::WEIGHT;
                    }),
            );

            self.new_stmt_list_node_loc.extend(
                model
                    .stmt_list_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= StmtListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_rule_decl_node_loc.extend(
                model
                    .rule_decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleDeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= RuleDeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_decl_node_loc.extend(
                model
                    .decl_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.decl_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DeclNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DeclNodeLocTable::WEIGHT;
                    }),
            );

            self.new_decl_list_node_loc.extend(
                model
                    .decl_list_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model
                            .decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= DeclListNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DeclListNodeLocTable::WEIGHT;
                    }),
            );

            self.new_module_node_loc.extend(
                model
                    .module_node_loc
                    .drain_with_element_loc(child)
                    .inspect(|t| {
                        let weight0 = model.module_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ModuleNodeLocTable::WEIGHT;

                        let weight1 = model.loc_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ModuleNodeLocTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_rule_child_node_equalities.drain(..) {
            lhs = model.rule_child_node_equalities.root(lhs);
            rhs = model.rule_child_node_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.rule_child_node_weights[lhs.0 as usize];
            let rhs_weight = model.rule_child_node_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model
                .rule_child_node_equalities
                .union_roots_into(child, root);
            model.rule_child_node_all.remove(&child);
            model.rule_child_node_dirty.remove(&child);

            self.new_rule_child.extend(
                model
                    .rule_child
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_child_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildTable::WEIGHT;

                        let weight1 = model
                            .rule_decl_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTable::WEIGHT;
                    }),
            );

            self.new_rule_child_term.extend(
                model
                    .rule_child_term
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildTermTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTermTable::WEIGHT;
                    }),
            );

            self.new_rule_child_term_list.extend(
                model
                    .rule_child_term_list
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildTermListTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildTermListTable::WEIGHT;
                    }),
            );

            self.new_rule_child_opt_term.extend(
                model
                    .rule_child_opt_term
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildOptTermTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildOptTermTable::WEIGHT;
                    }),
            );

            self.new_rule_child_if_atom.extend(
                model
                    .rule_child_if_atom
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildIfAtomTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildIfAtomTable::WEIGHT;
                    }),
            );

            self.new_rule_child_then_atom.extend(
                model
                    .rule_child_then_atom
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildThenAtomTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildThenAtomTable::WEIGHT;
                    }),
            );

            self.new_rule_child_stmt.extend(
                model
                    .rule_child_stmt
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleChildStmtTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildStmtTable::WEIGHT;
                    }),
            );

            self.new_rule_child_stmt_list.extend(
                model
                    .rule_child_stmt_list
                    .drain_with_element_rule_child_node(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= RuleChildStmtListTable::WEIGHT;

                        let weight1 = model
                            .rule_child_node_weights
                            .get_mut(t.1 .0 as usize)
                            .unwrap();
                        *weight1 -= RuleChildStmtListTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_type_equalities.drain(..) {
            lhs = model.type_equalities.root(lhs);
            rhs = model.type_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.type_weights[lhs.0 as usize];
            let rhs_weight = model.type_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.type_equalities.union_roots_into(child, root);
            model.type_all.remove(&child);
            model.type_dirty.remove(&child);

            self.new_el_type
                .extend(model.el_type.drain_with_element_type(child).inspect(|t| {
                    let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= ElTypeTable::WEIGHT;

                    let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= ElTypeTable::WEIGHT;
                }));

            self.new_cons_type_list.extend(
                model
                    .cons_type_list
                    .drain_with_element_type(child)
                    .inspect(|t| {
                        let weight0 = model.type_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ConsTypeListTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsTypeListTable::WEIGHT;

                        let weight2 = model.type_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ConsTypeListTable::WEIGHT;
                    }),
            );

            self.new_semantic_type.extend(
                model
                    .semantic_type
                    .drain_with_element_type(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticTypeTable::WEIGHT;

                        let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticTypeTable::WEIGHT;
                    }),
            );

            self.new_codomain
                .extend(model.codomain.drain_with_element_type(child).inspect(|t| {
                    let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= CodomainTable::WEIGHT;

                    let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= CodomainTable::WEIGHT;
                }));
        }

        for (mut lhs, mut rhs) in self.new_type_list_equalities.drain(..) {
            lhs = model.type_list_equalities.root(lhs);
            rhs = model.type_list_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.type_list_weights[lhs.0 as usize];
            let rhs_weight = model.type_list_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.type_list_equalities.union_roots_into(child, root);
            model.type_list_all.remove(&child);
            model.type_list_dirty.remove(&child);

            self.new_el_types
                .extend(
                    model
                        .el_types
                        .drain_with_element_type_list(child)
                        .inspect(|t| {
                            let weight0 = model.el_list_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ElTypesTable::WEIGHT;

                            let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ElTypesTable::WEIGHT;
                        }),
                );

            self.new_nil_type_list.extend(
                model
                    .nil_type_list
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model.type_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= NilTypeListTable::WEIGHT;
                    }),
            );

            self.new_cons_type_list.extend(
                model
                    .cons_type_list
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model.type_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ConsTypeListTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsTypeListTable::WEIGHT;

                        let weight2 = model.type_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ConsTypeListTable::WEIGHT;
                    }),
            );

            self.new_semantic_arg_types.extend(
                model
                    .semantic_arg_types
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model
                            .arg_decl_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SemanticArgTypesTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticArgTypesTable::WEIGHT;
                    }),
            );

            self.new_arity.extend(
                model
                    .arity
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model.pred_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ArityTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ArityTable::WEIGHT;
                    }),
            );

            self.new_domain.extend(
                model
                    .domain
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DomainTable::WEIGHT;

                        let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DomainTable::WEIGHT;
                    }),
            );

            self.new_type_list_len.extend(
                model
                    .type_list_len
                    .drain_with_element_type_list(child)
                    .inspect(|t| {
                        let weight0 = model.type_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TypeListLenTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TypeListLenTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_pred_equalities.drain(..) {
            lhs = model.pred_equalities.root(lhs);
            rhs = model.pred_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.pred_weights[lhs.0 as usize];
            let rhs_weight = model.pred_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.pred_equalities.union_roots_into(child, root);
            model.pred_all.remove(&child);
            model.pred_dirty.remove(&child);

            self.new_pred_app
                .extend(model.pred_app.drain_with_element_pred(child).inspect(|t| {
                    let weight0 = model.pred_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= PredAppTable::WEIGHT;

                    let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= PredAppTable::WEIGHT;
                }));

            self.new_pred_tuple_in_img.extend(
                model
                    .pred_tuple_in_img
                    .drain_with_element_pred(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredTupleInImgTable::WEIGHT;

                        let weight1 = model.pred_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredTupleInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= PredTupleInImgTable::WEIGHT;
                    }),
            );

            self.new_semantic_pred.extend(
                model
                    .semantic_pred
                    .drain_with_element_pred(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticPredTable::WEIGHT;

                        let weight1 = model.pred_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticPredTable::WEIGHT;
                    }),
            );

            self.new_arity
                .extend(model.arity.drain_with_element_pred(child).inspect(|t| {
                    let weight0 = model.pred_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= ArityTable::WEIGHT;

                    let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= ArityTable::WEIGHT;
                }));
        }

        for (mut lhs, mut rhs) in self.new_func_equalities.drain(..) {
            lhs = model.func_equalities.root(lhs);
            rhs = model.func_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.func_weights[lhs.0 as usize];
            let rhs_weight = model.func_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.func_equalities.union_roots_into(child, root);
            model.func_all.remove(&child);
            model.func_dirty.remove(&child);

            self.new_func_app_in_img.extend(
                model
                    .func_app_in_img
                    .drain_with_element_func(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncAppInImgTable::WEIGHT;

                        let weight1 = model.func_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncAppInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= FuncAppInImgTable::WEIGHT;
                    }),
            );

            self.new_semantic_func.extend(
                model
                    .semantic_func
                    .drain_with_element_func(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= SemanticFuncTable::WEIGHT;

                        let weight1 = model.func_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticFuncTable::WEIGHT;
                    }),
            );

            self.new_domain
                .extend(model.domain.drain_with_element_func(child).inspect(|t| {
                    let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= DomainTable::WEIGHT;

                    let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= DomainTable::WEIGHT;
                }));

            self.new_codomain
                .extend(model.codomain.drain_with_element_func(child).inspect(|t| {
                    let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= CodomainTable::WEIGHT;

                    let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= CodomainTable::WEIGHT;
                }));

            self.new_func_app
                .extend(model.func_app.drain_with_element_func(child).inspect(|t| {
                    let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= FuncAppTable::WEIGHT;

                    let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= FuncAppTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= FuncAppTable::WEIGHT;
                }));
        }

        for (mut lhs, mut rhs) in self.new_structure_equalities.drain(..) {
            lhs = model.structure_equalities.root(lhs);
            rhs = model.structure_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.structure_weights[lhs.0 as usize];
            let rhs_weight = model.structure_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.structure_equalities.union_roots_into(child, root);
            model.structure_all.remove(&child);
            model.structure_dirty.remove(&child);

            self.new_nil_el_list.extend(
                model
                    .nil_el_list
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= NilElListTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= NilElListTable::WEIGHT;
                    }),
            );

            self.new_var
                .extend(model.var.drain_with_element_structure(child).inspect(|t| {
                    let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= VarTable::WEIGHT;

                    let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= VarTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= VarTable::WEIGHT;
                }));

            self.new_el_structure.extend(
                model
                    .el_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ElStructureTable::WEIGHT;
                    }),
            );

            self.new_els_structure.extend(
                model
                    .els_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.el_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElsStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ElsStructureTable::WEIGHT;
                    }),
            );

            self.new_dom
                .extend(model.dom.drain_with_element_structure(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= DomTable::WEIGHT;

                    let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= DomTable::WEIGHT;
                }));

            self.new_cod
                .extend(model.cod.drain_with_element_structure(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= CodTable::WEIGHT;

                    let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= CodTable::WEIGHT;
                }));

            self.new_initial_structure.extend(
                model
                    .initial_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= InitialStructureTable::WEIGHT;
                    }),
            );

            self.new_initiality_morphism.extend(
                model
                    .initiality_morphism
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= InitialityMorphismTable::WEIGHT;

                        let weight1 = model.morphism_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= InitialityMorphismTable::WEIGHT;
                    }),
            );

            self.new_chain_head_structure.extend(
                model
                    .chain_head_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ChainHeadStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ChainHeadStructureTable::WEIGHT;
                    }),
            );

            self.new_stmt_structure.extend(
                model
                    .stmt_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.stmt_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= StmtStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtStructureTable::WEIGHT;
                    }),
            );

            self.new_if_atom_structure.extend(
                model
                    .if_atom_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.if_atom_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= IfAtomStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= IfAtomStructureTable::WEIGHT;
                    }),
            );

            self.new_then_atom_structure.extend(
                model
                    .then_atom_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model
                            .then_atom_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= ThenAtomStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ThenAtomStructureTable::WEIGHT;
                    }),
            );

            self.new_term_structure.extend(
                model
                    .term_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TermStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermStructureTable::WEIGHT;
                    }),
            );

            self.new_terms_structure.extend(
                model
                    .terms_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermsStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermsStructureTable::WEIGHT;
                    }),
            );

            self.new_opt_term_structure.extend(
                model
                    .opt_term_structure
                    .drain_with_element_structure(child)
                    .inspect(|t| {
                        let weight0 = model
                            .opt_term_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= OptTermStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= OptTermStructureTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_el_equalities.drain(..) {
            lhs = model.el_equalities.root(lhs);
            rhs = model.el_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.el_weights[lhs.0 as usize];
            let rhs_weight = model.el_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.el_equalities.union_roots_into(child, root);
            model.el_all.remove(&child);
            model.el_dirty.remove(&child);

            self.new_el_type
                .extend(model.el_type.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= ElTypeTable::WEIGHT;

                    let weight1 = model.type_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= ElTypeTable::WEIGHT;
                }));

            self.new_constrained_el.extend(
                model
                    .constrained_el
                    .drain_with_element_el(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ConstrainedElTable::WEIGHT;
                    }),
            );

            self.new_in_ker
                .extend(model.in_ker.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= InKerTable::WEIGHT;

                    let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= InKerTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= InKerTable::WEIGHT;
                }));

            self.new_el_in_img
                .extend(model.el_in_img.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= ElInImgTable::WEIGHT;

                    let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= ElInImgTable::WEIGHT;
                }));

            self.new_el_surjective_exempted.extend(
                model
                    .el_surjective_exempted
                    .drain_with_element_el(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElSurjectiveExemptedTable::WEIGHT;
                    }),
            );

            self.new_el_should_be_surjective_ok.extend(
                model
                    .el_should_be_surjective_ok
                    .drain_with_element_el(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElShouldBeSurjectiveOkTable::WEIGHT;
                    }),
            );

            self.new_el_is_surjective_ok.extend(
                model
                    .el_is_surjective_ok
                    .drain_with_element_el(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElIsSurjectiveOkTable::WEIGHT;
                    }),
            );

            self.new_cons_el_list
                .extend(
                    model
                        .cons_el_list
                        .drain_with_element_el(child)
                        .inspect(|t| {
                            let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ConsElListTable::WEIGHT;

                            let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ConsElListTable::WEIGHT;

                            let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                            *weight2 -= ConsElListTable::WEIGHT;
                        }),
                );

            self.new_func_app
                .extend(model.func_app.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= FuncAppTable::WEIGHT;

                    let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= FuncAppTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= FuncAppTable::WEIGHT;
                }));

            self.new_var
                .extend(model.var.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= VarTable::WEIGHT;

                    let weight1 = model.virt_ident_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= VarTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= VarTable::WEIGHT;
                }));

            self.new_el_structure
                .extend(
                    model
                        .el_structure
                        .drain_with_element_el(child)
                        .inspect(|t| {
                            let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ElStructureTable::WEIGHT;

                            let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ElStructureTable::WEIGHT;
                        }),
                );

            self.new_map_el
                .extend(model.map_el.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= MapElTable::WEIGHT;

                    let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= MapElTable::WEIGHT;

                    let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                    *weight2 -= MapElTable::WEIGHT;
                }));

            self.new_semantic_el
                .extend(model.semantic_el.drain_with_element_el(child).inspect(|t| {
                    let weight0 = model.term_node_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= SemanticElTable::WEIGHT;

                    let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= SemanticElTable::WEIGHT;
                }));
        }

        for (mut lhs, mut rhs) in self.new_el_list_equalities.drain(..) {
            lhs = model.el_list_equalities.root(lhs);
            rhs = model.el_list_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.el_list_weights[lhs.0 as usize];
            let rhs_weight = model.el_list_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.el_list_equalities.union_roots_into(child, root);
            model.el_list_all.remove(&child);
            model.el_list_dirty.remove(&child);

            self.new_pred_app
                .extend(
                    model
                        .pred_app
                        .drain_with_element_el_list(child)
                        .inspect(|t| {
                            let weight0 = model.pred_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= PredAppTable::WEIGHT;

                            let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= PredAppTable::WEIGHT;
                        }),
                );

            self.new_el_types
                .extend(
                    model
                        .el_types
                        .drain_with_element_el_list(child)
                        .inspect(|t| {
                            let weight0 = model.el_list_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ElTypesTable::WEIGHT;

                            let weight1 = model.type_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ElTypesTable::WEIGHT;
                        }),
                );

            self.new_constrained_els.extend(
                model
                    .constrained_els
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.el_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ConstrainedElsTable::WEIGHT;
                    }),
            );

            self.new_pred_tuple_in_img.extend(
                model
                    .pred_tuple_in_img
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredTupleInImgTable::WEIGHT;

                        let weight1 = model.pred_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredTupleInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= PredTupleInImgTable::WEIGHT;
                    }),
            );

            self.new_func_app_in_img.extend(
                model
                    .func_app_in_img
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncAppInImgTable::WEIGHT;

                        let weight1 = model.func_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncAppInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= FuncAppInImgTable::WEIGHT;
                    }),
            );

            self.new_nil_el_list.extend(
                model
                    .nil_el_list
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= NilElListTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= NilElListTable::WEIGHT;
                    }),
            );

            self.new_cons_el_list.extend(
                model
                    .cons_el_list
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.el_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ConsElListTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ConsElListTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ConsElListTable::WEIGHT;
                    }),
            );

            self.new_func_app
                .extend(
                    model
                        .func_app
                        .drain_with_element_el_list(child)
                        .inspect(|t| {
                            let weight0 = model.func_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= FuncAppTable::WEIGHT;

                            let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= FuncAppTable::WEIGHT;

                            let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                            *weight2 -= FuncAppTable::WEIGHT;
                        }),
                );

            self.new_els_structure.extend(
                model
                    .els_structure
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.el_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ElsStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ElsStructureTable::WEIGHT;
                    }),
            );

            self.new_map_els.extend(
                model
                    .map_els
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= MapElsTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= MapElsTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= MapElsTable::WEIGHT;
                    }),
            );

            self.new_semantic_els.extend(
                model
                    .semantic_els
                    .drain_with_element_el_list(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= SemanticElsTable::WEIGHT;

                        let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= SemanticElsTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_morphism_equalities.drain(..) {
            lhs = model.morphism_equalities.root(lhs);
            rhs = model.morphism_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.morphism_weights[lhs.0 as usize];
            let rhs_weight = model.morphism_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.morphism_equalities.union_roots_into(child, root);
            model.morphism_all.remove(&child);
            model.morphism_dirty.remove(&child);

            self.new_in_ker.extend(
                model
                    .in_ker
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= InKerTable::WEIGHT;

                        let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= InKerTable::WEIGHT;

                        let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= InKerTable::WEIGHT;
                    }),
            );

            self.new_el_in_img
                .extend(
                    model
                        .el_in_img
                        .drain_with_element_morphism(child)
                        .inspect(|t| {
                            let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ElInImgTable::WEIGHT;

                            let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ElInImgTable::WEIGHT;
                        }),
                );

            self.new_pred_tuple_in_img.extend(
                model
                    .pred_tuple_in_img
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredTupleInImgTable::WEIGHT;

                        let weight1 = model.pred_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredTupleInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= PredTupleInImgTable::WEIGHT;
                    }),
            );

            self.new_func_app_in_img.extend(
                model
                    .func_app_in_img
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncAppInImgTable::WEIGHT;

                        let weight1 = model.func_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncAppInImgTable::WEIGHT;

                        let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= FuncAppInImgTable::WEIGHT;
                    }),
            );

            self.new_should_be_surjective.extend(
                model
                    .should_be_surjective
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ShouldBeSurjectiveTable::WEIGHT;
                    }),
            );

            self.new_dom
                .extend(model.dom.drain_with_element_morphism(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= DomTable::WEIGHT;

                    let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= DomTable::WEIGHT;
                }));

            self.new_cod
                .extend(model.cod.drain_with_element_morphism(child).inspect(|t| {
                    let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= CodTable::WEIGHT;

                    let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= CodTable::WEIGHT;
                }));

            self.new_map_el.extend(
                model
                    .map_el
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= MapElTable::WEIGHT;

                        let weight1 = model.el_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= MapElTable::WEIGHT;

                        let weight2 = model.el_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= MapElTable::WEIGHT;
                    }),
            );

            self.new_map_els
                .extend(
                    model
                        .map_els
                        .drain_with_element_morphism(child)
                        .inspect(|t| {
                            let weight0 = model.morphism_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= MapElsTable::WEIGHT;

                            let weight1 = model.el_list_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= MapElsTable::WEIGHT;

                            let weight2 = model.el_list_weights.get_mut(t.2 .0 as usize).unwrap();
                            *weight2 -= MapElsTable::WEIGHT;
                        }),
                );

            self.new_initiality_morphism.extend(
                model
                    .initiality_morphism
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.structure_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= InitialityMorphismTable::WEIGHT;

                        let weight1 = model.morphism_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= InitialityMorphismTable::WEIGHT;
                    }),
            );

            self.new_chain_head_transition.extend(
                model
                    .chain_head_transition
                    .drain_with_element_morphism(child)
                    .inspect(|t| {
                        let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ChainHeadTransitionTable::WEIGHT;

                        let weight1 = model.morphism_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ChainHeadTransitionTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_chain_equalities.drain(..) {
            lhs = model.chain_equalities.root(lhs);
            rhs = model.chain_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.chain_weights[lhs.0 as usize];
            let rhs_weight = model.chain_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.chain_equalities.union_roots_into(child, root);
            model.chain_all.remove(&child);
            model.chain_dirty.remove(&child);

            self.new_nil_chain
                .extend(
                    model
                        .nil_chain
                        .drain_with_element_chain(child)
                        .inspect(|t| {
                            let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= NilChainTable::WEIGHT;
                        }),
                );

            self.new_chain_tail
                .extend(
                    model
                        .chain_tail
                        .drain_with_element_chain(child)
                        .inspect(|t| {
                            let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                            *weight0 -= ChainTailTable::WEIGHT;

                            let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= ChainTailTable::WEIGHT;
                        }),
                );

            self.new_chain_head_structure.extend(
                model
                    .chain_head_structure
                    .drain_with_element_chain(child)
                    .inspect(|t| {
                        let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ChainHeadStructureTable::WEIGHT;

                        let weight1 = model.structure_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ChainHeadStructureTable::WEIGHT;
                    }),
            );

            self.new_chain_head_transition.extend(
                model
                    .chain_head_transition
                    .drain_with_element_chain(child)
                    .inspect(|t| {
                        let weight0 = model.chain_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ChainHeadTransitionTable::WEIGHT;

                        let weight1 = model.morphism_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ChainHeadTransitionTable::WEIGHT;
                    }),
            );

            self.new_rule_chain
                .extend(
                    model
                        .rule_chain
                        .drain_with_element_chain(child)
                        .inspect(|t| {
                            let weight0 = model
                                .rule_decl_node_weights
                                .get_mut(t.0 .0 as usize)
                                .unwrap();
                            *weight0 -= RuleChainTable::WEIGHT;

                            let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                            *weight1 -= RuleChainTable::WEIGHT;
                        }),
                );

            self.new_stmt_list_chain.extend(
                model
                    .stmt_list_chain
                    .drain_with_element_chain(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= StmtListChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= StmtListChainTable::WEIGHT;
                    }),
            );

            self.new_grouped_rule_chain.extend(
                model
                    .grouped_rule_chain
                    .drain_with_element_chain(child)
                    .inspect(|t| {
                        let weight0 = model
                            .rule_decl_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= GroupedRuleChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= GroupedRuleChainTable::WEIGHT;
                    }),
            );

            self.new_grouped_stmt_list_chain.extend(
                model
                    .grouped_stmt_list_chain
                    .drain_with_element_chain(child)
                    .inspect(|t| {
                        let weight0 = model
                            .stmt_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= GroupedStmtListChainTable::WEIGHT;

                        let weight1 = model.chain_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= GroupedStmtListChainTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_symbol_kind_equalities.drain(..) {
            lhs = model.symbol_kind_equalities.root(lhs);
            rhs = model.symbol_kind_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.symbol_kind_weights[lhs.0 as usize];
            let rhs_weight = model.symbol_kind_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.symbol_kind_equalities.union_roots_into(child, root);
            model.symbol_kind_all.remove(&child);
            model.symbol_kind_dirty.remove(&child);

            self.new_defined_symbol.extend(
                model
                    .defined_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= DefinedSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= DefinedSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= DefinedSymbolTable::WEIGHT;
                    }),
            );

            self.new_should_be_symbol.extend(
                model
                    .should_be_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.ident_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= ShouldBeSymbolTable::WEIGHT;

                        let weight1 = model.symbol_kind_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= ShouldBeSymbolTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= ShouldBeSymbolTable::WEIGHT;
                    }),
            );

            self.new_type_symbol.extend(
                model
                    .type_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.symbol_kind_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TypeSymbolTable::WEIGHT;
                    }),
            );

            self.new_pred_symbol.extend(
                model
                    .pred_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.symbol_kind_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredSymbolTable::WEIGHT;
                    }),
            );

            self.new_func_symbol.extend(
                model
                    .func_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.symbol_kind_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncSymbolTable::WEIGHT;
                    }),
            );

            self.new_rule_symbol.extend(
                model
                    .rule_symbol
                    .drain_with_element_symbol_kind(child)
                    .inspect(|t| {
                        let weight0 = model.symbol_kind_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= RuleSymbolTable::WEIGHT;
                    }),
            );
        }

        for (mut lhs, mut rhs) in self.new_nat_equalities.drain(..) {
            lhs = model.nat_equalities.root(lhs);
            rhs = model.nat_equalities.root(rhs);
            if lhs == rhs {
                continue;
            }

            let lhs_weight = model.nat_weights[lhs.0 as usize];
            let rhs_weight = model.nat_weights[rhs.0 as usize];
            let (root, child) = if lhs_weight >= rhs_weight {
                (lhs, rhs)
            } else {
                (rhs, lhs)
            };

            model.nat_equalities.union_roots_into(child, root);
            model.nat_all.remove(&child);
            model.nat_dirty.remove(&child);

            self.new_pred_arg_num_should_match.extend(
                model
                    .pred_arg_num_should_match
                    .drain_with_element_nat(child)
                    .inspect(|t| {
                        let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= PredArgNumShouldMatchTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= PredArgNumShouldMatchTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= PredArgNumShouldMatchTable::WEIGHT;
                    }),
            );

            self.new_func_arg_num_should_match.extend(
                model
                    .func_arg_num_should_match
                    .drain_with_element_nat(child)
                    .inspect(|t| {
                        let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= FuncArgNumShouldMatchTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= FuncArgNumShouldMatchTable::WEIGHT;

                        let weight2 = model.loc_weights.get_mut(t.2 .0 as usize).unwrap();
                        *weight2 -= FuncArgNumShouldMatchTable::WEIGHT;
                    }),
            );

            self.new_zero
                .extend(model.zero.drain_with_element_nat(child).inspect(|t| {
                    let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= ZeroTable::WEIGHT;
                }));

            self.new_succ
                .extend(model.succ.drain_with_element_nat(child).inspect(|t| {
                    let weight0 = model.nat_weights.get_mut(t.0 .0 as usize).unwrap();
                    *weight0 -= SuccTable::WEIGHT;

                    let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                    *weight1 -= SuccTable::WEIGHT;
                }));

            self.new_type_list_len.extend(
                model
                    .type_list_len
                    .drain_with_element_nat(child)
                    .inspect(|t| {
                        let weight0 = model.type_list_weights.get_mut(t.0 .0 as usize).unwrap();
                        *weight0 -= TypeListLenTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TypeListLenTable::WEIGHT;
                    }),
            );

            self.new_term_list_len.extend(
                model
                    .term_list_len
                    .drain_with_element_nat(child)
                    .inspect(|t| {
                        let weight0 = model
                            .term_list_node_weights
                            .get_mut(t.0 .0 as usize)
                            .unwrap();
                        *weight0 -= TermListLenTable::WEIGHT;

                        let weight1 = model.nat_weights.get_mut(t.1 .0 as usize).unwrap();
                        *weight1 -= TermListLenTable::WEIGHT;
                    }),
            );
        }
    }
    fn apply_tuples(&mut self, model: &mut Model) {
        #[allow(unused_mut)]
        for mut t in self.new_absurd.drain(..) {
            if model.absurd.insert(t) {}
        }

        #[allow(unused_mut)]
        for mut t in self.new_type_decl.drain(..) {
            t.0 = model.type_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            if model.type_decl.insert(t) {
                model.type_decl_node_weights[t.0 .0 as usize] += TypeDeclTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += TypeDeclTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_arg_decl_node_name.drain(..) {
            t.0 = model.arg_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            if model.arg_decl_node_name.insert(t) {
                model.arg_decl_node_weights[t.0 .0 as usize] += ArgDeclNodeNameTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += ArgDeclNodeNameTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_arg_decl_node_type.drain(..) {
            t.0 = model.arg_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            if model.arg_decl_node_type.insert(t) {
                model.arg_decl_node_weights[t.0 .0 as usize] += ArgDeclNodeTypeTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += ArgDeclNodeTypeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_arg_decl_list_node.drain(..) {
            t.0 = model.arg_decl_list_node_equalities.root(t.0);
            if model.nil_arg_decl_list_node.insert(t) {
                model.arg_decl_list_node_weights[t.0 .0 as usize] +=
                    NilArgDeclListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_arg_decl_list_node.drain(..) {
            t.0 = model.arg_decl_list_node_equalities.root(t.0);
            t.1 = model.arg_decl_node_equalities.root(t.1);
            t.2 = model.arg_decl_list_node_equalities.root(t.2);
            if model.cons_arg_decl_list_node.insert(t) {
                model.arg_decl_list_node_weights[t.0 .0 as usize] +=
                    ConsArgDeclListNodeTable::WEIGHT;
                model.arg_decl_node_weights[t.1 .0 as usize] += ConsArgDeclListNodeTable::WEIGHT;
                model.arg_decl_list_node_weights[t.2 .0 as usize] +=
                    ConsArgDeclListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_decl.drain(..) {
            t.0 = model.pred_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.arg_decl_list_node_equalities.root(t.2);
            if model.pred_decl.insert(t) {
                model.pred_decl_node_weights[t.0 .0 as usize] += PredDeclTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += PredDeclTable::WEIGHT;
                model.arg_decl_list_node_weights[t.2 .0 as usize] += PredDeclTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_decl.drain(..) {
            t.0 = model.func_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.arg_decl_list_node_equalities.root(t.2);
            t.3 = model.ident_equalities.root(t.3);
            if model.func_decl.insert(t) {
                model.func_decl_node_weights[t.0 .0 as usize] += FuncDeclTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += FuncDeclTable::WEIGHT;
                model.arg_decl_list_node_weights[t.2 .0 as usize] += FuncDeclTable::WEIGHT;
                model.ident_weights[t.3 .0 as usize] += FuncDeclTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_term_list_node.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            if model.nil_term_list_node.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += NilTermListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_term_list_node.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            t.2 = model.term_list_node_equalities.root(t.2);
            if model.cons_term_list_node.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += ConsTermListNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += ConsTermListNodeTable::WEIGHT;
                model.term_list_node_weights[t.2 .0 as usize] += ConsTermListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_none_term_node.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            if model.none_term_node.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += NoneTermNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_some_term_node.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            if model.some_term_node.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += SomeTermNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += SomeTermNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_term_node.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            if model.var_term_node.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += VarTermNodeTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += VarTermNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_wildcard_term_node.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            if model.wildcard_term_node.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += WildcardTermNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_app_term_node.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.term_list_node_equalities.root(t.2);
            if model.app_term_node.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += AppTermNodeTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += AppTermNodeTable::WEIGHT;
                model.term_list_node_weights[t.2 .0 as usize] += AppTermNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_equal_if_atom_node.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            t.2 = model.term_node_equalities.root(t.2);
            if model.equal_if_atom_node.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += EqualIfAtomNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += EqualIfAtomNodeTable::WEIGHT;
                model.term_node_weights[t.2 .0 as usize] += EqualIfAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_defined_if_atom_node.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            if model.defined_if_atom_node.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += DefinedIfAtomNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += DefinedIfAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_if_atom_node.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.term_list_node_equalities.root(t.2);
            if model.pred_if_atom_node.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += PredIfAtomNodeTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += PredIfAtomNodeTable::WEIGHT;
                model.term_list_node_weights[t.2 .0 as usize] += PredIfAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_if_atom_node.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            t.2 = model.ident_equalities.root(t.2);
            if model.var_if_atom_node.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += VarIfAtomNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += VarIfAtomNodeTable::WEIGHT;
                model.ident_weights[t.2 .0 as usize] += VarIfAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_equal_then_atom_node.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.term_node_equalities.root(t.1);
            t.2 = model.term_node_equalities.root(t.2);
            if model.equal_then_atom_node.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += EqualThenAtomNodeTable::WEIGHT;
                model.term_node_weights[t.1 .0 as usize] += EqualThenAtomNodeTable::WEIGHT;
                model.term_node_weights[t.2 .0 as usize] += EqualThenAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_defined_then_atom_node.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.opt_term_node_equalities.root(t.1);
            t.2 = model.term_node_equalities.root(t.2);
            if model.defined_then_atom_node.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += DefinedThenAtomNodeTable::WEIGHT;
                model.opt_term_node_weights[t.1 .0 as usize] += DefinedThenAtomNodeTable::WEIGHT;
                model.term_node_weights[t.2 .0 as usize] += DefinedThenAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_then_atom_node.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.term_list_node_equalities.root(t.2);
            if model.pred_then_atom_node.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += PredThenAtomNodeTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += PredThenAtomNodeTable::WEIGHT;
                model.term_list_node_weights[t.2 .0 as usize] += PredThenAtomNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_if_stmt_node.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.if_atom_node_equalities.root(t.1);
            if model.if_stmt_node.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += IfStmtNodeTable::WEIGHT;
                model.if_atom_node_weights[t.1 .0 as usize] += IfStmtNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_then_stmt_node.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.then_atom_node_equalities.root(t.1);
            if model.then_stmt_node.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += ThenStmtNodeTable::WEIGHT;
                model.then_atom_node_weights[t.1 .0 as usize] += ThenStmtNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_stmt_list_node.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            if model.nil_stmt_list_node.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += NilStmtListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_stmt_list_node.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.stmt_node_equalities.root(t.1);
            t.2 = model.stmt_list_node_equalities.root(t.2);
            if model.cons_stmt_list_node.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += ConsStmtListNodeTable::WEIGHT;
                model.stmt_node_weights[t.1 .0 as usize] += ConsStmtListNodeTable::WEIGHT;
                model.stmt_list_node_weights[t.2 .0 as usize] += ConsStmtListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_decl.drain(..) {
            t.0 = model.rule_decl_node_equalities.root(t.0);
            t.1 = model.stmt_list_node_equalities.root(t.1);
            if model.rule_decl.insert(t) {
                model.rule_decl_node_weights[t.0 .0 as usize] += RuleDeclTable::WEIGHT;
                model.stmt_list_node_weights[t.1 .0 as usize] += RuleDeclTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_node_type.drain(..) {
            t.0 = model.decl_node_equalities.root(t.0);
            t.1 = model.type_decl_node_equalities.root(t.1);
            if model.decl_node_type.insert(t) {
                model.decl_node_weights[t.0 .0 as usize] += DeclNodeTypeTable::WEIGHT;
                model.type_decl_node_weights[t.1 .0 as usize] += DeclNodeTypeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_node_pred.drain(..) {
            t.0 = model.decl_node_equalities.root(t.0);
            t.1 = model.pred_decl_node_equalities.root(t.1);
            if model.decl_node_pred.insert(t) {
                model.decl_node_weights[t.0 .0 as usize] += DeclNodePredTable::WEIGHT;
                model.pred_decl_node_weights[t.1 .0 as usize] += DeclNodePredTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_node_func.drain(..) {
            t.0 = model.decl_node_equalities.root(t.0);
            t.1 = model.func_decl_node_equalities.root(t.1);
            if model.decl_node_func.insert(t) {
                model.decl_node_weights[t.0 .0 as usize] += DeclNodeFuncTable::WEIGHT;
                model.func_decl_node_weights[t.1 .0 as usize] += DeclNodeFuncTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_node_rule.drain(..) {
            t.0 = model.decl_node_equalities.root(t.0);
            t.1 = model.rule_decl_node_equalities.root(t.1);
            if model.decl_node_rule.insert(t) {
                model.decl_node_weights[t.0 .0 as usize] += DeclNodeRuleTable::WEIGHT;
                model.rule_decl_node_weights[t.1 .0 as usize] += DeclNodeRuleTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_decl_list_node.drain(..) {
            t.0 = model.decl_list_node_equalities.root(t.0);
            if model.nil_decl_list_node.insert(t) {
                model.decl_list_node_weights[t.0 .0 as usize] += NilDeclListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_decl_list_node.drain(..) {
            t.0 = model.decl_list_node_equalities.root(t.0);
            t.1 = model.decl_node_equalities.root(t.1);
            t.2 = model.decl_list_node_equalities.root(t.2);
            if model.cons_decl_list_node.insert(t) {
                model.decl_list_node_weights[t.0 .0 as usize] += ConsDeclListNodeTable::WEIGHT;
                model.decl_node_weights[t.1 .0 as usize] += ConsDeclListNodeTable::WEIGHT;
                model.decl_list_node_weights[t.2 .0 as usize] += ConsDeclListNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decls_module_node.drain(..) {
            t.0 = model.module_node_equalities.root(t.0);
            t.1 = model.decl_list_node_equalities.root(t.1);
            if model.decls_module_node.insert(t) {
                model.module_node_weights[t.0 .0 as usize] += DeclsModuleNodeTable::WEIGHT;
                model.decl_list_node_weights[t.1 .0 as usize] += DeclsModuleNodeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child.drain(..) {
            t.0 = model.rule_child_node_equalities.root(t.0);
            t.1 = model.rule_decl_node_equalities.root(t.1);
            if model.rule_child.insert(t) {
                model.rule_child_node_weights[t.0 .0 as usize] += RuleChildTable::WEIGHT;
                model.rule_decl_node_weights[t.1 .0 as usize] += RuleChildTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_app.drain(..) {
            t.0 = model.pred_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            if model.pred_app.insert(t) {
                model.pred_weights[t.0 .0 as usize] += PredAppTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += PredAppTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_type.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            t.1 = model.type_equalities.root(t.1);
            if model.el_type.insert(t) {
                model.el_weights[t.0 .0 as usize] += ElTypeTable::WEIGHT;
                model.type_weights[t.1 .0 as usize] += ElTypeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_types.drain(..) {
            t.0 = model.el_list_equalities.root(t.0);
            t.1 = model.type_list_equalities.root(t.1);
            if model.el_types.insert(t) {
                model.el_list_weights[t.0 .0 as usize] += ElTypesTable::WEIGHT;
                model.type_list_weights[t.1 .0 as usize] += ElTypesTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_constrained_el.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            if model.constrained_el.insert(t) {
                model.el_weights[t.0 .0 as usize] += ConstrainedElTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_constrained_els.drain(..) {
            t.0 = model.el_list_equalities.root(t.0);
            if model.constrained_els.insert(t) {
                model.el_list_weights[t.0 .0 as usize] += ConstrainedElsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_in_ker.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.el_equalities.root(t.1);
            t.2 = model.el_equalities.root(t.2);
            if model.in_ker.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += InKerTable::WEIGHT;
                model.el_weights[t.1 .0 as usize] += InKerTable::WEIGHT;
                model.el_weights[t.2 .0 as usize] += InKerTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_in_img.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.el_equalities.root(t.1);
            if model.el_in_img.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += ElInImgTable::WEIGHT;
                model.el_weights[t.1 .0 as usize] += ElInImgTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_tuple_in_img.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.pred_equalities.root(t.1);
            t.2 = model.el_list_equalities.root(t.2);
            if model.pred_tuple_in_img.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += PredTupleInImgTable::WEIGHT;
                model.pred_weights[t.1 .0 as usize] += PredTupleInImgTable::WEIGHT;
                model.el_list_weights[t.2 .0 as usize] += PredTupleInImgTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_app_in_img.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.func_equalities.root(t.1);
            t.2 = model.el_list_equalities.root(t.2);
            if model.func_app_in_img.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += FuncAppInImgTable::WEIGHT;
                model.func_weights[t.1 .0 as usize] += FuncAppInImgTable::WEIGHT;
                model.el_list_weights[t.2 .0 as usize] += FuncAppInImgTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_defined_symbol.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.symbol_kind_equalities.root(t.1);
            t.2 = model.loc_equalities.root(t.2);
            if model.defined_symbol.insert(t) {
                model.ident_weights[t.0 .0 as usize] += DefinedSymbolTable::WEIGHT;
                model.symbol_kind_weights[t.1 .0 as usize] += DefinedSymbolTable::WEIGHT;
                model.loc_weights[t.2 .0 as usize] += DefinedSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_should_be_symbol.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.symbol_kind_equalities.root(t.1);
            t.2 = model.loc_equalities.root(t.2);
            if model.should_be_symbol.insert(t) {
                model.ident_weights[t.0 .0 as usize] += ShouldBeSymbolTable::WEIGHT;
                model.symbol_kind_weights[t.1 .0 as usize] += ShouldBeSymbolTable::WEIGHT;
                model.loc_weights[t.2 .0 as usize] += ShouldBeSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_arg_num_should_match.drain(..) {
            t.0 = model.nat_equalities.root(t.0);
            t.1 = model.nat_equalities.root(t.1);
            t.2 = model.loc_equalities.root(t.2);
            if model.pred_arg_num_should_match.insert(t) {
                model.nat_weights[t.0 .0 as usize] += PredArgNumShouldMatchTable::WEIGHT;
                model.nat_weights[t.1 .0 as usize] += PredArgNumShouldMatchTable::WEIGHT;
                model.loc_weights[t.2 .0 as usize] += PredArgNumShouldMatchTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_arg_num_should_match.drain(..) {
            t.0 = model.nat_equalities.root(t.0);
            t.1 = model.nat_equalities.root(t.1);
            t.2 = model.loc_equalities.root(t.2);
            if model.func_arg_num_should_match.insert(t) {
                model.nat_weights[t.0 .0 as usize] += FuncArgNumShouldMatchTable::WEIGHT;
                model.nat_weights[t.1 .0 as usize] += FuncArgNumShouldMatchTable::WEIGHT;
                model.loc_weights[t.2 .0 as usize] += FuncArgNumShouldMatchTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_term.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_term.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += VarBeforeTermTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_terms.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_terms.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += VarBeforeTermsTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeTermsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_opt_term.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_opt_term.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += VarBeforeOptTermTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeOptTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_if_atom.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_if_atom.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += VarBeforeIfAtomTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeIfAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_then_atom.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_then_atom.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += VarBeforeThenAtomTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeThenAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_stmt.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_stmt.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += VarBeforeStmtTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeStmtTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_before_stmts.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_before_stmts.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += VarBeforeStmtsTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarBeforeStmtsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_term.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_term.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += VarInTermTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_terms.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_terms.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += VarInTermsTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInTermsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_opt_term.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_opt_term.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += VarInOptTermTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInOptTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_if_atom.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_if_atom.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += VarInIfAtomTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInIfAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_then_atom.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_then_atom.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += VarInThenAtomTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInThenAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_in_stmt.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.var_in_stmt.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += VarInStmtTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarInStmtTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_should_be_epic_ok.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            if model.term_should_be_epic_ok.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += TermShouldBeEpicOkTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_terms_should_be_epic_ok.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            if model.terms_should_be_epic_ok.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += TermsShouldBeEpicOkTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_should_be_surjective.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            if model.should_be_surjective.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += ShouldBeSurjectiveTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_surjective_exempted.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            if model.term_surjective_exempted.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += TermSurjectiveExemptedTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_terms_surjective_exempted.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            if model.terms_surjective_exempted.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] +=
                    TermsSurjectiveExemptedTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_surjective_exempted.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            if model.el_surjective_exempted.insert(t) {
                model.el_weights[t.0 .0 as usize] += ElSurjectiveExemptedTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_should_be_surjective_ok.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            if model.el_should_be_surjective_ok.insert(t) {
                model.el_weights[t.0 .0 as usize] += ElShouldBeSurjectiveOkTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_is_surjective_ok.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            if model.el_is_surjective_ok.insert(t) {
                model.el_weights[t.0 .0 as usize] += ElIsSurjectiveOkTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var_term_in_rule.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            t.2 = model.rule_decl_node_equalities.root(t.2);
            if model.var_term_in_rule.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += VarTermInRuleTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += VarTermInRuleTable::WEIGHT;
                model.rule_decl_node_weights[t.2 .0 as usize] += VarTermInRuleTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_if_after_then.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            if model.if_after_then.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += IfAfterThenTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_real_virt_ident.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.real_virt_ident.insert(t) {
                model.ident_weights[t.0 .0 as usize] += RealVirtIdentTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += RealVirtIdentTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_name.drain(..) {
            t.0 = model.rule_decl_node_equalities.root(t.0);
            t.1 = model.ident_equalities.root(t.1);
            if model.rule_name.insert(t) {
                model.rule_decl_node_weights[t.0 .0 as usize] += RuleNameTable::WEIGHT;
                model.ident_weights[t.1 .0 as usize] += RuleNameTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_type_decl_node_loc.drain(..) {
            t.0 = model.type_decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.type_decl_node_loc.insert(t) {
                model.type_decl_node_weights[t.0 .0 as usize] += TypeDeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += TypeDeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_arg_decl_node_loc.drain(..) {
            t.0 = model.arg_decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.arg_decl_node_loc.insert(t) {
                model.arg_decl_node_weights[t.0 .0 as usize] += ArgDeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += ArgDeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_arg_decl_list_node_loc.drain(..) {
            t.0 = model.arg_decl_list_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.arg_decl_list_node_loc.insert(t) {
                model.arg_decl_list_node_weights[t.0 .0 as usize] +=
                    ArgDeclListNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += ArgDeclListNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_decl_node_loc.drain(..) {
            t.0 = model.pred_decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.pred_decl_node_loc.insert(t) {
                model.pred_decl_node_weights[t.0 .0 as usize] += PredDeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += PredDeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_decl_node_loc.drain(..) {
            t.0 = model.func_decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.func_decl_node_loc.insert(t) {
                model.func_decl_node_weights[t.0 .0 as usize] += FuncDeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += FuncDeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_node_loc.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.term_node_loc.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += TermNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += TermNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_list_node_loc.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.term_list_node_loc.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += TermListNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += TermListNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_opt_term_node_loc.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.opt_term_node_loc.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += OptTermNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += OptTermNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_if_atom_node_loc.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.if_atom_node_loc.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += IfAtomNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += IfAtomNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_then_atom_node_loc.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.then_atom_node_loc.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += ThenAtomNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += ThenAtomNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_stmt_node_loc.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.stmt_node_loc.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += StmtNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += StmtNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_stmt_list_node_loc.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.stmt_list_node_loc.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += StmtListNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += StmtListNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_decl_node_loc.drain(..) {
            t.0 = model.rule_decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.rule_decl_node_loc.insert(t) {
                model.rule_decl_node_weights[t.0 .0 as usize] += RuleDeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += RuleDeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_node_loc.drain(..) {
            t.0 = model.decl_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.decl_node_loc.insert(t) {
                model.decl_node_weights[t.0 .0 as usize] += DeclNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += DeclNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_decl_list_node_loc.drain(..) {
            t.0 = model.decl_list_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.decl_list_node_loc.insert(t) {
                model.decl_list_node_weights[t.0 .0 as usize] += DeclListNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += DeclListNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_module_node_loc.drain(..) {
            t.0 = model.module_node_equalities.root(t.0);
            t.1 = model.loc_equalities.root(t.1);
            if model.module_node_loc.insert(t) {
                model.module_node_weights[t.0 .0 as usize] += ModuleNodeLocTable::WEIGHT;
                model.loc_weights[t.1 .0 as usize] += ModuleNodeLocTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_term.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_term.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += RuleChildTermTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_term_list.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_term_list.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += RuleChildTermListTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildTermListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_opt_term.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_opt_term.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += RuleChildOptTermTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildOptTermTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_if_atom.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_if_atom.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += RuleChildIfAtomTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildIfAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_then_atom.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_then_atom.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += RuleChildThenAtomTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildThenAtomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_stmt.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_stmt.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += RuleChildStmtTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildStmtTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_child_stmt_list.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.rule_child_node_equalities.root(t.1);
            if model.rule_child_stmt_list.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += RuleChildStmtListTable::WEIGHT;
                model.rule_child_node_weights[t.1 .0 as usize] += RuleChildStmtListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_type_list.drain(..) {
            t.0 = model.type_list_equalities.root(t.0);
            if model.nil_type_list.insert(t) {
                model.type_list_weights[t.0 .0 as usize] += NilTypeListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_type_list.drain(..) {
            t.0 = model.type_equalities.root(t.0);
            t.1 = model.type_list_equalities.root(t.1);
            t.2 = model.type_list_equalities.root(t.2);
            if model.cons_type_list.insert(t) {
                model.type_weights[t.0 .0 as usize] += ConsTypeListTable::WEIGHT;
                model.type_list_weights[t.1 .0 as usize] += ConsTypeListTable::WEIGHT;
                model.type_list_weights[t.2 .0 as usize] += ConsTypeListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_type.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.type_equalities.root(t.1);
            if model.semantic_type.insert(t) {
                model.ident_weights[t.0 .0 as usize] += SemanticTypeTable::WEIGHT;
                model.type_weights[t.1 .0 as usize] += SemanticTypeTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_arg_types.drain(..) {
            t.0 = model.arg_decl_list_node_equalities.root(t.0);
            t.1 = model.type_list_equalities.root(t.1);
            if model.semantic_arg_types.insert(t) {
                model.arg_decl_list_node_weights[t.0 .0 as usize] += SemanticArgTypesTable::WEIGHT;
                model.type_list_weights[t.1 .0 as usize] += SemanticArgTypesTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_pred.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.pred_equalities.root(t.1);
            if model.semantic_pred.insert(t) {
                model.ident_weights[t.0 .0 as usize] += SemanticPredTable::WEIGHT;
                model.pred_weights[t.1 .0 as usize] += SemanticPredTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_arity.drain(..) {
            t.0 = model.pred_equalities.root(t.0);
            t.1 = model.type_list_equalities.root(t.1);
            if model.arity.insert(t) {
                model.pred_weights[t.0 .0 as usize] += ArityTable::WEIGHT;
                model.type_list_weights[t.1 .0 as usize] += ArityTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_func.drain(..) {
            t.0 = model.ident_equalities.root(t.0);
            t.1 = model.func_equalities.root(t.1);
            if model.semantic_func.insert(t) {
                model.ident_weights[t.0 .0 as usize] += SemanticFuncTable::WEIGHT;
                model.func_weights[t.1 .0 as usize] += SemanticFuncTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_domain.drain(..) {
            t.0 = model.func_equalities.root(t.0);
            t.1 = model.type_list_equalities.root(t.1);
            if model.domain.insert(t) {
                model.func_weights[t.0 .0 as usize] += DomainTable::WEIGHT;
                model.type_list_weights[t.1 .0 as usize] += DomainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_codomain.drain(..) {
            t.0 = model.func_equalities.root(t.0);
            t.1 = model.type_equalities.root(t.1);
            if model.codomain.insert(t) {
                model.func_weights[t.0 .0 as usize] += CodomainTable::WEIGHT;
                model.type_weights[t.1 .0 as usize] += CodomainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_el_list.drain(..) {
            t.0 = model.structure_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            if model.nil_el_list.insert(t) {
                model.structure_weights[t.0 .0 as usize] += NilElListTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += NilElListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cons_el_list.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            t.2 = model.el_list_equalities.root(t.2);
            if model.cons_el_list.insert(t) {
                model.el_weights[t.0 .0 as usize] += ConsElListTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += ConsElListTable::WEIGHT;
                model.el_list_weights[t.2 .0 as usize] += ConsElListTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_app.drain(..) {
            t.0 = model.func_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            t.2 = model.el_equalities.root(t.2);
            if model.func_app.insert(t) {
                model.func_weights[t.0 .0 as usize] += FuncAppTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += FuncAppTable::WEIGHT;
                model.el_weights[t.2 .0 as usize] += FuncAppTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_var.drain(..) {
            t.0 = model.structure_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            t.2 = model.el_equalities.root(t.2);
            if model.var.insert(t) {
                model.structure_weights[t.0 .0 as usize] += VarTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += VarTable::WEIGHT;
                model.el_weights[t.2 .0 as usize] += VarTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_el_structure.drain(..) {
            t.0 = model.el_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.el_structure.insert(t) {
                model.el_weights[t.0 .0 as usize] += ElStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += ElStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_els_structure.drain(..) {
            t.0 = model.el_list_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.els_structure.insert(t) {
                model.el_list_weights[t.0 .0 as usize] += ElsStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += ElsStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_dom.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.dom.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += DomTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += DomTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_cod.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.cod.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += CodTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += CodTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_map_el.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.el_equalities.root(t.1);
            t.2 = model.el_equalities.root(t.2);
            if model.map_el.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += MapElTable::WEIGHT;
                model.el_weights[t.1 .0 as usize] += MapElTable::WEIGHT;
                model.el_weights[t.2 .0 as usize] += MapElTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_map_els.drain(..) {
            t.0 = model.morphism_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            t.2 = model.el_list_equalities.root(t.2);
            if model.map_els.insert(t) {
                model.morphism_weights[t.0 .0 as usize] += MapElsTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += MapElsTable::WEIGHT;
                model.el_list_weights[t.2 .0 as usize] += MapElsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_initial_structure.drain(..) {
            t.0 = model.structure_equalities.root(t.0);
            if model.initial_structure.insert(t) {
                model.structure_weights[t.0 .0 as usize] += InitialStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_initiality_morphism.drain(..) {
            t.0 = model.structure_equalities.root(t.0);
            t.1 = model.morphism_equalities.root(t.1);
            if model.initiality_morphism.insert(t) {
                model.structure_weights[t.0 .0 as usize] += InitialityMorphismTable::WEIGHT;
                model.morphism_weights[t.1 .0 as usize] += InitialityMorphismTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_nil_chain.drain(..) {
            t.0 = model.chain_equalities.root(t.0);
            if model.nil_chain.insert(t) {
                model.chain_weights[t.0 .0 as usize] += NilChainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_chain_tail.drain(..) {
            t.0 = model.chain_equalities.root(t.0);
            t.1 = model.chain_equalities.root(t.1);
            if model.chain_tail.insert(t) {
                model.chain_weights[t.0 .0 as usize] += ChainTailTable::WEIGHT;
                model.chain_weights[t.1 .0 as usize] += ChainTailTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_chain_head_structure.drain(..) {
            t.0 = model.chain_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.chain_head_structure.insert(t) {
                model.chain_weights[t.0 .0 as usize] += ChainHeadStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += ChainHeadStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_chain_head_transition.drain(..) {
            t.0 = model.chain_equalities.root(t.0);
            t.1 = model.morphism_equalities.root(t.1);
            if model.chain_head_transition.insert(t) {
                model.chain_weights[t.0 .0 as usize] += ChainHeadTransitionTable::WEIGHT;
                model.morphism_weights[t.1 .0 as usize] += ChainHeadTransitionTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_type_symbol.drain(..) {
            t.0 = model.symbol_kind_equalities.root(t.0);
            if model.type_symbol.insert(t) {
                model.symbol_kind_weights[t.0 .0 as usize] += TypeSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_pred_symbol.drain(..) {
            t.0 = model.symbol_kind_equalities.root(t.0);
            if model.pred_symbol.insert(t) {
                model.symbol_kind_weights[t.0 .0 as usize] += PredSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_func_symbol.drain(..) {
            t.0 = model.symbol_kind_equalities.root(t.0);
            if model.func_symbol.insert(t) {
                model.symbol_kind_weights[t.0 .0 as usize] += FuncSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_symbol.drain(..) {
            t.0 = model.symbol_kind_equalities.root(t.0);
            if model.rule_symbol.insert(t) {
                model.symbol_kind_weights[t.0 .0 as usize] += RuleSymbolTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_zero.drain(..) {
            t.0 = model.nat_equalities.root(t.0);
            if model.zero.insert(t) {
                model.nat_weights[t.0 .0 as usize] += ZeroTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_succ.drain(..) {
            t.0 = model.nat_equalities.root(t.0);
            t.1 = model.nat_equalities.root(t.1);
            if model.succ.insert(t) {
                model.nat_weights[t.0 .0 as usize] += SuccTable::WEIGHT;
                model.nat_weights[t.1 .0 as usize] += SuccTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_type_list_len.drain(..) {
            t.0 = model.type_list_equalities.root(t.0);
            t.1 = model.nat_equalities.root(t.1);
            if model.type_list_len.insert(t) {
                model.type_list_weights[t.0 .0 as usize] += TypeListLenTable::WEIGHT;
                model.nat_weights[t.1 .0 as usize] += TypeListLenTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_list_len.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.nat_equalities.root(t.1);
            if model.term_list_len.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += TermListLenTable::WEIGHT;
                model.nat_weights[t.1 .0 as usize] += TermListLenTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_rule_chain.drain(..) {
            t.0 = model.rule_decl_node_equalities.root(t.0);
            t.1 = model.chain_equalities.root(t.1);
            if model.rule_chain.insert(t) {
                model.rule_decl_node_weights[t.0 .0 as usize] += RuleChainTable::WEIGHT;
                model.chain_weights[t.1 .0 as usize] += RuleChainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_stmt_list_chain.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.chain_equalities.root(t.1);
            if model.stmt_list_chain.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += StmtListChainTable::WEIGHT;
                model.chain_weights[t.1 .0 as usize] += StmtListChainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_stmt_structure.drain(..) {
            t.0 = model.stmt_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.stmt_structure.insert(t) {
                model.stmt_node_weights[t.0 .0 as usize] += StmtStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += StmtStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_if_atom_structure.drain(..) {
            t.0 = model.if_atom_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.if_atom_structure.insert(t) {
                model.if_atom_node_weights[t.0 .0 as usize] += IfAtomStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += IfAtomStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_then_atom_structure.drain(..) {
            t.0 = model.then_atom_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.then_atom_structure.insert(t) {
                model.then_atom_node_weights[t.0 .0 as usize] += ThenAtomStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += ThenAtomStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_term_structure.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.term_structure.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += TermStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += TermStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_terms_structure.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.terms_structure.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += TermsStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += TermsStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_opt_term_structure.drain(..) {
            t.0 = model.opt_term_node_equalities.root(t.0);
            t.1 = model.structure_equalities.root(t.1);
            if model.opt_term_structure.insert(t) {
                model.opt_term_node_weights[t.0 .0 as usize] += OptTermStructureTable::WEIGHT;
                model.structure_weights[t.1 .0 as usize] += OptTermStructureTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_el.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.el_equalities.root(t.1);
            if model.semantic_el.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += SemanticElTable::WEIGHT;
                model.el_weights[t.1 .0 as usize] += SemanticElTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_semantic_els.drain(..) {
            t.0 = model.term_list_node_equalities.root(t.0);
            t.1 = model.el_list_equalities.root(t.1);
            if model.semantic_els.insert(t) {
                model.term_list_node_weights[t.0 .0 as usize] += SemanticElsTable::WEIGHT;
                model.el_list_weights[t.1 .0 as usize] += SemanticElsTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_wildcard_virt_ident.drain(..) {
            t.0 = model.term_node_equalities.root(t.0);
            t.1 = model.virt_ident_equalities.root(t.1);
            if model.wildcard_virt_ident.insert(t) {
                model.term_node_weights[t.0 .0 as usize] += WildcardVirtIdentTable::WEIGHT;
                model.virt_ident_weights[t.1 .0 as usize] += WildcardVirtIdentTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_grouped_rule_chain.drain(..) {
            t.0 = model.rule_decl_node_equalities.root(t.0);
            t.1 = model.chain_equalities.root(t.1);
            if model.grouped_rule_chain.insert(t) {
                model.rule_decl_node_weights[t.0 .0 as usize] += GroupedRuleChainTable::WEIGHT;
                model.chain_weights[t.1 .0 as usize] += GroupedRuleChainTable::WEIGHT;
            }
        }

        #[allow(unused_mut)]
        for mut t in self.new_grouped_stmt_list_chain.drain(..) {
            t.0 = model.stmt_list_node_equalities.root(t.0);
            t.1 = model.chain_equalities.root(t.1);
            if model.grouped_stmt_list_chain.insert(t) {
                model.stmt_list_node_weights[t.0 .0 as usize] += GroupedStmtListChainTable::WEIGHT;
                model.chain_weights[t.1 .0 as usize] += GroupedStmtListChainTable::WEIGHT;
            }
        }
    }
    #[allow(dead_code)]
    fn new_ident(&mut self, model: &Model) -> Ident {
        let id: usize = model.ident_equalities.len() + self.new_ident_number;
        assert!(id <= (u32::MAX as usize));
        self.new_ident_number += 1;
        Ident::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_virt_ident(&mut self, model: &Model) -> VirtIdent {
        let id: usize = model.virt_ident_equalities.len() + self.new_virt_ident_number;
        assert!(id <= (u32::MAX as usize));
        self.new_virt_ident_number += 1;
        VirtIdent::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_type_decl_node(&mut self, model: &Model) -> TypeDeclNode {
        let id: usize = model.type_decl_node_equalities.len() + self.new_type_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_type_decl_node_number += 1;
        TypeDeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_arg_decl_node(&mut self, model: &Model) -> ArgDeclNode {
        let id: usize = model.arg_decl_node_equalities.len() + self.new_arg_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_arg_decl_node_number += 1;
        ArgDeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_arg_decl_list_node(&mut self, model: &Model) -> ArgDeclListNode {
        let id: usize =
            model.arg_decl_list_node_equalities.len() + self.new_arg_decl_list_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_arg_decl_list_node_number += 1;
        ArgDeclListNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_pred_decl_node(&mut self, model: &Model) -> PredDeclNode {
        let id: usize = model.pred_decl_node_equalities.len() + self.new_pred_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_pred_decl_node_number += 1;
        PredDeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_func_decl_node(&mut self, model: &Model) -> FuncDeclNode {
        let id: usize = model.func_decl_node_equalities.len() + self.new_func_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_func_decl_node_number += 1;
        FuncDeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_term_node(&mut self, model: &Model) -> TermNode {
        let id: usize = model.term_node_equalities.len() + self.new_term_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_term_node_number += 1;
        TermNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_term_list_node(&mut self, model: &Model) -> TermListNode {
        let id: usize = model.term_list_node_equalities.len() + self.new_term_list_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_term_list_node_number += 1;
        TermListNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_opt_term_node(&mut self, model: &Model) -> OptTermNode {
        let id: usize = model.opt_term_node_equalities.len() + self.new_opt_term_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_opt_term_node_number += 1;
        OptTermNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_if_atom_node(&mut self, model: &Model) -> IfAtomNode {
        let id: usize = model.if_atom_node_equalities.len() + self.new_if_atom_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_if_atom_node_number += 1;
        IfAtomNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_then_atom_node(&mut self, model: &Model) -> ThenAtomNode {
        let id: usize = model.then_atom_node_equalities.len() + self.new_then_atom_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_then_atom_node_number += 1;
        ThenAtomNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_stmt_node(&mut self, model: &Model) -> StmtNode {
        let id: usize = model.stmt_node_equalities.len() + self.new_stmt_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_stmt_node_number += 1;
        StmtNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_stmt_list_node(&mut self, model: &Model) -> StmtListNode {
        let id: usize = model.stmt_list_node_equalities.len() + self.new_stmt_list_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_stmt_list_node_number += 1;
        StmtListNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_rule_decl_node(&mut self, model: &Model) -> RuleDeclNode {
        let id: usize = model.rule_decl_node_equalities.len() + self.new_rule_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_rule_decl_node_number += 1;
        RuleDeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_decl_node(&mut self, model: &Model) -> DeclNode {
        let id: usize = model.decl_node_equalities.len() + self.new_decl_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_decl_node_number += 1;
        DeclNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_decl_list_node(&mut self, model: &Model) -> DeclListNode {
        let id: usize = model.decl_list_node_equalities.len() + self.new_decl_list_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_decl_list_node_number += 1;
        DeclListNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_module_node(&mut self, model: &Model) -> ModuleNode {
        let id: usize = model.module_node_equalities.len() + self.new_module_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_module_node_number += 1;
        ModuleNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_loc(&mut self, model: &Model) -> Loc {
        let id: usize = model.loc_equalities.len() + self.new_loc_number;
        assert!(id <= (u32::MAX as usize));
        self.new_loc_number += 1;
        Loc::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_rule_child_node(&mut self, model: &Model) -> RuleChildNode {
        let id: usize = model.rule_child_node_equalities.len() + self.new_rule_child_node_number;
        assert!(id <= (u32::MAX as usize));
        self.new_rule_child_node_number += 1;
        RuleChildNode::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_type(&mut self, model: &Model) -> Type {
        let id: usize = model.type_equalities.len() + self.new_type_number;
        assert!(id <= (u32::MAX as usize));
        self.new_type_number += 1;
        Type::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_type_list(&mut self, model: &Model) -> TypeList {
        let id: usize = model.type_list_equalities.len() + self.new_type_list_number;
        assert!(id <= (u32::MAX as usize));
        self.new_type_list_number += 1;
        TypeList::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_pred(&mut self, model: &Model) -> Pred {
        let id: usize = model.pred_equalities.len() + self.new_pred_number;
        assert!(id <= (u32::MAX as usize));
        self.new_pred_number += 1;
        Pred::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_func(&mut self, model: &Model) -> Func {
        let id: usize = model.func_equalities.len() + self.new_func_number;
        assert!(id <= (u32::MAX as usize));
        self.new_func_number += 1;
        Func::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_structure(&mut self, model: &Model) -> Structure {
        let id: usize = model.structure_equalities.len() + self.new_structure_number;
        assert!(id <= (u32::MAX as usize));
        self.new_structure_number += 1;
        Structure::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_el(&mut self, model: &Model) -> El {
        let id: usize = model.el_equalities.len() + self.new_el_number;
        assert!(id <= (u32::MAX as usize));
        self.new_el_number += 1;
        El::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_el_list(&mut self, model: &Model) -> ElList {
        let id: usize = model.el_list_equalities.len() + self.new_el_list_number;
        assert!(id <= (u32::MAX as usize));
        self.new_el_list_number += 1;
        ElList::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_morphism(&mut self, model: &Model) -> Morphism {
        let id: usize = model.morphism_equalities.len() + self.new_morphism_number;
        assert!(id <= (u32::MAX as usize));
        self.new_morphism_number += 1;
        Morphism::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_chain(&mut self, model: &Model) -> Chain {
        let id: usize = model.chain_equalities.len() + self.new_chain_number;
        assert!(id <= (u32::MAX as usize));
        self.new_chain_number += 1;
        Chain::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_symbol_kind(&mut self, model: &Model) -> SymbolKind {
        let id: usize = model.symbol_kind_equalities.len() + self.new_symbol_kind_number;
        assert!(id <= (u32::MAX as usize));
        self.new_symbol_kind_number += 1;
        SymbolKind::from(id as u32)
    }
    #[allow(dead_code)]
    fn new_nat(&mut self, model: &Model) -> Nat {
        let id: usize = model.nat_equalities.len() + self.new_nat_number;
        assert!(id <= (u32::MAX as usize));
        self.new_nat_number += 1;
        Nat::from(id as u32)
    }
}

impl Eqlog {
    /// Creates an empty model.
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self {
            ident_equalities: Unification::new(),
            ident_dirty: BTreeSet::new(),
            ident_dirty_prev: Vec::new(),
            ident_weights: Vec::new(),
            ident_all: BTreeSet::new(),
            virt_ident_equalities: Unification::new(),
            virt_ident_dirty: BTreeSet::new(),
            virt_ident_dirty_prev: Vec::new(),
            virt_ident_weights: Vec::new(),
            virt_ident_all: BTreeSet::new(),
            type_decl_node_equalities: Unification::new(),
            type_decl_node_dirty: BTreeSet::new(),
            type_decl_node_dirty_prev: Vec::new(),
            type_decl_node_weights: Vec::new(),
            type_decl_node_all: BTreeSet::new(),
            arg_decl_node_equalities: Unification::new(),
            arg_decl_node_dirty: BTreeSet::new(),
            arg_decl_node_dirty_prev: Vec::new(),
            arg_decl_node_weights: Vec::new(),
            arg_decl_node_all: BTreeSet::new(),
            arg_decl_list_node_equalities: Unification::new(),
            arg_decl_list_node_dirty: BTreeSet::new(),
            arg_decl_list_node_dirty_prev: Vec::new(),
            arg_decl_list_node_weights: Vec::new(),
            arg_decl_list_node_all: BTreeSet::new(),
            pred_decl_node_equalities: Unification::new(),
            pred_decl_node_dirty: BTreeSet::new(),
            pred_decl_node_dirty_prev: Vec::new(),
            pred_decl_node_weights: Vec::new(),
            pred_decl_node_all: BTreeSet::new(),
            func_decl_node_equalities: Unification::new(),
            func_decl_node_dirty: BTreeSet::new(),
            func_decl_node_dirty_prev: Vec::new(),
            func_decl_node_weights: Vec::new(),
            func_decl_node_all: BTreeSet::new(),
            term_node_equalities: Unification::new(),
            term_node_dirty: BTreeSet::new(),
            term_node_dirty_prev: Vec::new(),
            term_node_weights: Vec::new(),
            term_node_all: BTreeSet::new(),
            term_list_node_equalities: Unification::new(),
            term_list_node_dirty: BTreeSet::new(),
            term_list_node_dirty_prev: Vec::new(),
            term_list_node_weights: Vec::new(),
            term_list_node_all: BTreeSet::new(),
            opt_term_node_equalities: Unification::new(),
            opt_term_node_dirty: BTreeSet::new(),
            opt_term_node_dirty_prev: Vec::new(),
            opt_term_node_weights: Vec::new(),
            opt_term_node_all: BTreeSet::new(),
            if_atom_node_equalities: Unification::new(),
            if_atom_node_dirty: BTreeSet::new(),
            if_atom_node_dirty_prev: Vec::new(),
            if_atom_node_weights: Vec::new(),
            if_atom_node_all: BTreeSet::new(),
            then_atom_node_equalities: Unification::new(),
            then_atom_node_dirty: BTreeSet::new(),
            then_atom_node_dirty_prev: Vec::new(),
            then_atom_node_weights: Vec::new(),
            then_atom_node_all: BTreeSet::new(),
            stmt_node_equalities: Unification::new(),
            stmt_node_dirty: BTreeSet::new(),
            stmt_node_dirty_prev: Vec::new(),
            stmt_node_weights: Vec::new(),
            stmt_node_all: BTreeSet::new(),
            stmt_list_node_equalities: Unification::new(),
            stmt_list_node_dirty: BTreeSet::new(),
            stmt_list_node_dirty_prev: Vec::new(),
            stmt_list_node_weights: Vec::new(),
            stmt_list_node_all: BTreeSet::new(),
            rule_decl_node_equalities: Unification::new(),
            rule_decl_node_dirty: BTreeSet::new(),
            rule_decl_node_dirty_prev: Vec::new(),
            rule_decl_node_weights: Vec::new(),
            rule_decl_node_all: BTreeSet::new(),
            decl_node_equalities: Unification::new(),
            decl_node_dirty: BTreeSet::new(),
            decl_node_dirty_prev: Vec::new(),
            decl_node_weights: Vec::new(),
            decl_node_all: BTreeSet::new(),
            decl_list_node_equalities: Unification::new(),
            decl_list_node_dirty: BTreeSet::new(),
            decl_list_node_dirty_prev: Vec::new(),
            decl_list_node_weights: Vec::new(),
            decl_list_node_all: BTreeSet::new(),
            module_node_equalities: Unification::new(),
            module_node_dirty: BTreeSet::new(),
            module_node_dirty_prev: Vec::new(),
            module_node_weights: Vec::new(),
            module_node_all: BTreeSet::new(),
            loc_equalities: Unification::new(),
            loc_dirty: BTreeSet::new(),
            loc_dirty_prev: Vec::new(),
            loc_weights: Vec::new(),
            loc_all: BTreeSet::new(),
            rule_child_node_equalities: Unification::new(),
            rule_child_node_dirty: BTreeSet::new(),
            rule_child_node_dirty_prev: Vec::new(),
            rule_child_node_weights: Vec::new(),
            rule_child_node_all: BTreeSet::new(),
            type_equalities: Unification::new(),
            type_dirty: BTreeSet::new(),
            type_dirty_prev: Vec::new(),
            type_weights: Vec::new(),
            type_all: BTreeSet::new(),
            type_list_equalities: Unification::new(),
            type_list_dirty: BTreeSet::new(),
            type_list_dirty_prev: Vec::new(),
            type_list_weights: Vec::new(),
            type_list_all: BTreeSet::new(),
            pred_equalities: Unification::new(),
            pred_dirty: BTreeSet::new(),
            pred_dirty_prev: Vec::new(),
            pred_weights: Vec::new(),
            pred_all: BTreeSet::new(),
            func_equalities: Unification::new(),
            func_dirty: BTreeSet::new(),
            func_dirty_prev: Vec::new(),
            func_weights: Vec::new(),
            func_all: BTreeSet::new(),
            structure_equalities: Unification::new(),
            structure_dirty: BTreeSet::new(),
            structure_dirty_prev: Vec::new(),
            structure_weights: Vec::new(),
            structure_all: BTreeSet::new(),
            el_equalities: Unification::new(),
            el_dirty: BTreeSet::new(),
            el_dirty_prev: Vec::new(),
            el_weights: Vec::new(),
            el_all: BTreeSet::new(),
            el_list_equalities: Unification::new(),
            el_list_dirty: BTreeSet::new(),
            el_list_dirty_prev: Vec::new(),
            el_list_weights: Vec::new(),
            el_list_all: BTreeSet::new(),
            morphism_equalities: Unification::new(),
            morphism_dirty: BTreeSet::new(),
            morphism_dirty_prev: Vec::new(),
            morphism_weights: Vec::new(),
            morphism_all: BTreeSet::new(),
            chain_equalities: Unification::new(),
            chain_dirty: BTreeSet::new(),
            chain_dirty_prev: Vec::new(),
            chain_weights: Vec::new(),
            chain_all: BTreeSet::new(),
            symbol_kind_equalities: Unification::new(),
            symbol_kind_dirty: BTreeSet::new(),
            symbol_kind_dirty_prev: Vec::new(),
            symbol_kind_weights: Vec::new(),
            symbol_kind_all: BTreeSet::new(),
            nat_equalities: Unification::new(),
            nat_dirty: BTreeSet::new(),
            nat_dirty_prev: Vec::new(),
            nat_weights: Vec::new(),
            nat_all: BTreeSet::new(),
            absurd: AbsurdTable::new(),
            type_decl: TypeDeclTable::new(),
            arg_decl_node_name: ArgDeclNodeNameTable::new(),
            arg_decl_node_type: ArgDeclNodeTypeTable::new(),
            nil_arg_decl_list_node: NilArgDeclListNodeTable::new(),
            cons_arg_decl_list_node: ConsArgDeclListNodeTable::new(),
            pred_decl: PredDeclTable::new(),
            func_decl: FuncDeclTable::new(),
            nil_term_list_node: NilTermListNodeTable::new(),
            cons_term_list_node: ConsTermListNodeTable::new(),
            none_term_node: NoneTermNodeTable::new(),
            some_term_node: SomeTermNodeTable::new(),
            var_term_node: VarTermNodeTable::new(),
            wildcard_term_node: WildcardTermNodeTable::new(),
            app_term_node: AppTermNodeTable::new(),
            equal_if_atom_node: EqualIfAtomNodeTable::new(),
            defined_if_atom_node: DefinedIfAtomNodeTable::new(),
            pred_if_atom_node: PredIfAtomNodeTable::new(),
            var_if_atom_node: VarIfAtomNodeTable::new(),
            equal_then_atom_node: EqualThenAtomNodeTable::new(),
            defined_then_atom_node: DefinedThenAtomNodeTable::new(),
            pred_then_atom_node: PredThenAtomNodeTable::new(),
            if_stmt_node: IfStmtNodeTable::new(),
            then_stmt_node: ThenStmtNodeTable::new(),
            nil_stmt_list_node: NilStmtListNodeTable::new(),
            cons_stmt_list_node: ConsStmtListNodeTable::new(),
            rule_decl: RuleDeclTable::new(),
            decl_node_type: DeclNodeTypeTable::new(),
            decl_node_pred: DeclNodePredTable::new(),
            decl_node_func: DeclNodeFuncTable::new(),
            decl_node_rule: DeclNodeRuleTable::new(),
            nil_decl_list_node: NilDeclListNodeTable::new(),
            cons_decl_list_node: ConsDeclListNodeTable::new(),
            decls_module_node: DeclsModuleNodeTable::new(),
            rule_child: RuleChildTable::new(),
            pred_app: PredAppTable::new(),
            el_type: ElTypeTable::new(),
            el_types: ElTypesTable::new(),
            constrained_el: ConstrainedElTable::new(),
            constrained_els: ConstrainedElsTable::new(),
            in_ker: InKerTable::new(),
            el_in_img: ElInImgTable::new(),
            pred_tuple_in_img: PredTupleInImgTable::new(),
            func_app_in_img: FuncAppInImgTable::new(),
            defined_symbol: DefinedSymbolTable::new(),
            should_be_symbol: ShouldBeSymbolTable::new(),
            pred_arg_num_should_match: PredArgNumShouldMatchTable::new(),
            func_arg_num_should_match: FuncArgNumShouldMatchTable::new(),
            var_before_term: VarBeforeTermTable::new(),
            var_before_terms: VarBeforeTermsTable::new(),
            var_before_opt_term: VarBeforeOptTermTable::new(),
            var_before_if_atom: VarBeforeIfAtomTable::new(),
            var_before_then_atom: VarBeforeThenAtomTable::new(),
            var_before_stmt: VarBeforeStmtTable::new(),
            var_before_stmts: VarBeforeStmtsTable::new(),
            var_in_term: VarInTermTable::new(),
            var_in_terms: VarInTermsTable::new(),
            var_in_opt_term: VarInOptTermTable::new(),
            var_in_if_atom: VarInIfAtomTable::new(),
            var_in_then_atom: VarInThenAtomTable::new(),
            var_in_stmt: VarInStmtTable::new(),
            term_should_be_epic_ok: TermShouldBeEpicOkTable::new(),
            terms_should_be_epic_ok: TermsShouldBeEpicOkTable::new(),
            should_be_surjective: ShouldBeSurjectiveTable::new(),
            term_surjective_exempted: TermSurjectiveExemptedTable::new(),
            terms_surjective_exempted: TermsSurjectiveExemptedTable::new(),
            el_surjective_exempted: ElSurjectiveExemptedTable::new(),
            el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable::new(),
            el_is_surjective_ok: ElIsSurjectiveOkTable::new(),
            var_term_in_rule: VarTermInRuleTable::new(),
            if_after_then: IfAfterThenTable::new(),
            real_virt_ident: RealVirtIdentTable::new(),
            rule_name: RuleNameTable::new(),
            type_decl_node_loc: TypeDeclNodeLocTable::new(),
            arg_decl_node_loc: ArgDeclNodeLocTable::new(),
            arg_decl_list_node_loc: ArgDeclListNodeLocTable::new(),
            pred_decl_node_loc: PredDeclNodeLocTable::new(),
            func_decl_node_loc: FuncDeclNodeLocTable::new(),
            term_node_loc: TermNodeLocTable::new(),
            term_list_node_loc: TermListNodeLocTable::new(),
            opt_term_node_loc: OptTermNodeLocTable::new(),
            if_atom_node_loc: IfAtomNodeLocTable::new(),
            then_atom_node_loc: ThenAtomNodeLocTable::new(),
            stmt_node_loc: StmtNodeLocTable::new(),
            stmt_list_node_loc: StmtListNodeLocTable::new(),
            rule_decl_node_loc: RuleDeclNodeLocTable::new(),
            decl_node_loc: DeclNodeLocTable::new(),
            decl_list_node_loc: DeclListNodeLocTable::new(),
            module_node_loc: ModuleNodeLocTable::new(),
            rule_child_term: RuleChildTermTable::new(),
            rule_child_term_list: RuleChildTermListTable::new(),
            rule_child_opt_term: RuleChildOptTermTable::new(),
            rule_child_if_atom: RuleChildIfAtomTable::new(),
            rule_child_then_atom: RuleChildThenAtomTable::new(),
            rule_child_stmt: RuleChildStmtTable::new(),
            rule_child_stmt_list: RuleChildStmtListTable::new(),
            nil_type_list: NilTypeListTable::new(),
            cons_type_list: ConsTypeListTable::new(),
            semantic_type: SemanticTypeTable::new(),
            semantic_arg_types: SemanticArgTypesTable::new(),
            semantic_pred: SemanticPredTable::new(),
            arity: ArityTable::new(),
            semantic_func: SemanticFuncTable::new(),
            domain: DomainTable::new(),
            codomain: CodomainTable::new(),
            nil_el_list: NilElListTable::new(),
            cons_el_list: ConsElListTable::new(),
            func_app: FuncAppTable::new(),
            var: VarTable::new(),
            el_structure: ElStructureTable::new(),
            els_structure: ElsStructureTable::new(),
            dom: DomTable::new(),
            cod: CodTable::new(),
            map_el: MapElTable::new(),
            map_els: MapElsTable::new(),
            initial_structure: InitialStructureTable::new(),
            initiality_morphism: InitialityMorphismTable::new(),
            nil_chain: NilChainTable::new(),
            chain_tail: ChainTailTable::new(),
            chain_head_structure: ChainHeadStructureTable::new(),
            chain_head_transition: ChainHeadTransitionTable::new(),
            type_symbol: TypeSymbolTable::new(),
            pred_symbol: PredSymbolTable::new(),
            func_symbol: FuncSymbolTable::new(),
            rule_symbol: RuleSymbolTable::new(),
            zero: ZeroTable::new(),
            succ: SuccTable::new(),
            type_list_len: TypeListLenTable::new(),
            term_list_len: TermListLenTable::new(),
            rule_chain: RuleChainTable::new(),
            stmt_list_chain: StmtListChainTable::new(),
            stmt_structure: StmtStructureTable::new(),
            if_atom_structure: IfAtomStructureTable::new(),
            then_atom_structure: ThenAtomStructureTable::new(),
            term_structure: TermStructureTable::new(),
            terms_structure: TermsStructureTable::new(),
            opt_term_structure: OptTermStructureTable::new(),
            semantic_el: SemanticElTable::new(),
            semantic_els: SemanticElsTable::new(),
            wildcard_virt_ident: WildcardVirtIdentTable::new(),
            grouped_rule_chain: GroupedRuleChainTable::new(),
            grouped_stmt_list_chain: GroupedStmtListChainTable::new(),
            empty_join_is_dirty: true,
            empty_join_is_dirty_prev: true,
            delta: Some(Box::new(ModelDelta::new())),
        }
    }

    /// Closes the model under all axioms.
    /// Depending on the axioms and the model, this may run indefinitely.
    #[allow(dead_code)]
    pub fn close(&mut self) {
        self.close_until(|_: &Self| false);
    }
    /// Closes the model under all axioms until `condition` is satisfied.
    /// Depending on the axioms and `condition`, this may run indefinitely.
    /// Returns `true` if the `condition` eventually holds.
    /// Returns `false` if the model could be closed under all axioms but `condition` still does not hold.
    #[allow(dead_code)]
    pub fn close_until(&mut self, condition: impl Fn(&Self) -> bool) -> bool {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        delta.apply(self);
        if condition(self) {
            self.delta = Some(delta);
            return true;
        }

        while self.is_dirty() {
            loop {
                self.query_and_record_functionality_real_virt_ident(&mut delta);
                self.query_and_record_functionality_rule_name(&mut delta);
                self.query_and_record_functionality_type_decl_node_loc(&mut delta);
                self.query_and_record_functionality_arg_decl_node_loc(&mut delta);
                self.query_and_record_functionality_arg_decl_list_node_loc(&mut delta);
                self.query_and_record_functionality_pred_decl_node_loc(&mut delta);
                self.query_and_record_functionality_func_decl_node_loc(&mut delta);
                self.query_and_record_functionality_term_node_loc(&mut delta);
                self.query_and_record_functionality_term_list_node_loc(&mut delta);
                self.query_and_record_functionality_opt_term_node_loc(&mut delta);
                self.query_and_record_functionality_if_atom_node_loc(&mut delta);
                self.query_and_record_functionality_then_atom_node_loc(&mut delta);
                self.query_and_record_functionality_stmt_node_loc(&mut delta);
                self.query_and_record_functionality_stmt_list_node_loc(&mut delta);
                self.query_and_record_functionality_rule_decl_node_loc(&mut delta);
                self.query_and_record_functionality_decl_node_loc(&mut delta);
                self.query_and_record_functionality_decl_list_node_loc(&mut delta);
                self.query_and_record_functionality_module_node_loc(&mut delta);
                self.query_and_record_functionality_rule_child_term(&mut delta);
                self.query_and_record_functionality_rule_child_term_list(&mut delta);
                self.query_and_record_functionality_rule_child_opt_term(&mut delta);
                self.query_and_record_functionality_rule_child_if_atom(&mut delta);
                self.query_and_record_functionality_rule_child_then_atom(&mut delta);
                self.query_and_record_functionality_rule_child_stmt(&mut delta);
                self.query_and_record_functionality_rule_child_stmt_list(&mut delta);
                self.query_and_record_functionality_nil_type_list(&mut delta);
                self.query_and_record_functionality_cons_type_list(&mut delta);
                self.query_and_record_functionality_semantic_type(&mut delta);
                self.query_and_record_functionality_semantic_arg_types(&mut delta);
                self.query_and_record_functionality_semantic_pred(&mut delta);
                self.query_and_record_functionality_arity(&mut delta);
                self.query_and_record_functionality_semantic_func(&mut delta);
                self.query_and_record_functionality_domain(&mut delta);
                self.query_and_record_functionality_codomain(&mut delta);
                self.query_and_record_functionality_nil_el_list(&mut delta);
                self.query_and_record_functionality_cons_el_list(&mut delta);
                self.query_and_record_functionality_func_app(&mut delta);
                self.query_and_record_functionality_var(&mut delta);
                self.query_and_record_functionality_el_structure(&mut delta);
                self.query_and_record_functionality_els_structure(&mut delta);
                self.query_and_record_functionality_dom(&mut delta);
                self.query_and_record_functionality_cod(&mut delta);
                self.query_and_record_functionality_map_el(&mut delta);
                self.query_and_record_functionality_map_els(&mut delta);
                self.query_and_record_functionality_initial_structure(&mut delta);
                self.query_and_record_functionality_initiality_morphism(&mut delta);
                self.query_and_record_functionality_nil_chain(&mut delta);
                self.query_and_record_functionality_chain_tail(&mut delta);
                self.query_and_record_functionality_chain_head_structure(&mut delta);
                self.query_and_record_functionality_chain_head_transition(&mut delta);
                self.query_and_record_functionality_type_symbol(&mut delta);
                self.query_and_record_functionality_pred_symbol(&mut delta);
                self.query_and_record_functionality_func_symbol(&mut delta);
                self.query_and_record_functionality_rule_symbol(&mut delta);
                self.query_and_record_functionality_zero(&mut delta);
                self.query_and_record_functionality_succ(&mut delta);
                self.query_and_record_functionality_type_list_len(&mut delta);
                self.query_and_record_functionality_term_list_len(&mut delta);
                self.query_and_record_functionality_rule_chain(&mut delta);
                self.query_and_record_functionality_stmt_list_chain(&mut delta);
                self.query_and_record_functionality_stmt_structure(&mut delta);
                self.query_and_record_functionality_if_atom_structure(&mut delta);
                self.query_and_record_functionality_then_atom_structure(&mut delta);
                self.query_and_record_functionality_term_structure(&mut delta);
                self.query_and_record_functionality_terms_structure(&mut delta);
                self.query_and_record_functionality_opt_term_structure(&mut delta);
                self.query_and_record_functionality_semantic_el(&mut delta);
                self.query_and_record_functionality_semantic_els(&mut delta);
                self.query_and_record_functionality_wildcard_virt_ident(&mut delta);
                self.query_and_record_functionality_grouped_rule_chain(&mut delta);
                self.query_and_record_functionality_grouped_stmt_list_chain(&mut delta);
                self.query_and_record_rule_child_rule_decl(&mut delta);
                self.query_and_record_rule_child_stmts_cons(&mut delta);
                self.query_and_record_rule_child_stmt_if(&mut delta);
                self.query_and_record_rule_child_stmt_then(&mut delta);
                self.query_and_record_rule_child_if_atom_equal(&mut delta);
                self.query_and_record_rule_child_if_atom_defined(&mut delta);
                self.query_and_record_rule_child_if_atom_pred(&mut delta);
                self.query_and_record_rule_child_if_atom_var(&mut delta);
                self.query_and_record_rule_child_then_atom_equal(&mut delta);
                self.query_and_record_rule_child_then_atom_defined(&mut delta);
                self.query_and_record_rule_child_then_atom_pred(&mut delta);
                self.query_and_record_rule_child_terms_cons(&mut delta);
                self.query_and_record_rule_child_opt_term_some(&mut delta);
                self.query_and_record_rule_child_term_app(&mut delta);
                self.query_and_record_type_list_nil_not_cons(&mut delta);
                self.query_and_record_type_list_cons_injective(&mut delta);
                self.query_and_record_arity_decl(&mut delta);
                self.query_and_record_domain_decl(&mut delta);
                self.query_and_record_el_list_cons_injective(&mut delta);
                self.query_and_record_el_list_cons_nil(&mut delta);
                self.query_and_record_nil_els_structure(&mut delta);
                self.query_and_record_cons_els_structure(&mut delta);
                self.query_and_record_func_app_structure(&mut delta);
                self.query_and_record_var_structure(&mut delta);
                self.query_and_record_cons_el_types_reverse(&mut delta);
                self.query_and_record_func_app_types(&mut delta);
                self.query_and_record_pred_app_types(&mut delta);
                self.query_and_record_func_app_constrained(&mut delta);
                self.query_and_record_pred_app_constrained(&mut delta);
                self.query_and_record_constrained_head_tail(&mut delta);
                self.query_and_record_map_el_structure(&mut delta);
                self.query_and_record_map_els_structure(&mut delta);
                self.query_and_record_map_nil_els(&mut delta);
                self.query_and_record_map_app_func(&mut delta);
                self.query_and_record_map_var(&mut delta);
                self.query_and_record_map_pred_app(&mut delta);
                self.query_and_record_map_preserves_el_type(&mut delta);
                self.query_and_record_map_reflects_el_type(&mut delta);
                self.query_and_record_in_ker_rule(&mut delta);
                self.query_and_record_el_in_img_rule(&mut delta);
                self.query_and_record_pred_tuple_in_img_rule(&mut delta);
                self.query_and_record_func_app_in_img_rule(&mut delta);
                self.query_and_record_dom_cod_initiality_morphism(&mut delta);
                self.query_and_record_initiality_uniqueness(&mut delta);
                self.query_and_record_chain_transition_signature(&mut delta);
                self.query_and_record_type_decl_defines_symbol(&mut delta);
                self.query_and_record_pred_decl_defines_symbol(&mut delta);
                self.query_and_record_func_decl_defines_symbol(&mut delta);
                self.query_and_record_rule_decl_defines_symbol(&mut delta);
                self.query_and_record_arg_decl_should_be_type(&mut delta);
                self.query_and_record_var_atom_should_be_type(&mut delta);
                self.query_and_record_pred_if_atom_should_be_pred(&mut delta);
                self.query_and_record_pred_then_atom_should_be_pred(&mut delta);
                self.query_and_record_app_atom_should_be_func(&mut delta);
                self.query_and_record_type_list_len_nil(&mut delta);
                self.query_and_record_type_list_len_cons(&mut delta);
                self.query_and_record_term_list_len_nil(&mut delta);
                self.query_and_record_term_list_len_cons(&mut delta);
                self.query_and_record_pred_if_atom_arg_num_should_match(&mut delta);
                self.query_and_record_pred_then_atom_arg_num_should_match(&mut delta);
                self.query_and_record_app_term_arg_num_should_match(&mut delta);
                self.query_and_record_stmt_list_chain_nil(&mut delta);
                self.query_and_record_stmt_list_chain_cons(&mut delta);
                self.query_and_record_stmt_structure_chain(&mut delta);
                self.query_and_record_if_stmt_structure(&mut delta);
                self.query_and_record_then_stmt_structure(&mut delta);
                self.query_and_record_equal_if_atom_structure(&mut delta);
                self.query_and_record_defined_if_atom_structure(&mut delta);
                self.query_and_record_pred_if_atom_structure(&mut delta);
                self.query_and_record_var_if_atom_structure(&mut delta);
                self.query_and_record_equal_then_atom_structure(&mut delta);
                self.query_and_record_defined_then_atom_structure(&mut delta);
                self.query_and_record_pred_then_atom_structure(&mut delta);
                self.query_and_record_cons_term_list_structure(&mut delta);
                self.query_and_record_some_opt_term_structure(&mut delta);
                self.query_and_record_app_term_structure(&mut delta);
                self.query_and_record_semantic_els_nil(&mut delta);
                self.query_and_record_semantic_els_cons(&mut delta);
                self.query_and_record_semantic_el_struct(&mut delta);
                self.query_and_record_semantic_els_struct(&mut delta);
                self.query_and_record_app_term_semantics(&mut delta);
                self.query_and_record_var_term_semantics(&mut delta);
                self.query_and_record_wildcard_term_semantics(&mut delta);
                self.query_and_record_equal_if_atom_semantics(&mut delta);
                self.query_and_record_pred_if_atom_semantics(&mut delta);
                self.query_and_record_var_if_atom_semantics(&mut delta);
                self.query_and_record_equal_then_atom_semantics(&mut delta);
                self.query_and_record_defined_then_atom_semantics(&mut delta);
                self.query_and_record_pred_then_atom_semantics(&mut delta);
                self.query_and_record_grouped_rule_stmt_list_chain(&mut delta);
                self.query_and_record_grouped_stmt_list_chain_nil(&mut delta);
                self.query_and_record_grouped_chain_if_if(&mut delta);
                self.query_and_record_stmt_list_chain_then_then(&mut delta);
                self.query_and_record_stmt_list_chain_singleton(&mut delta);
                self.query_and_record_grouped_chain_if_then(&mut delta);
                self.query_and_record_grouped_chain_then_if(&mut delta);
                self.query_and_record_var_before_stmts_cons(&mut delta);
                self.query_and_record_var_before_stmt_if(&mut delta);
                self.query_and_record_var_before_stmt_then(&mut delta);
                self.query_and_record_var_before_if_atom_equal(&mut delta);
                self.query_and_record_var_before_if_atom_defined(&mut delta);
                self.query_and_record_var_before_if_atom_pred(&mut delta);
                self.query_and_record_var_before_if_atom_var(&mut delta);
                self.query_and_record_var_before_then_atom_equal(&mut delta);
                self.query_and_record_var_before_then_atom_defined(&mut delta);
                self.query_and_record_var_before_then_atom_pred(&mut delta);
                self.query_and_record_var_before_terms_cons(&mut delta);
                self.query_and_record_var_before_opt_term_some(&mut delta);
                self.query_and_record_var_before_term_app(&mut delta);
                self.query_and_record_var_in_term_var(&mut delta);
                self.query_and_record_var_in_term_wildcard(&mut delta);
                self.query_and_record_var_in_term_app(&mut delta);
                self.query_and_record_var_in_terms_cons_head(&mut delta);
                self.query_and_record_var_in_terms_cons_tail(&mut delta);
                self.query_and_record_var_in_opt_terms(&mut delta);
                self.query_and_record_var_in_if_atom_equal_lhs(&mut delta);
                self.query_and_record_var_in_if_atom_equal_rhs(&mut delta);
                self.query_and_record_var_in_if_atom_defined(&mut delta);
                self.query_and_record_var_in_if_atom_pred(&mut delta);
                self.query_and_record_var_in_if_atom_var(&mut delta);
                self.query_and_record_var_in_then_atom_equal_lhs(&mut delta);
                self.query_and_record_var_in_then_atom_equal_rhs(&mut delta);
                self.query_and_record_var_in_then_atom_defined_var_term(&mut delta);
                self.query_and_record_var_in_then_atom_defined_term(&mut delta);
                self.query_and_record_var_in_then_atom_pred(&mut delta);
                self.query_and_record_var_in_stmt_if(&mut delta);
                self.query_and_record_var_in_stmt_then(&mut delta);
                self.query_and_record_var_in_var_before(&mut delta);
                self.query_and_record_terms_should_be_epic_ok_cons(&mut delta);
                self.query_and_record_terms_should_be_epic_ok_app(&mut delta);
                self.query_and_record_then_atom_epic_ok_equal(&mut delta);
                self.query_and_record_then_atom_epic_ok_defined(&mut delta);
                self.query_and_record_then_atom_epic_ok_pred(&mut delta);
                self.query_and_record_then_stmt_surjective(&mut delta);
                self.query_and_record_cons_head_tail_terms_surjective_exempted(&mut delta);
                self.query_and_record_head_tail_cons_terms_surjective_exempted(&mut delta);
                self.query_and_record_subterms_surjective_exempted(&mut delta);
                self.query_and_record_defined_atom_surjective_exempted(&mut delta);
                self.query_and_record_semantic_el_exempted(&mut delta);
                self.query_and_record_surjective_codomain_should_be_ok(&mut delta);
                self.query_and_record_surjective_exempted_el_is_ok(&mut delta);
                self.query_and_record_surjective_img_el_is_ok(&mut delta);
                self.query_and_record_var_term_in_rule_child(&mut delta);
                self.query_and_record_after_then_should_be_if(&mut delta);

                self.retire_dirt();
                delta.apply(self);

                if condition(self) {
                    self.delta = Some(delta);
                    return true;
                }
                if !self.is_dirty() {
                    break;
                }
            }

            self.recall_previous_dirt();
            self.query_and_record_real_virt_ident_total(&mut delta);
            self.query_and_record_rule_child_term_total(&mut delta);
            self.query_and_record_rule_child_term_list_total(&mut delta);
            self.query_and_record_rule_child_opt_term_total(&mut delta);
            self.query_and_record_rule_child_if_atom_total(&mut delta);
            self.query_and_record_rule_child_then_atom_total(&mut delta);
            self.query_and_record_rule_child_stmt_total(&mut delta);
            self.query_and_record_rule_child_stmt_list_total(&mut delta);
            self.query_and_record_semantic_decl_type(&mut delta);
            self.query_and_record_semantic_arg_types_nil(&mut delta);
            self.query_and_record_semantic_arg_types_cons(&mut delta);
            self.query_and_record_semantic_decl_pred(&mut delta);
            self.query_and_record_semantic_decl_func(&mut delta);
            self.query_and_record_nil_el_types(&mut delta);
            self.query_and_record_cons_el_types(&mut delta);
            self.query_and_record_map_el_defined(&mut delta);
            self.query_and_record_map_els_defined(&mut delta);
            self.query_and_record_map_cons_els(&mut delta);
            self.query_and_record_initial_structure_total(&mut delta);
            self.query_and_record_initiality_morphism_total(&mut delta);
            self.query_and_record_chain_head_structure_defined(&mut delta);
            self.query_and_record_chain_head_transition_defined(&mut delta);
            self.query_and_record_138(&mut delta);
            self.query_and_record_type_list_len_total(&mut delta);
            self.query_and_record_term_list_len_total(&mut delta);
            self.query_and_record_rule_chain_total(&mut delta);
            self.query_and_record_rule_stmt_list_chain(&mut delta);
            self.query_and_record_stmt_list_chain_total(&mut delta);
            self.query_and_record_semantic_el_total(&mut delta);
            self.query_and_record_semantic_els_total(&mut delta);
            self.query_and_record_wildcard_virt_ident_defined(&mut delta);
            self.query_and_record_grouped_rule_chain_total(&mut delta);
            self.query_and_record_grouped_stmt_list_chain_total(&mut delta);
            self.drop_dirt();
            delta.apply(self);
            if condition(self) {
                self.delta = Some(delta);
                return true;
            }
        }

        self.delta = Some(delta);
        return false;
    }
    /// Adjoins a new element of sort `Ident`.
    #[allow(dead_code)]
    pub fn new_ident(&mut self) -> Ident {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_ident(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_ident(&mut self, lhs: Ident, rhs: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_ident_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Ident`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_ident(&self) -> impl '_ + Iterator<Item = Ident> {
        self.ident_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_ident(&self, el: Ident) -> Ident {
        if el.0 as usize >= self.ident_equalities.len() {
            el
        } else {
            self.ident_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_ident(&self, lhs: Ident, rhs: Ident) -> bool {
        self.root_ident(lhs) == self.root_ident(rhs)
    }

    /// Adjoins a new element of sort `VirtIdent`.
    #[allow(dead_code)]
    pub fn new_virt_ident(&mut self) -> VirtIdent {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_virt_ident(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_virt_ident(&mut self, lhs: VirtIdent, rhs: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_virt_ident_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `VirtIdent`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_virt_ident(&self) -> impl '_ + Iterator<Item = VirtIdent> {
        self.virt_ident_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_virt_ident(&self, el: VirtIdent) -> VirtIdent {
        if el.0 as usize >= self.virt_ident_equalities.len() {
            el
        } else {
            self.virt_ident_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_virt_ident(&self, lhs: VirtIdent, rhs: VirtIdent) -> bool {
        self.root_virt_ident(lhs) == self.root_virt_ident(rhs)
    }

    /// Adjoins a new element of sort `TypeDeclNode`.
    #[allow(dead_code)]
    pub fn new_type_decl_node(&mut self) -> TypeDeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_type_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type_decl_node(&mut self, lhs: TypeDeclNode, rhs: TypeDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `TypeDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type_decl_node(&self) -> impl '_ + Iterator<Item = TypeDeclNode> {
        self.type_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type_decl_node(&self, el: TypeDeclNode) -> TypeDeclNode {
        if el.0 as usize >= self.type_decl_node_equalities.len() {
            el
        } else {
            self.type_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type_decl_node(&self, lhs: TypeDeclNode, rhs: TypeDeclNode) -> bool {
        self.root_type_decl_node(lhs) == self.root_type_decl_node(rhs)
    }

    /// Adjoins a new element of sort `ArgDeclNode`.
    #[allow(dead_code)]
    pub fn new_arg_decl_node(&mut self) -> ArgDeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_arg_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_arg_decl_node(&mut self, lhs: ArgDeclNode, rhs: ArgDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `ArgDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_arg_decl_node(&self) -> impl '_ + Iterator<Item = ArgDeclNode> {
        self.arg_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_arg_decl_node(&self, el: ArgDeclNode) -> ArgDeclNode {
        if el.0 as usize >= self.arg_decl_node_equalities.len() {
            el
        } else {
            self.arg_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_arg_decl_node(&self, lhs: ArgDeclNode, rhs: ArgDeclNode) -> bool {
        self.root_arg_decl_node(lhs) == self.root_arg_decl_node(rhs)
    }

    /// Adjoins a new element of sort `ArgDeclListNode`.
    #[allow(dead_code)]
    pub fn new_arg_decl_list_node(&mut self) -> ArgDeclListNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_arg_decl_list_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_arg_decl_list_node(&mut self, lhs: ArgDeclListNode, rhs: ArgDeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_list_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `ArgDeclListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_arg_decl_list_node(&self) -> impl '_ + Iterator<Item = ArgDeclListNode> {
        self.arg_decl_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_arg_decl_list_node(&self, el: ArgDeclListNode) -> ArgDeclListNode {
        if el.0 as usize >= self.arg_decl_list_node_equalities.len() {
            el
        } else {
            self.arg_decl_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_arg_decl_list_node(&self, lhs: ArgDeclListNode, rhs: ArgDeclListNode) -> bool {
        self.root_arg_decl_list_node(lhs) == self.root_arg_decl_list_node(rhs)
    }

    /// Adjoins a new element of sort `PredDeclNode`.
    #[allow(dead_code)]
    pub fn new_pred_decl_node(&mut self) -> PredDeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_pred_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_pred_decl_node(&mut self, lhs: PredDeclNode, rhs: PredDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `PredDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_pred_decl_node(&self) -> impl '_ + Iterator<Item = PredDeclNode> {
        self.pred_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_pred_decl_node(&self, el: PredDeclNode) -> PredDeclNode {
        if el.0 as usize >= self.pred_decl_node_equalities.len() {
            el
        } else {
            self.pred_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_pred_decl_node(&self, lhs: PredDeclNode, rhs: PredDeclNode) -> bool {
        self.root_pred_decl_node(lhs) == self.root_pred_decl_node(rhs)
    }

    /// Adjoins a new element of sort `FuncDeclNode`.
    #[allow(dead_code)]
    pub fn new_func_decl_node(&mut self) -> FuncDeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_func_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_func_decl_node(&mut self, lhs: FuncDeclNode, rhs: FuncDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `FuncDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_func_decl_node(&self) -> impl '_ + Iterator<Item = FuncDeclNode> {
        self.func_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_func_decl_node(&self, el: FuncDeclNode) -> FuncDeclNode {
        if el.0 as usize >= self.func_decl_node_equalities.len() {
            el
        } else {
            self.func_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_func_decl_node(&self, lhs: FuncDeclNode, rhs: FuncDeclNode) -> bool {
        self.root_func_decl_node(lhs) == self.root_func_decl_node(rhs)
    }

    /// Adjoins a new element of sort `TermNode`.
    #[allow(dead_code)]
    pub fn new_term_node(&mut self) -> TermNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_term_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_term_node(&mut self, lhs: TermNode, rhs: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `TermNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_term_node(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.term_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_term_node(&self, el: TermNode) -> TermNode {
        if el.0 as usize >= self.term_node_equalities.len() {
            el
        } else {
            self.term_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_term_node(&self, lhs: TermNode, rhs: TermNode) -> bool {
        self.root_term_node(lhs) == self.root_term_node(rhs)
    }

    /// Adjoins a new element of sort `TermListNode`.
    #[allow(dead_code)]
    pub fn new_term_list_node(&mut self) -> TermListNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_term_list_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_term_list_node(&mut self, lhs: TermListNode, rhs: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_list_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `TermListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_term_list_node(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.term_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_term_list_node(&self, el: TermListNode) -> TermListNode {
        if el.0 as usize >= self.term_list_node_equalities.len() {
            el
        } else {
            self.term_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_term_list_node(&self, lhs: TermListNode, rhs: TermListNode) -> bool {
        self.root_term_list_node(lhs) == self.root_term_list_node(rhs)
    }

    /// Adjoins a new element of sort `OptTermNode`.
    #[allow(dead_code)]
    pub fn new_opt_term_node(&mut self) -> OptTermNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_opt_term_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_opt_term_node(&mut self, lhs: OptTermNode, rhs: OptTermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_opt_term_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `OptTermNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_opt_term_node(&self) -> impl '_ + Iterator<Item = OptTermNode> {
        self.opt_term_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_opt_term_node(&self, el: OptTermNode) -> OptTermNode {
        if el.0 as usize >= self.opt_term_node_equalities.len() {
            el
        } else {
            self.opt_term_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_opt_term_node(&self, lhs: OptTermNode, rhs: OptTermNode) -> bool {
        self.root_opt_term_node(lhs) == self.root_opt_term_node(rhs)
    }

    /// Adjoins a new element of sort `IfAtomNode`.
    #[allow(dead_code)]
    pub fn new_if_atom_node(&mut self) -> IfAtomNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_if_atom_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_if_atom_node(&mut self, lhs: IfAtomNode, rhs: IfAtomNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_if_atom_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `IfAtomNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_if_atom_node(&self) -> impl '_ + Iterator<Item = IfAtomNode> {
        self.if_atom_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_if_atom_node(&self, el: IfAtomNode) -> IfAtomNode {
        if el.0 as usize >= self.if_atom_node_equalities.len() {
            el
        } else {
            self.if_atom_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_if_atom_node(&self, lhs: IfAtomNode, rhs: IfAtomNode) -> bool {
        self.root_if_atom_node(lhs) == self.root_if_atom_node(rhs)
    }

    /// Adjoins a new element of sort `ThenAtomNode`.
    #[allow(dead_code)]
    pub fn new_then_atom_node(&mut self) -> ThenAtomNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_then_atom_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_then_atom_node(&mut self, lhs: ThenAtomNode, rhs: ThenAtomNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_then_atom_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `ThenAtomNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_then_atom_node(&self) -> impl '_ + Iterator<Item = ThenAtomNode> {
        self.then_atom_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_then_atom_node(&self, el: ThenAtomNode) -> ThenAtomNode {
        if el.0 as usize >= self.then_atom_node_equalities.len() {
            el
        } else {
            self.then_atom_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_then_atom_node(&self, lhs: ThenAtomNode, rhs: ThenAtomNode) -> bool {
        self.root_then_atom_node(lhs) == self.root_then_atom_node(rhs)
    }

    /// Adjoins a new element of sort `StmtNode`.
    #[allow(dead_code)]
    pub fn new_stmt_node(&mut self) -> StmtNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_stmt_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_stmt_node(&mut self, lhs: StmtNode, rhs: StmtNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `StmtNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_stmt_node(&self) -> impl '_ + Iterator<Item = StmtNode> {
        self.stmt_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_stmt_node(&self, el: StmtNode) -> StmtNode {
        if el.0 as usize >= self.stmt_node_equalities.len() {
            el
        } else {
            self.stmt_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_stmt_node(&self, lhs: StmtNode, rhs: StmtNode) -> bool {
        self.root_stmt_node(lhs) == self.root_stmt_node(rhs)
    }

    /// Adjoins a new element of sort `StmtListNode`.
    #[allow(dead_code)]
    pub fn new_stmt_list_node(&mut self) -> StmtListNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_stmt_list_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_stmt_list_node(&mut self, lhs: StmtListNode, rhs: StmtListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_list_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `StmtListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_stmt_list_node(&self) -> impl '_ + Iterator<Item = StmtListNode> {
        self.stmt_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_stmt_list_node(&self, el: StmtListNode) -> StmtListNode {
        if el.0 as usize >= self.stmt_list_node_equalities.len() {
            el
        } else {
            self.stmt_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_stmt_list_node(&self, lhs: StmtListNode, rhs: StmtListNode) -> bool {
        self.root_stmt_list_node(lhs) == self.root_stmt_list_node(rhs)
    }

    /// Adjoins a new element of sort `RuleDeclNode`.
    #[allow(dead_code)]
    pub fn new_rule_decl_node(&mut self) -> RuleDeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_rule_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_rule_decl_node(&mut self, lhs: RuleDeclNode, rhs: RuleDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `RuleDeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_rule_decl_node(&self) -> impl '_ + Iterator<Item = RuleDeclNode> {
        self.rule_decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_rule_decl_node(&self, el: RuleDeclNode) -> RuleDeclNode {
        if el.0 as usize >= self.rule_decl_node_equalities.len() {
            el
        } else {
            self.rule_decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_rule_decl_node(&self, lhs: RuleDeclNode, rhs: RuleDeclNode) -> bool {
        self.root_rule_decl_node(lhs) == self.root_rule_decl_node(rhs)
    }

    /// Adjoins a new element of sort `DeclNode`.
    #[allow(dead_code)]
    pub fn new_decl_node(&mut self) -> DeclNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_decl_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_decl_node(&mut self, lhs: DeclNode, rhs: DeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `DeclNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_decl_node(&self) -> impl '_ + Iterator<Item = DeclNode> {
        self.decl_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_decl_node(&self, el: DeclNode) -> DeclNode {
        if el.0 as usize >= self.decl_node_equalities.len() {
            el
        } else {
            self.decl_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_decl_node(&self, lhs: DeclNode, rhs: DeclNode) -> bool {
        self.root_decl_node(lhs) == self.root_decl_node(rhs)
    }

    /// Adjoins a new element of sort `DeclListNode`.
    #[allow(dead_code)]
    pub fn new_decl_list_node(&mut self) -> DeclListNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_decl_list_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_decl_list_node(&mut self, lhs: DeclListNode, rhs: DeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_list_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `DeclListNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_decl_list_node(&self) -> impl '_ + Iterator<Item = DeclListNode> {
        self.decl_list_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_decl_list_node(&self, el: DeclListNode) -> DeclListNode {
        if el.0 as usize >= self.decl_list_node_equalities.len() {
            el
        } else {
            self.decl_list_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_decl_list_node(&self, lhs: DeclListNode, rhs: DeclListNode) -> bool {
        self.root_decl_list_node(lhs) == self.root_decl_list_node(rhs)
    }

    /// Adjoins a new element of sort `ModuleNode`.
    #[allow(dead_code)]
    pub fn new_module_node(&mut self) -> ModuleNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_module_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_module_node(&mut self, lhs: ModuleNode, rhs: ModuleNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_module_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `ModuleNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_module_node(&self) -> impl '_ + Iterator<Item = ModuleNode> {
        self.module_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_module_node(&self, el: ModuleNode) -> ModuleNode {
        if el.0 as usize >= self.module_node_equalities.len() {
            el
        } else {
            self.module_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_module_node(&self, lhs: ModuleNode, rhs: ModuleNode) -> bool {
        self.root_module_node(lhs) == self.root_module_node(rhs)
    }

    /// Adjoins a new element of sort `Loc`.
    #[allow(dead_code)]
    pub fn new_loc(&mut self) -> Loc {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_loc(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_loc(&mut self, lhs: Loc, rhs: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_loc_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Loc`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_loc(&self) -> impl '_ + Iterator<Item = Loc> {
        self.loc_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_loc(&self, el: Loc) -> Loc {
        if el.0 as usize >= self.loc_equalities.len() {
            el
        } else {
            self.loc_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_loc(&self, lhs: Loc, rhs: Loc) -> bool {
        self.root_loc(lhs) == self.root_loc(rhs)
    }

    /// Adjoins a new element of sort `RuleChildNode`.
    #[allow(dead_code)]
    pub fn new_rule_child_node(&mut self) -> RuleChildNode {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_rule_child_node(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_rule_child_node(&mut self, lhs: RuleChildNode, rhs: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_node_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `RuleChildNode`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_rule_child_node(&self) -> impl '_ + Iterator<Item = RuleChildNode> {
        self.rule_child_node_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_rule_child_node(&self, el: RuleChildNode) -> RuleChildNode {
        if el.0 as usize >= self.rule_child_node_equalities.len() {
            el
        } else {
            self.rule_child_node_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_rule_child_node(&self, lhs: RuleChildNode, rhs: RuleChildNode) -> bool {
        self.root_rule_child_node(lhs) == self.root_rule_child_node(rhs)
    }

    /// Adjoins a new element of sort `Type`.
    #[allow(dead_code)]
    pub fn new_type(&mut self) -> Type {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_type(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type(&mut self, lhs: Type, rhs: Type) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Type`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type(&self) -> impl '_ + Iterator<Item = Type> {
        self.type_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type(&self, el: Type) -> Type {
        if el.0 as usize >= self.type_equalities.len() {
            el
        } else {
            self.type_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type(&self, lhs: Type, rhs: Type) -> bool {
        self.root_type(lhs) == self.root_type(rhs)
    }

    /// Adjoins a new element of sort `TypeList`.
    #[allow(dead_code)]
    pub fn new_type_list(&mut self) -> TypeList {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_type_list(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_type_list(&mut self, lhs: TypeList, rhs: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_list_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `TypeList`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_type_list(&self) -> impl '_ + Iterator<Item = TypeList> {
        self.type_list_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_type_list(&self, el: TypeList) -> TypeList {
        if el.0 as usize >= self.type_list_equalities.len() {
            el
        } else {
            self.type_list_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_type_list(&self, lhs: TypeList, rhs: TypeList) -> bool {
        self.root_type_list(lhs) == self.root_type_list(rhs)
    }

    /// Adjoins a new element of sort `Pred`.
    #[allow(dead_code)]
    pub fn new_pred(&mut self) -> Pred {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_pred(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_pred(&mut self, lhs: Pred, rhs: Pred) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Pred`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_pred(&self) -> impl '_ + Iterator<Item = Pred> {
        self.pred_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_pred(&self, el: Pred) -> Pred {
        if el.0 as usize >= self.pred_equalities.len() {
            el
        } else {
            self.pred_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_pred(&self, lhs: Pred, rhs: Pred) -> bool {
        self.root_pred(lhs) == self.root_pred(rhs)
    }

    /// Adjoins a new element of sort `Func`.
    #[allow(dead_code)]
    pub fn new_func(&mut self) -> Func {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_func(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_func(&mut self, lhs: Func, rhs: Func) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Func`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_func(&self) -> impl '_ + Iterator<Item = Func> {
        self.func_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_func(&self, el: Func) -> Func {
        if el.0 as usize >= self.func_equalities.len() {
            el
        } else {
            self.func_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_func(&self, lhs: Func, rhs: Func) -> bool {
        self.root_func(lhs) == self.root_func(rhs)
    }

    /// Adjoins a new element of sort `Structure`.
    #[allow(dead_code)]
    pub fn new_structure(&mut self) -> Structure {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_structure(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_structure(&mut self, lhs: Structure, rhs: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_structure_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Structure`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_structure(&self) -> impl '_ + Iterator<Item = Structure> {
        self.structure_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_structure(&self, el: Structure) -> Structure {
        if el.0 as usize >= self.structure_equalities.len() {
            el
        } else {
            self.structure_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_structure(&self, lhs: Structure, rhs: Structure) -> bool {
        self.root_structure(lhs) == self.root_structure(rhs)
    }

    /// Adjoins a new element of sort `El`.
    #[allow(dead_code)]
    pub fn new_el(&mut self) -> El {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_el(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_el(&mut self, lhs: El, rhs: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `El`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_el(&self) -> impl '_ + Iterator<Item = El> {
        self.el_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_el(&self, el: El) -> El {
        if el.0 as usize >= self.el_equalities.len() {
            el
        } else {
            self.el_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_el(&self, lhs: El, rhs: El) -> bool {
        self.root_el(lhs) == self.root_el(rhs)
    }

    /// Adjoins a new element of sort `ElList`.
    #[allow(dead_code)]
    pub fn new_el_list(&mut self) -> ElList {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_el_list(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_el_list(&mut self, lhs: ElList, rhs: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_list_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `ElList`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_el_list(&self) -> impl '_ + Iterator<Item = ElList> {
        self.el_list_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_el_list(&self, el: ElList) -> ElList {
        if el.0 as usize >= self.el_list_equalities.len() {
            el
        } else {
            self.el_list_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_el_list(&self, lhs: ElList, rhs: ElList) -> bool {
        self.root_el_list(lhs) == self.root_el_list(rhs)
    }

    /// Adjoins a new element of sort `Morphism`.
    #[allow(dead_code)]
    pub fn new_morphism(&mut self) -> Morphism {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_morphism(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_morphism(&mut self, lhs: Morphism, rhs: Morphism) {
        self.delta
            .as_mut()
            .unwrap()
            .new_morphism_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Morphism`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_morphism(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.morphism_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_morphism(&self, el: Morphism) -> Morphism {
        if el.0 as usize >= self.morphism_equalities.len() {
            el
        } else {
            self.morphism_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_morphism(&self, lhs: Morphism, rhs: Morphism) -> bool {
        self.root_morphism(lhs) == self.root_morphism(rhs)
    }

    /// Adjoins a new element of sort `Chain`.
    #[allow(dead_code)]
    pub fn new_chain(&mut self) -> Chain {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_chain(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_chain(&mut self, lhs: Chain, rhs: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_chain_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Chain`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_chain(&self) -> impl '_ + Iterator<Item = Chain> {
        self.chain_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_chain(&self, el: Chain) -> Chain {
        if el.0 as usize >= self.chain_equalities.len() {
            el
        } else {
            self.chain_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_chain(&self, lhs: Chain, rhs: Chain) -> bool {
        self.root_chain(lhs) == self.root_chain(rhs)
    }

    /// Adjoins a new element of sort `SymbolKind`.
    #[allow(dead_code)]
    pub fn new_symbol_kind(&mut self) -> SymbolKind {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_symbol_kind(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_symbol_kind(&mut self, lhs: SymbolKind, rhs: SymbolKind) {
        self.delta
            .as_mut()
            .unwrap()
            .new_symbol_kind_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `SymbolKind`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_symbol_kind(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.symbol_kind_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_symbol_kind(&self, el: SymbolKind) -> SymbolKind {
        if el.0 as usize >= self.symbol_kind_equalities.len() {
            el
        } else {
            self.symbol_kind_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_symbol_kind(&self, lhs: SymbolKind, rhs: SymbolKind) -> bool {
        self.root_symbol_kind(lhs) == self.root_symbol_kind(rhs)
    }

    /// Adjoins a new element of sort `Nat`.
    #[allow(dead_code)]
    pub fn new_nat(&mut self) -> Nat {
        let mut delta_opt = None;
        std::mem::swap(&mut delta_opt, &mut self.delta);
        let mut delta = delta_opt.unwrap();

        let el = delta.new_nat(self);

        self.delta = Some(delta);
        el
    }
    /// Enforces the equality `lhs = rhs`.
    #[allow(dead_code)]
    pub fn equate_nat(&mut self, lhs: Nat, rhs: Nat) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nat_equalities
            .push((lhs, rhs));
    }
    /// Returns and iterator over elements of sort `Nat`.
    /// The iterator yields canonical representatives only.
    #[allow(dead_code)]
    pub fn iter_nat(&self) -> impl '_ + Iterator<Item = Nat> {
        self.nat_all.iter().copied()
    }
    /// Returns the canonical representative of the equivalence class of `el`.
    #[allow(dead_code)]
    pub fn root_nat(&self, el: Nat) -> Nat {
        if el.0 as usize >= self.nat_equalities.len() {
            el
        } else {
            self.nat_equalities.root_const(el)
        }
    }
    /// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
    #[allow(dead_code)]
    pub fn are_equal_nat(&self, lhs: Nat, rhs: Nat) -> bool {
        self.root_nat(lhs) == self.root_nat(rhs)
    }

    /// Evaluates `real_virt_ident(arg0)`.
    #[allow(dead_code)]
    pub fn real_virt_ident(&self, mut arg0: Ident) -> Option<VirtIdent> {
        arg0 = self.root_ident(arg0);
        self.real_virt_ident.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `real_virt_ident(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_real_virt_ident(&mut self, mut arg0: Ident) -> VirtIdent {
        arg0 = self.root_ident(arg0);
        if let Some(t) = self.real_virt_ident.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_virt_ident();
        self.insert_real_virt_ident(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `real_virt_ident` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_real_virt_ident(&self) -> impl '_ + Iterator<Item = (Ident, VirtIdent)> {
        self.real_virt_ident.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `real_virt_ident(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_real_virt_ident(&mut self, arg0: Ident, result: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_real_virt_ident
            .push(RealVirtIdent(arg0, result));
    }

    /// Evaluates `rule_name(arg0)`.
    #[allow(dead_code)]
    pub fn rule_name(&self, mut arg0: RuleDeclNode) -> Option<Ident> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_name.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_name(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_name(&mut self, mut arg0: RuleDeclNode) -> Ident {
        arg0 = self.root_rule_decl_node(arg0);
        if let Some(t) = self.rule_name.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_ident();
        self.insert_rule_name(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_name` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_name(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Ident)> {
        self.rule_name.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_name(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_name(&mut self, arg0: RuleDeclNode, result: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_name
            .push(RuleName(arg0, result));
    }

    /// Evaluates `type_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn type_decl_node_loc(&self, mut arg0: TypeDeclNode) -> Option<Loc> {
        arg0 = self.root_type_decl_node(arg0);
        self.type_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `type_decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_decl_node_loc(&mut self, mut arg0: TypeDeclNode) -> Loc {
        arg0 = self.root_type_decl_node(arg0);
        if let Some(t) = self.type_decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_type_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `type_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_decl_node_loc(&self) -> impl '_ + Iterator<Item = (TypeDeclNode, Loc)> {
        self.type_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `type_decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_type_decl_node_loc(&mut self, arg0: TypeDeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_decl_node_loc
            .push(TypeDeclNodeLoc(arg0, result));
    }

    /// Evaluates `arg_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn arg_decl_node_loc(&self, mut arg0: ArgDeclNode) -> Option<Loc> {
        arg0 = self.root_arg_decl_node(arg0);
        self.arg_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `arg_decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_arg_decl_node_loc(&mut self, mut arg0: ArgDeclNode) -> Loc {
        arg0 = self.root_arg_decl_node(arg0);
        if let Some(t) = self.arg_decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_arg_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `arg_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_loc(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Loc)> {
        self.arg_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arg_decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_loc(&mut self, arg0: ArgDeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_node_loc
            .push(ArgDeclNodeLoc(arg0, result));
    }

    /// Evaluates `arg_decl_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn arg_decl_list_node_loc(&self, mut arg0: ArgDeclListNode) -> Option<Loc> {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.arg_decl_list_node_loc
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `arg_decl_list_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_arg_decl_list_node_loc(&mut self, mut arg0: ArgDeclListNode) -> Loc {
        arg0 = self.root_arg_decl_list_node(arg0);
        if let Some(t) = self.arg_decl_list_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_arg_decl_list_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `arg_decl_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arg_decl_list_node_loc(&self) -> impl '_ + Iterator<Item = (ArgDeclListNode, Loc)> {
        self.arg_decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arg_decl_list_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_list_node_loc(&mut self, arg0: ArgDeclListNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_list_node_loc
            .push(ArgDeclListNodeLoc(arg0, result));
    }

    /// Evaluates `pred_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn pred_decl_node_loc(&self, mut arg0: PredDeclNode) -> Option<Loc> {
        arg0 = self.root_pred_decl_node(arg0);
        self.pred_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `pred_decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_pred_decl_node_loc(&mut self, mut arg0: PredDeclNode) -> Loc {
        arg0 = self.root_pred_decl_node(arg0);
        if let Some(t) = self.pred_decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_pred_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `pred_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_decl_node_loc(&self) -> impl '_ + Iterator<Item = (PredDeclNode, Loc)> {
        self.pred_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `pred_decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_pred_decl_node_loc(&mut self, arg0: PredDeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_decl_node_loc
            .push(PredDeclNodeLoc(arg0, result));
    }

    /// Evaluates `func_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn func_decl_node_loc(&self, mut arg0: FuncDeclNode) -> Option<Loc> {
        arg0 = self.root_func_decl_node(arg0);
        self.func_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `func_decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_decl_node_loc(&mut self, mut arg0: FuncDeclNode) -> Loc {
        arg0 = self.root_func_decl_node(arg0);
        if let Some(t) = self.func_decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_func_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `func_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_decl_node_loc(&self) -> impl '_ + Iterator<Item = (FuncDeclNode, Loc)> {
        self.func_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `func_decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_func_decl_node_loc(&mut self, arg0: FuncDeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_decl_node_loc
            .push(FuncDeclNodeLoc(arg0, result));
    }

    /// Evaluates `term_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn term_node_loc(&self, mut arg0: TermNode) -> Option<Loc> {
        arg0 = self.root_term_node(arg0);
        self.term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `term_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_node_loc(&mut self, mut arg0: TermNode) -> Loc {
        arg0 = self.root_term_node(arg0);
        if let Some(t) = self.term_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_term_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `term_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_node_loc(&self) -> impl '_ + Iterator<Item = (TermNode, Loc)> {
        self.term_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_term_node_loc(&mut self, arg0: TermNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_node_loc
            .push(TermNodeLoc(arg0, result));
    }

    /// Evaluates `term_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn term_list_node_loc(&self, mut arg0: TermListNode) -> Option<Loc> {
        arg0 = self.root_term_list_node(arg0);
        self.term_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `term_list_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_list_node_loc(&mut self, mut arg0: TermListNode) -> Loc {
        arg0 = self.root_term_list_node(arg0);
        if let Some(t) = self.term_list_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_term_list_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `term_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_list_node_loc(&self) -> impl '_ + Iterator<Item = (TermListNode, Loc)> {
        self.term_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_list_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_term_list_node_loc(&mut self, arg0: TermListNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_list_node_loc
            .push(TermListNodeLoc(arg0, result));
    }

    /// Evaluates `opt_term_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn opt_term_node_loc(&self, mut arg0: OptTermNode) -> Option<Loc> {
        arg0 = self.root_opt_term_node(arg0);
        self.opt_term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `opt_term_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_opt_term_node_loc(&mut self, mut arg0: OptTermNode) -> Loc {
        arg0 = self.root_opt_term_node(arg0);
        if let Some(t) = self.opt_term_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_opt_term_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `opt_term_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_opt_term_node_loc(&self) -> impl '_ + Iterator<Item = (OptTermNode, Loc)> {
        self.opt_term_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `opt_term_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_opt_term_node_loc(&mut self, arg0: OptTermNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_opt_term_node_loc
            .push(OptTermNodeLoc(arg0, result));
    }

    /// Evaluates `if_atom_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn if_atom_node_loc(&self, mut arg0: IfAtomNode) -> Option<Loc> {
        arg0 = self.root_if_atom_node(arg0);
        self.if_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `if_atom_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_if_atom_node_loc(&mut self, mut arg0: IfAtomNode) -> Loc {
        arg0 = self.root_if_atom_node(arg0);
        if let Some(t) = self.if_atom_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_if_atom_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `if_atom_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_if_atom_node_loc(&self) -> impl '_ + Iterator<Item = (IfAtomNode, Loc)> {
        self.if_atom_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `if_atom_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_if_atom_node_loc(&mut self, arg0: IfAtomNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_if_atom_node_loc
            .push(IfAtomNodeLoc(arg0, result));
    }

    /// Evaluates `then_atom_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn then_atom_node_loc(&self, mut arg0: ThenAtomNode) -> Option<Loc> {
        arg0 = self.root_then_atom_node(arg0);
        self.then_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `then_atom_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_then_atom_node_loc(&mut self, mut arg0: ThenAtomNode) -> Loc {
        arg0 = self.root_then_atom_node(arg0);
        if let Some(t) = self.then_atom_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_then_atom_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `then_atom_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_then_atom_node_loc(&self) -> impl '_ + Iterator<Item = (ThenAtomNode, Loc)> {
        self.then_atom_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `then_atom_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_then_atom_node_loc(&mut self, arg0: ThenAtomNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_then_atom_node_loc
            .push(ThenAtomNodeLoc(arg0, result));
    }

    /// Evaluates `stmt_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_node_loc(&self, mut arg0: StmtNode) -> Option<Loc> {
        arg0 = self.root_stmt_node(arg0);
        self.stmt_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `stmt_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_node_loc(&mut self, mut arg0: StmtNode) -> Loc {
        arg0 = self.root_stmt_node(arg0);
        if let Some(t) = self.stmt_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_stmt_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `stmt_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_node_loc(&self) -> impl '_ + Iterator<Item = (StmtNode, Loc)> {
        self.stmt_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_node_loc(&mut self, arg0: StmtNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_node_loc
            .push(StmtNodeLoc(arg0, result));
    }

    /// Evaluates `stmt_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_list_node_loc(&self, mut arg0: StmtListNode) -> Option<Loc> {
        arg0 = self.root_stmt_list_node(arg0);
        self.stmt_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `stmt_list_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_list_node_loc(&mut self, mut arg0: StmtListNode) -> Loc {
        arg0 = self.root_stmt_list_node(arg0);
        if let Some(t) = self.stmt_list_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_stmt_list_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `stmt_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_list_node_loc(&self) -> impl '_ + Iterator<Item = (StmtListNode, Loc)> {
        self.stmt_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_list_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_list_node_loc(&mut self, arg0: StmtListNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_list_node_loc
            .push(StmtListNodeLoc(arg0, result));
    }

    /// Evaluates `rule_decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn rule_decl_node_loc(&self, mut arg0: RuleDeclNode) -> Option<Loc> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_decl_node_loc(&mut self, mut arg0: RuleDeclNode) -> Loc {
        arg0 = self.root_rule_decl_node(arg0);
        if let Some(t) = self.rule_decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_rule_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_decl_node_loc(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Loc)> {
        self.rule_decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_decl_node_loc(&mut self, arg0: RuleDeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_decl_node_loc
            .push(RuleDeclNodeLoc(arg0, result));
    }

    /// Evaluates `decl_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn decl_node_loc(&self, mut arg0: DeclNode) -> Option<Loc> {
        arg0 = self.root_decl_node(arg0);
        self.decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `decl_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_decl_node_loc(&mut self, mut arg0: DeclNode) -> Loc {
        arg0 = self.root_decl_node(arg0);
        if let Some(t) = self.decl_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_decl_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `decl_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_decl_node_loc(&self) -> impl '_ + Iterator<Item = (DeclNode, Loc)> {
        self.decl_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `decl_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_loc(&mut self, arg0: DeclNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_loc
            .push(DeclNodeLoc(arg0, result));
    }

    /// Evaluates `decl_list_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn decl_list_node_loc(&self, mut arg0: DeclListNode) -> Option<Loc> {
        arg0 = self.root_decl_list_node(arg0);
        self.decl_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `decl_list_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_decl_list_node_loc(&mut self, mut arg0: DeclListNode) -> Loc {
        arg0 = self.root_decl_list_node(arg0);
        if let Some(t) = self.decl_list_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_decl_list_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `decl_list_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_decl_list_node_loc(&self) -> impl '_ + Iterator<Item = (DeclListNode, Loc)> {
        self.decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `decl_list_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_decl_list_node_loc(&mut self, arg0: DeclListNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_list_node_loc
            .push(DeclListNodeLoc(arg0, result));
    }

    /// Evaluates `module_node_loc(arg0)`.
    #[allow(dead_code)]
    pub fn module_node_loc(&self, mut arg0: ModuleNode) -> Option<Loc> {
        arg0 = self.root_module_node(arg0);
        self.module_node_loc.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `module_node_loc(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_module_node_loc(&mut self, mut arg0: ModuleNode) -> Loc {
        arg0 = self.root_module_node(arg0);
        if let Some(t) = self.module_node_loc.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_loc();
        self.insert_module_node_loc(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `module_node_loc` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_module_node_loc(&self) -> impl '_ + Iterator<Item = (ModuleNode, Loc)> {
        self.module_node_loc.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `module_node_loc(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_module_node_loc(&mut self, arg0: ModuleNode, result: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_module_node_loc
            .push(ModuleNodeLoc(arg0, result));
    }

    /// Evaluates `rule_child_term(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_term(&self, mut arg0: TermNode) -> Option<RuleChildNode> {
        arg0 = self.root_term_node(arg0);
        self.rule_child_term.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_child_term(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_term(&mut self, mut arg0: TermNode) -> RuleChildNode {
        arg0 = self.root_term_node(arg0);
        if let Some(t) = self.rule_child_term.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_term(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_term` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_term(&self) -> impl '_ + Iterator<Item = (TermNode, RuleChildNode)> {
        self.rule_child_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_term(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_term(&mut self, arg0: TermNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_term
            .push(RuleChildTerm(arg0, result));
    }

    /// Evaluates `rule_child_term_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_term_list(&self, mut arg0: TermListNode) -> Option<RuleChildNode> {
        arg0 = self.root_term_list_node(arg0);
        self.rule_child_term_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `rule_child_term_list(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_term_list(&mut self, mut arg0: TermListNode) -> RuleChildNode {
        arg0 = self.root_term_list_node(arg0);
        if let Some(t) = self.rule_child_term_list.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_term_list(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_term_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_term_list(
        &self,
    ) -> impl '_ + Iterator<Item = (TermListNode, RuleChildNode)> {
        self.rule_child_term_list.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_term_list(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_term_list(&mut self, arg0: TermListNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_term_list
            .push(RuleChildTermList(arg0, result));
    }

    /// Evaluates `rule_child_opt_term(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_opt_term(&self, mut arg0: OptTermNode) -> Option<RuleChildNode> {
        arg0 = self.root_opt_term_node(arg0);
        self.rule_child_opt_term
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `rule_child_opt_term(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_opt_term(&mut self, mut arg0: OptTermNode) -> RuleChildNode {
        arg0 = self.root_opt_term_node(arg0);
        if let Some(t) = self.rule_child_opt_term.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_opt_term(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_opt_term` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_opt_term(
        &self,
    ) -> impl '_ + Iterator<Item = (OptTermNode, RuleChildNode)> {
        self.rule_child_opt_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_opt_term(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_opt_term(&mut self, arg0: OptTermNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_opt_term
            .push(RuleChildOptTerm(arg0, result));
    }

    /// Evaluates `rule_child_if_atom(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_if_atom(&self, mut arg0: IfAtomNode) -> Option<RuleChildNode> {
        arg0 = self.root_if_atom_node(arg0);
        self.rule_child_if_atom.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_child_if_atom(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_if_atom(&mut self, mut arg0: IfAtomNode) -> RuleChildNode {
        arg0 = self.root_if_atom_node(arg0);
        if let Some(t) = self.rule_child_if_atom.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_if_atom(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_if_atom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_if_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, RuleChildNode)> {
        self.rule_child_if_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_if_atom(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_if_atom(&mut self, arg0: IfAtomNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_if_atom
            .push(RuleChildIfAtom(arg0, result));
    }

    /// Evaluates `rule_child_then_atom(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_then_atom(&self, mut arg0: ThenAtomNode) -> Option<RuleChildNode> {
        arg0 = self.root_then_atom_node(arg0);
        self.rule_child_then_atom
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `rule_child_then_atom(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_then_atom(&mut self, mut arg0: ThenAtomNode) -> RuleChildNode {
        arg0 = self.root_then_atom_node(arg0);
        if let Some(t) = self.rule_child_then_atom.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_then_atom(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_then_atom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_then_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, RuleChildNode)> {
        self.rule_child_then_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_then_atom(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_then_atom(&mut self, arg0: ThenAtomNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_then_atom
            .push(RuleChildThenAtom(arg0, result));
    }

    /// Evaluates `rule_child_stmt(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_stmt(&self, mut arg0: StmtNode) -> Option<RuleChildNode> {
        arg0 = self.root_stmt_node(arg0);
        self.rule_child_stmt.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_child_stmt(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_stmt(&mut self, mut arg0: StmtNode) -> RuleChildNode {
        arg0 = self.root_stmt_node(arg0);
        if let Some(t) = self.rule_child_stmt.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_stmt(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_stmt` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_stmt(&self) -> impl '_ + Iterator<Item = (StmtNode, RuleChildNode)> {
        self.rule_child_stmt.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_stmt(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_stmt(&mut self, arg0: StmtNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_stmt
            .push(RuleChildStmt(arg0, result));
    }

    /// Evaluates `rule_child_stmt_list(arg0)`.
    #[allow(dead_code)]
    pub fn rule_child_stmt_list(&self, mut arg0: StmtListNode) -> Option<RuleChildNode> {
        arg0 = self.root_stmt_list_node(arg0);
        self.rule_child_stmt_list
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `rule_child_stmt_list(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_child_stmt_list(&mut self, mut arg0: StmtListNode) -> RuleChildNode {
        arg0 = self.root_stmt_list_node(arg0);
        if let Some(t) = self.rule_child_stmt_list.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_rule_child_node();
        self.insert_rule_child_stmt_list(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_child_stmt_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_child_stmt_list(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtListNode, RuleChildNode)> {
        self.rule_child_stmt_list.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_child_stmt_list(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child_stmt_list(&mut self, arg0: StmtListNode, result: RuleChildNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child_stmt_list
            .push(RuleChildStmtList(arg0, result));
    }

    /// Evaluates `nil_type_list()`.
    #[allow(dead_code)]
    pub fn nil_type_list(&self) -> Option<TypeList> {
        self.nil_type_list.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `nil_type_list()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_nil_type_list(&mut self) -> TypeList {
        if let Some(t) = self.nil_type_list.iter_all().next() {
            return t.0;
        }
        let result = self.new_type_list();
        self.insert_nil_type_list(result);
        result
    }
    /// Returns an iterator over `nil_type_list` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_nil_type_list(&self) -> impl '_ + Iterator<Item = TypeList> {
        self.nil_type_list.iter_all().map(|t| t.0)
    }
    /// Makes the equation `nil_type_list() = result` hold.

    #[allow(dead_code)]
    pub fn insert_nil_type_list(&mut self, result: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_type_list
            .push(NilTypeList(result));
    }

    /// Evaluates `cons_type_list(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn cons_type_list(&self, mut arg0: Type, mut arg1: TypeList) -> Option<TypeList> {
        arg0 = self.root_type(arg0);
        arg1 = self.root_type_list(arg1);
        self.cons_type_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Enforces that `cons_type_list(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cons_type_list(&mut self, mut arg0: Type, mut arg1: TypeList) -> TypeList {
        arg0 = self.root_type(arg0);
        arg1 = self.root_type_list(arg1);
        if let Some(t) = self.cons_type_list.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_type_list();
        self.insert_cons_type_list(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `cons_type_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cons_type_list(&self) -> impl '_ + Iterator<Item = (Type, TypeList, TypeList)> {
        self.cons_type_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `cons_type_list(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_cons_type_list(&mut self, arg0: Type, arg1: TypeList, result: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_type_list
            .push(ConsTypeList(arg0, arg1, result));
    }

    /// Evaluates `semantic_type(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_type(&self, mut arg0: Ident) -> Option<Type> {
        arg0 = self.root_ident(arg0);
        self.semantic_type.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_type(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_type(&mut self, mut arg0: Ident) -> Type {
        arg0 = self.root_ident(arg0);
        if let Some(t) = self.semantic_type.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_type();
        self.insert_semantic_type(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_type` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_type(&self) -> impl '_ + Iterator<Item = (Ident, Type)> {
        self.semantic_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_type(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_type(&mut self, arg0: Ident, result: Type) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_type
            .push(SemanticType(arg0, result));
    }

    /// Evaluates `semantic_arg_types(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_arg_types(&self, mut arg0: ArgDeclListNode) -> Option<TypeList> {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.semantic_arg_types.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_arg_types(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_arg_types(&mut self, mut arg0: ArgDeclListNode) -> TypeList {
        arg0 = self.root_arg_decl_list_node(arg0);
        if let Some(t) = self.semantic_arg_types.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_type_list();
        self.insert_semantic_arg_types(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_arg_types` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_arg_types(
        &self,
    ) -> impl '_ + Iterator<Item = (ArgDeclListNode, TypeList)> {
        self.semantic_arg_types.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_arg_types(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_arg_types(&mut self, arg0: ArgDeclListNode, result: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_arg_types
            .push(SemanticArgTypes(arg0, result));
    }

    /// Evaluates `semantic_pred(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_pred(&self, mut arg0: Ident) -> Option<Pred> {
        arg0 = self.root_ident(arg0);
        self.semantic_pred.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_pred(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_pred(&mut self, mut arg0: Ident) -> Pred {
        arg0 = self.root_ident(arg0);
        if let Some(t) = self.semantic_pred.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_pred();
        self.insert_semantic_pred(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_pred` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_pred(&self) -> impl '_ + Iterator<Item = (Ident, Pred)> {
        self.semantic_pred.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_pred(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_pred(&mut self, arg0: Ident, result: Pred) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_pred
            .push(SemanticPred(arg0, result));
    }

    /// Evaluates `arity(arg0)`.
    #[allow(dead_code)]
    pub fn arity(&self, mut arg0: Pred) -> Option<TypeList> {
        arg0 = self.root_pred(arg0);
        self.arity.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `arity(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_arity(&mut self, mut arg0: Pred) -> TypeList {
        arg0 = self.root_pred(arg0);
        if let Some(t) = self.arity.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_type_list();
        self.insert_arity(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `arity` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_arity(&self) -> impl '_ + Iterator<Item = (Pred, TypeList)> {
        self.arity.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `arity(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_arity(&mut self, arg0: Pred, result: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arity
            .push(Arity(arg0, result));
    }

    /// Evaluates `semantic_func(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_func(&self, mut arg0: Ident) -> Option<Func> {
        arg0 = self.root_ident(arg0);
        self.semantic_func.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_func(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_func(&mut self, mut arg0: Ident) -> Func {
        arg0 = self.root_ident(arg0);
        if let Some(t) = self.semantic_func.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_func();
        self.insert_semantic_func(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_func` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_func(&self) -> impl '_ + Iterator<Item = (Ident, Func)> {
        self.semantic_func.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_func(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_func(&mut self, arg0: Ident, result: Func) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_func
            .push(SemanticFunc(arg0, result));
    }

    /// Evaluates `domain(arg0)`.
    #[allow(dead_code)]
    pub fn domain(&self, mut arg0: Func) -> Option<TypeList> {
        arg0 = self.root_func(arg0);
        self.domain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `domain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_domain(&mut self, mut arg0: Func) -> TypeList {
        arg0 = self.root_func(arg0);
        if let Some(t) = self.domain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_type_list();
        self.insert_domain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `domain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_domain(&self) -> impl '_ + Iterator<Item = (Func, TypeList)> {
        self.domain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `domain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_domain(&mut self, arg0: Func, result: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_domain
            .push(Domain(arg0, result));
    }

    /// Evaluates `codomain(arg0)`.
    #[allow(dead_code)]
    pub fn codomain(&self, mut arg0: Func) -> Option<Type> {
        arg0 = self.root_func(arg0);
        self.codomain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `codomain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_codomain(&mut self, mut arg0: Func) -> Type {
        arg0 = self.root_func(arg0);
        if let Some(t) = self.codomain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_type();
        self.insert_codomain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `codomain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_codomain(&self) -> impl '_ + Iterator<Item = (Func, Type)> {
        self.codomain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `codomain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_codomain(&mut self, arg0: Func, result: Type) {
        self.delta
            .as_mut()
            .unwrap()
            .new_codomain
            .push(Codomain(arg0, result));
    }

    /// Evaluates `nil_el_list(arg0)`.
    #[allow(dead_code)]
    pub fn nil_el_list(&self, mut arg0: Structure) -> Option<ElList> {
        arg0 = self.root_structure(arg0);
        self.nil_el_list.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `nil_el_list(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_nil_el_list(&mut self, mut arg0: Structure) -> ElList {
        arg0 = self.root_structure(arg0);
        if let Some(t) = self.nil_el_list.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_el_list();
        self.insert_nil_el_list(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `nil_el_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_nil_el_list(&self) -> impl '_ + Iterator<Item = (Structure, ElList)> {
        self.nil_el_list.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `nil_el_list(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_nil_el_list(&mut self, arg0: Structure, result: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_el_list
            .push(NilElList(arg0, result));
    }

    /// Evaluates `cons_el_list(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn cons_el_list(&self, mut arg0: El, mut arg1: ElList) -> Option<ElList> {
        arg0 = self.root_el(arg0);
        arg1 = self.root_el_list(arg1);
        self.cons_el_list
            .iter_all_0_1(arg0, arg1)
            .next()
            .map(|t| t.2)
    }
    /// Enforces that `cons_el_list(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cons_el_list(&mut self, mut arg0: El, mut arg1: ElList) -> ElList {
        arg0 = self.root_el(arg0);
        arg1 = self.root_el_list(arg1);
        if let Some(t) = self.cons_el_list.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_el_list();
        self.insert_cons_el_list(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `cons_el_list` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cons_el_list(&self) -> impl '_ + Iterator<Item = (El, ElList, ElList)> {
        self.cons_el_list.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `cons_el_list(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_cons_el_list(&mut self, arg0: El, arg1: ElList, result: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_el_list
            .push(ConsElList(arg0, arg1, result));
    }

    /// Evaluates `func_app(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn func_app(&self, mut arg0: Func, mut arg1: ElList) -> Option<El> {
        arg0 = self.root_func(arg0);
        arg1 = self.root_el_list(arg1);
        self.func_app.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Enforces that `func_app(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_app(&mut self, mut arg0: Func, mut arg1: ElList) -> El {
        arg0 = self.root_func(arg0);
        arg1 = self.root_el_list(arg1);
        if let Some(t) = self.func_app.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_el();
        self.insert_func_app(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `func_app` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_app(&self) -> impl '_ + Iterator<Item = (Func, ElList, El)> {
        self.func_app.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `func_app(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_func_app(&mut self, arg0: Func, arg1: ElList, result: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_app
            .push(FuncApp(arg0, arg1, result));
    }

    /// Evaluates `var(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn var(&self, mut arg0: Structure, mut arg1: VirtIdent) -> Option<El> {
        arg0 = self.root_structure(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Enforces that `var(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_var(&mut self, mut arg0: Structure, mut arg1: VirtIdent) -> El {
        arg0 = self.root_structure(arg0);
        arg1 = self.root_virt_ident(arg1);
        if let Some(t) = self.var.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_el();
        self.insert_var(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `var` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_var(&self) -> impl '_ + Iterator<Item = (Structure, VirtIdent, El)> {
        self.var.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `var(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_var(&mut self, arg0: Structure, arg1: VirtIdent, result: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var
            .push(Var(arg0, arg1, result));
    }

    /// Evaluates `el_structure(arg0)`.
    #[allow(dead_code)]
    pub fn el_structure(&self, mut arg0: El) -> Option<Structure> {
        arg0 = self.root_el(arg0);
        self.el_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `el_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_el_structure(&mut self, mut arg0: El) -> Structure {
        arg0 = self.root_el(arg0);
        if let Some(t) = self.el_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_el_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `el_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_el_structure(&self) -> impl '_ + Iterator<Item = (El, Structure)> {
        self.el_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `el_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_el_structure(&mut self, arg0: El, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_structure
            .push(ElStructure(arg0, result));
    }

    /// Evaluates `els_structure(arg0)`.
    #[allow(dead_code)]
    pub fn els_structure(&self, mut arg0: ElList) -> Option<Structure> {
        arg0 = self.root_el_list(arg0);
        self.els_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `els_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_els_structure(&mut self, mut arg0: ElList) -> Structure {
        arg0 = self.root_el_list(arg0);
        if let Some(t) = self.els_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_els_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `els_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_els_structure(&self) -> impl '_ + Iterator<Item = (ElList, Structure)> {
        self.els_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `els_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_els_structure(&mut self, arg0: ElList, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_els_structure
            .push(ElsStructure(arg0, result));
    }

    /// Evaluates `dom(arg0)`.
    #[allow(dead_code)]
    pub fn dom(&self, mut arg0: Morphism) -> Option<Structure> {
        arg0 = self.root_morphism(arg0);
        self.dom.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `dom(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_dom(&mut self, mut arg0: Morphism) -> Structure {
        arg0 = self.root_morphism(arg0);
        if let Some(t) = self.dom.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_dom(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `dom` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_dom(&self) -> impl '_ + Iterator<Item = (Morphism, Structure)> {
        self.dom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `dom(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_dom(&mut self, arg0: Morphism, result: Structure) {
        self.delta.as_mut().unwrap().new_dom.push(Dom(arg0, result));
    }

    /// Evaluates `cod(arg0)`.
    #[allow(dead_code)]
    pub fn cod(&self, mut arg0: Morphism) -> Option<Structure> {
        arg0 = self.root_morphism(arg0);
        self.cod.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `cod(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_cod(&mut self, mut arg0: Morphism) -> Structure {
        arg0 = self.root_morphism(arg0);
        if let Some(t) = self.cod.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_cod(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `cod` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_cod(&self) -> impl '_ + Iterator<Item = (Morphism, Structure)> {
        self.cod.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `cod(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_cod(&mut self, arg0: Morphism, result: Structure) {
        self.delta.as_mut().unwrap().new_cod.push(Cod(arg0, result));
    }

    /// Evaluates `map_el(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn map_el(&self, mut arg0: Morphism, mut arg1: El) -> Option<El> {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        self.map_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Enforces that `map_el(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_map_el(&mut self, mut arg0: Morphism, mut arg1: El) -> El {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        if let Some(t) = self.map_el.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_el();
        self.insert_map_el(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `map_el` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_map_el(&self) -> impl '_ + Iterator<Item = (Morphism, El, El)> {
        self.map_el.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `map_el(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_map_el(&mut self, arg0: Morphism, arg1: El, result: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_map_el
            .push(MapEl(arg0, arg1, result));
    }

    /// Evaluates `map_els(arg0, arg1)`.
    #[allow(dead_code)]
    pub fn map_els(&self, mut arg0: Morphism, mut arg1: ElList) -> Option<ElList> {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el_list(arg1);
        self.map_els.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
    }
    /// Enforces that `map_els(arg0, arg1)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_map_els(&mut self, mut arg0: Morphism, mut arg1: ElList) -> ElList {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el_list(arg1);
        if let Some(t) = self.map_els.iter_all_0_1(arg0, arg1).next() {
            return t.2;
        }
        let result = self.new_el_list();
        self.insert_map_els(arg0, arg1, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `map_els` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_map_els(&self) -> impl '_ + Iterator<Item = (Morphism, ElList, ElList)> {
        self.map_els.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes the equation `map_els(arg0, arg1) = result` hold.

    #[allow(dead_code)]
    pub fn insert_map_els(&mut self, arg0: Morphism, arg1: ElList, result: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_map_els
            .push(MapEls(arg0, arg1, result));
    }

    /// Evaluates `initial_structure()`.
    #[allow(dead_code)]
    pub fn initial_structure(&self) -> Option<Structure> {
        self.initial_structure.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `initial_structure()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_initial_structure(&mut self) -> Structure {
        if let Some(t) = self.initial_structure.iter_all().next() {
            return t.0;
        }
        let result = self.new_structure();
        self.insert_initial_structure(result);
        result
    }
    /// Returns an iterator over `initial_structure` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_initial_structure(&self) -> impl '_ + Iterator<Item = Structure> {
        self.initial_structure.iter_all().map(|t| t.0)
    }
    /// Makes the equation `initial_structure() = result` hold.

    #[allow(dead_code)]
    pub fn insert_initial_structure(&mut self, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_initial_structure
            .push(InitialStructure(result));
    }

    /// Evaluates `initiality_morphism(arg0)`.
    #[allow(dead_code)]
    pub fn initiality_morphism(&self, mut arg0: Structure) -> Option<Morphism> {
        arg0 = self.root_structure(arg0);
        self.initiality_morphism
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `initiality_morphism(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_initiality_morphism(&mut self, mut arg0: Structure) -> Morphism {
        arg0 = self.root_structure(arg0);
        if let Some(t) = self.initiality_morphism.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_morphism();
        self.insert_initiality_morphism(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `initiality_morphism` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_initiality_morphism(&self) -> impl '_ + Iterator<Item = (Structure, Morphism)> {
        self.initiality_morphism.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `initiality_morphism(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_initiality_morphism(&mut self, arg0: Structure, result: Morphism) {
        self.delta
            .as_mut()
            .unwrap()
            .new_initiality_morphism
            .push(InitialityMorphism(arg0, result));
    }

    /// Evaluates `nil_chain()`.
    #[allow(dead_code)]
    pub fn nil_chain(&self) -> Option<Chain> {
        self.nil_chain.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `nil_chain()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_nil_chain(&mut self) -> Chain {
        if let Some(t) = self.nil_chain.iter_all().next() {
            return t.0;
        }
        let result = self.new_chain();
        self.insert_nil_chain(result);
        result
    }
    /// Returns an iterator over `nil_chain` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_nil_chain(&self) -> impl '_ + Iterator<Item = Chain> {
        self.nil_chain.iter_all().map(|t| t.0)
    }
    /// Makes the equation `nil_chain() = result` hold.

    #[allow(dead_code)]
    pub fn insert_nil_chain(&mut self, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_chain
            .push(NilChain(result));
    }

    /// Evaluates `chain_tail(arg0)`.
    #[allow(dead_code)]
    pub fn chain_tail(&self, mut arg0: Chain) -> Option<Chain> {
        arg0 = self.root_chain(arg0);
        self.chain_tail.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `chain_tail(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_chain_tail(&mut self, mut arg0: Chain) -> Chain {
        arg0 = self.root_chain(arg0);
        if let Some(t) = self.chain_tail.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_chain();
        self.insert_chain_tail(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `chain_tail` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_chain_tail(&self) -> impl '_ + Iterator<Item = (Chain, Chain)> {
        self.chain_tail.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `chain_tail(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_chain_tail(&mut self, arg0: Chain, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_chain_tail
            .push(ChainTail(arg0, result));
    }

    /// Evaluates `chain_head_structure(arg0)`.
    #[allow(dead_code)]
    pub fn chain_head_structure(&self, mut arg0: Chain) -> Option<Structure> {
        arg0 = self.root_chain(arg0);
        self.chain_head_structure
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `chain_head_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_chain_head_structure(&mut self, mut arg0: Chain) -> Structure {
        arg0 = self.root_chain(arg0);
        if let Some(t) = self.chain_head_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_chain_head_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `chain_head_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_chain_head_structure(&self) -> impl '_ + Iterator<Item = (Chain, Structure)> {
        self.chain_head_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `chain_head_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_chain_head_structure(&mut self, arg0: Chain, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_chain_head_structure
            .push(ChainHeadStructure(arg0, result));
    }

    /// Evaluates `chain_head_transition(arg0)`.
    #[allow(dead_code)]
    pub fn chain_head_transition(&self, mut arg0: Chain) -> Option<Morphism> {
        arg0 = self.root_chain(arg0);
        self.chain_head_transition
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `chain_head_transition(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_chain_head_transition(&mut self, mut arg0: Chain) -> Morphism {
        arg0 = self.root_chain(arg0);
        if let Some(t) = self.chain_head_transition.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_morphism();
        self.insert_chain_head_transition(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `chain_head_transition` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_chain_head_transition(&self) -> impl '_ + Iterator<Item = (Chain, Morphism)> {
        self.chain_head_transition.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `chain_head_transition(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_chain_head_transition(&mut self, arg0: Chain, result: Morphism) {
        self.delta
            .as_mut()
            .unwrap()
            .new_chain_head_transition
            .push(ChainHeadTransition(arg0, result));
    }

    /// Evaluates `type_symbol()`.
    #[allow(dead_code)]
    pub fn type_symbol(&self) -> Option<SymbolKind> {
        self.type_symbol.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `type_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_symbol(&mut self) -> SymbolKind {
        if let Some(t) = self.type_symbol.iter_all().next() {
            return t.0;
        }
        let result = self.new_symbol_kind();
        self.insert_type_symbol(result);
        result
    }
    /// Returns an iterator over `type_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.type_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `type_symbol() = result` hold.

    #[allow(dead_code)]
    pub fn insert_type_symbol(&mut self, result: SymbolKind) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_symbol
            .push(TypeSymbol(result));
    }

    /// Evaluates `pred_symbol()`.
    #[allow(dead_code)]
    pub fn pred_symbol(&self) -> Option<SymbolKind> {
        self.pred_symbol.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `pred_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_pred_symbol(&mut self) -> SymbolKind {
        if let Some(t) = self.pred_symbol.iter_all().next() {
            return t.0;
        }
        let result = self.new_symbol_kind();
        self.insert_pred_symbol(result);
        result
    }
    /// Returns an iterator over `pred_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_pred_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.pred_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `pred_symbol() = result` hold.

    #[allow(dead_code)]
    pub fn insert_pred_symbol(&mut self, result: SymbolKind) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_symbol
            .push(PredSymbol(result));
    }

    /// Evaluates `func_symbol()`.
    #[allow(dead_code)]
    pub fn func_symbol(&self) -> Option<SymbolKind> {
        self.func_symbol.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `func_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_func_symbol(&mut self) -> SymbolKind {
        if let Some(t) = self.func_symbol.iter_all().next() {
            return t.0;
        }
        let result = self.new_symbol_kind();
        self.insert_func_symbol(result);
        result
    }
    /// Returns an iterator over `func_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_func_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.func_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `func_symbol() = result` hold.

    #[allow(dead_code)]
    pub fn insert_func_symbol(&mut self, result: SymbolKind) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_symbol
            .push(FuncSymbol(result));
    }

    /// Evaluates `rule_symbol()`.
    #[allow(dead_code)]
    pub fn rule_symbol(&self) -> Option<SymbolKind> {
        self.rule_symbol.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `rule_symbol()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_symbol(&mut self) -> SymbolKind {
        if let Some(t) = self.rule_symbol.iter_all().next() {
            return t.0;
        }
        let result = self.new_symbol_kind();
        self.insert_rule_symbol(result);
        result
    }
    /// Returns an iterator over `rule_symbol` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_symbol(&self) -> impl '_ + Iterator<Item = SymbolKind> {
        self.rule_symbol.iter_all().map(|t| t.0)
    }
    /// Makes the equation `rule_symbol() = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_symbol(&mut self, result: SymbolKind) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_symbol
            .push(RuleSymbol(result));
    }

    /// Evaluates `zero()`.
    #[allow(dead_code)]
    pub fn zero(&self) -> Option<Nat> {
        self.zero.iter_all().next().map(|t| t.0)
    }
    /// Enforces that `zero()` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_zero(&mut self) -> Nat {
        if let Some(t) = self.zero.iter_all().next() {
            return t.0;
        }
        let result = self.new_nat();
        self.insert_zero(result);
        result
    }
    /// Returns an iterator over `zero` constants.
    /// The iterator may yield more than one element if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_zero(&self) -> impl '_ + Iterator<Item = Nat> {
        self.zero.iter_all().map(|t| t.0)
    }
    /// Makes the equation `zero() = result` hold.

    #[allow(dead_code)]
    pub fn insert_zero(&mut self, result: Nat) {
        self.delta.as_mut().unwrap().new_zero.push(Zero(result));
    }

    /// Evaluates `succ(arg0)`.
    #[allow(dead_code)]
    pub fn succ(&self, mut arg0: Nat) -> Option<Nat> {
        arg0 = self.root_nat(arg0);
        self.succ.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `succ(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_succ(&mut self, mut arg0: Nat) -> Nat {
        arg0 = self.root_nat(arg0);
        if let Some(t) = self.succ.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_nat();
        self.insert_succ(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `succ` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_succ(&self) -> impl '_ + Iterator<Item = (Nat, Nat)> {
        self.succ.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `succ(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_succ(&mut self, arg0: Nat, result: Nat) {
        self.delta
            .as_mut()
            .unwrap()
            .new_succ
            .push(Succ(arg0, result));
    }

    /// Evaluates `type_list_len(arg0)`.
    #[allow(dead_code)]
    pub fn type_list_len(&self, mut arg0: TypeList) -> Option<Nat> {
        arg0 = self.root_type_list(arg0);
        self.type_list_len.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `type_list_len(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_type_list_len(&mut self, mut arg0: TypeList) -> Nat {
        arg0 = self.root_type_list(arg0);
        if let Some(t) = self.type_list_len.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_nat();
        self.insert_type_list_len(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `type_list_len` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_type_list_len(&self) -> impl '_ + Iterator<Item = (TypeList, Nat)> {
        self.type_list_len.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `type_list_len(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_type_list_len(&mut self, arg0: TypeList, result: Nat) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_list_len
            .push(TypeListLen(arg0, result));
    }

    /// Evaluates `term_list_len(arg0)`.
    #[allow(dead_code)]
    pub fn term_list_len(&self, mut arg0: TermListNode) -> Option<Nat> {
        arg0 = self.root_term_list_node(arg0);
        self.term_list_len.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `term_list_len(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_list_len(&mut self, mut arg0: TermListNode) -> Nat {
        arg0 = self.root_term_list_node(arg0);
        if let Some(t) = self.term_list_len.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_nat();
        self.insert_term_list_len(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `term_list_len` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_list_len(&self) -> impl '_ + Iterator<Item = (TermListNode, Nat)> {
        self.term_list_len.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_list_len(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_term_list_len(&mut self, arg0: TermListNode, result: Nat) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_list_len
            .push(TermListLen(arg0, result));
    }

    /// Evaluates `rule_chain(arg0)`.
    #[allow(dead_code)]
    pub fn rule_chain(&self, mut arg0: RuleDeclNode) -> Option<Chain> {
        arg0 = self.root_rule_decl_node(arg0);
        self.rule_chain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `rule_chain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_rule_chain(&mut self, mut arg0: RuleDeclNode) -> Chain {
        arg0 = self.root_rule_decl_node(arg0);
        if let Some(t) = self.rule_chain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_chain();
        self.insert_rule_chain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `rule_chain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_rule_chain(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Chain)> {
        self.rule_chain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `rule_chain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_rule_chain(&mut self, arg0: RuleDeclNode, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_chain
            .push(RuleChain(arg0, result));
    }

    /// Evaluates `stmt_list_chain(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_list_chain(&self, mut arg0: StmtListNode) -> Option<Chain> {
        arg0 = self.root_stmt_list_node(arg0);
        self.stmt_list_chain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `stmt_list_chain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_list_chain(&mut self, mut arg0: StmtListNode) -> Chain {
        arg0 = self.root_stmt_list_node(arg0);
        if let Some(t) = self.stmt_list_chain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_chain();
        self.insert_stmt_list_chain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `stmt_list_chain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_list_chain(&self) -> impl '_ + Iterator<Item = (StmtListNode, Chain)> {
        self.stmt_list_chain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_list_chain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_list_chain(&mut self, arg0: StmtListNode, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_list_chain
            .push(StmtListChain(arg0, result));
    }

    /// Evaluates `stmt_structure(arg0)`.
    #[allow(dead_code)]
    pub fn stmt_structure(&self, mut arg0: StmtNode) -> Option<Structure> {
        arg0 = self.root_stmt_node(arg0);
        self.stmt_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `stmt_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_stmt_structure(&mut self, mut arg0: StmtNode) -> Structure {
        arg0 = self.root_stmt_node(arg0);
        if let Some(t) = self.stmt_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_stmt_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `stmt_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_stmt_structure(&self) -> impl '_ + Iterator<Item = (StmtNode, Structure)> {
        self.stmt_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `stmt_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_stmt_structure(&mut self, arg0: StmtNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_stmt_structure
            .push(StmtStructure(arg0, result));
    }

    /// Evaluates `if_atom_structure(arg0)`.
    #[allow(dead_code)]
    pub fn if_atom_structure(&self, mut arg0: IfAtomNode) -> Option<Structure> {
        arg0 = self.root_if_atom_node(arg0);
        self.if_atom_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `if_atom_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_if_atom_structure(&mut self, mut arg0: IfAtomNode) -> Structure {
        arg0 = self.root_if_atom_node(arg0);
        if let Some(t) = self.if_atom_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_if_atom_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `if_atom_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_if_atom_structure(&self) -> impl '_ + Iterator<Item = (IfAtomNode, Structure)> {
        self.if_atom_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `if_atom_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_if_atom_structure(&mut self, arg0: IfAtomNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_if_atom_structure
            .push(IfAtomStructure(arg0, result));
    }

    /// Evaluates `then_atom_structure(arg0)`.
    #[allow(dead_code)]
    pub fn then_atom_structure(&self, mut arg0: ThenAtomNode) -> Option<Structure> {
        arg0 = self.root_then_atom_node(arg0);
        self.then_atom_structure
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `then_atom_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_then_atom_structure(&mut self, mut arg0: ThenAtomNode) -> Structure {
        arg0 = self.root_then_atom_node(arg0);
        if let Some(t) = self.then_atom_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_then_atom_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `then_atom_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_then_atom_structure(&self) -> impl '_ + Iterator<Item = (ThenAtomNode, Structure)> {
        self.then_atom_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `then_atom_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_then_atom_structure(&mut self, arg0: ThenAtomNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_then_atom_structure
            .push(ThenAtomStructure(arg0, result));
    }

    /// Evaluates `term_structure(arg0)`.
    #[allow(dead_code)]
    pub fn term_structure(&self, mut arg0: TermNode) -> Option<Structure> {
        arg0 = self.root_term_node(arg0);
        self.term_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `term_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_term_structure(&mut self, mut arg0: TermNode) -> Structure {
        arg0 = self.root_term_node(arg0);
        if let Some(t) = self.term_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_term_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `term_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_term_structure(&self) -> impl '_ + Iterator<Item = (TermNode, Structure)> {
        self.term_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `term_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_term_structure(&mut self, arg0: TermNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_structure
            .push(TermStructure(arg0, result));
    }

    /// Evaluates `terms_structure(arg0)`.
    #[allow(dead_code)]
    pub fn terms_structure(&self, mut arg0: TermListNode) -> Option<Structure> {
        arg0 = self.root_term_list_node(arg0);
        self.terms_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `terms_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_terms_structure(&mut self, mut arg0: TermListNode) -> Structure {
        arg0 = self.root_term_list_node(arg0);
        if let Some(t) = self.terms_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_terms_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `terms_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_terms_structure(&self) -> impl '_ + Iterator<Item = (TermListNode, Structure)> {
        self.terms_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `terms_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_terms_structure(&mut self, arg0: TermListNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_terms_structure
            .push(TermsStructure(arg0, result));
    }

    /// Evaluates `opt_term_structure(arg0)`.
    #[allow(dead_code)]
    pub fn opt_term_structure(&self, mut arg0: OptTermNode) -> Option<Structure> {
        arg0 = self.root_opt_term_node(arg0);
        self.opt_term_structure.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `opt_term_structure(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_opt_term_structure(&mut self, mut arg0: OptTermNode) -> Structure {
        arg0 = self.root_opt_term_node(arg0);
        if let Some(t) = self.opt_term_structure.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_structure();
        self.insert_opt_term_structure(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `opt_term_structure` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_opt_term_structure(&self) -> impl '_ + Iterator<Item = (OptTermNode, Structure)> {
        self.opt_term_structure.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `opt_term_structure(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_opt_term_structure(&mut self, arg0: OptTermNode, result: Structure) {
        self.delta
            .as_mut()
            .unwrap()
            .new_opt_term_structure
            .push(OptTermStructure(arg0, result));
    }

    /// Evaluates `semantic_el(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_el(&self, mut arg0: TermNode) -> Option<El> {
        arg0 = self.root_term_node(arg0);
        self.semantic_el.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_el(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_el(&mut self, mut arg0: TermNode) -> El {
        arg0 = self.root_term_node(arg0);
        if let Some(t) = self.semantic_el.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_el();
        self.insert_semantic_el(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_el` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_el(&self) -> impl '_ + Iterator<Item = (TermNode, El)> {
        self.semantic_el.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_el(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_el(&mut self, arg0: TermNode, result: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_el
            .push(SemanticEl(arg0, result));
    }

    /// Evaluates `semantic_els(arg0)`.
    #[allow(dead_code)]
    pub fn semantic_els(&self, mut arg0: TermListNode) -> Option<ElList> {
        arg0 = self.root_term_list_node(arg0);
        self.semantic_els.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `semantic_els(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_semantic_els(&mut self, mut arg0: TermListNode) -> ElList {
        arg0 = self.root_term_list_node(arg0);
        if let Some(t) = self.semantic_els.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_el_list();
        self.insert_semantic_els(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `semantic_els` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_semantic_els(&self) -> impl '_ + Iterator<Item = (TermListNode, ElList)> {
        self.semantic_els.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `semantic_els(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_semantic_els(&mut self, arg0: TermListNode, result: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_semantic_els
            .push(SemanticEls(arg0, result));
    }

    /// Evaluates `wildcard_virt_ident(arg0)`.
    #[allow(dead_code)]
    pub fn wildcard_virt_ident(&self, mut arg0: TermNode) -> Option<VirtIdent> {
        arg0 = self.root_term_node(arg0);
        self.wildcard_virt_ident
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `wildcard_virt_ident(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_wildcard_virt_ident(&mut self, mut arg0: TermNode) -> VirtIdent {
        arg0 = self.root_term_node(arg0);
        if let Some(t) = self.wildcard_virt_ident.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_virt_ident();
        self.insert_wildcard_virt_ident(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `wildcard_virt_ident` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_wildcard_virt_ident(&self) -> impl '_ + Iterator<Item = (TermNode, VirtIdent)> {
        self.wildcard_virt_ident.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `wildcard_virt_ident(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_wildcard_virt_ident(&mut self, arg0: TermNode, result: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_wildcard_virt_ident
            .push(WildcardVirtIdent(arg0, result));
    }

    /// Evaluates `grouped_rule_chain(arg0)`.
    #[allow(dead_code)]
    pub fn grouped_rule_chain(&self, mut arg0: RuleDeclNode) -> Option<Chain> {
        arg0 = self.root_rule_decl_node(arg0);
        self.grouped_rule_chain.iter_all_0(arg0).next().map(|t| t.1)
    }
    /// Enforces that `grouped_rule_chain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_grouped_rule_chain(&mut self, mut arg0: RuleDeclNode) -> Chain {
        arg0 = self.root_rule_decl_node(arg0);
        if let Some(t) = self.grouped_rule_chain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_chain();
        self.insert_grouped_rule_chain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `grouped_rule_chain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_grouped_rule_chain(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, Chain)> {
        self.grouped_rule_chain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `grouped_rule_chain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_grouped_rule_chain(&mut self, arg0: RuleDeclNode, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_grouped_rule_chain
            .push(GroupedRuleChain(arg0, result));
    }

    /// Evaluates `grouped_stmt_list_chain(arg0)`.
    #[allow(dead_code)]
    pub fn grouped_stmt_list_chain(&self, mut arg0: StmtListNode) -> Option<Chain> {
        arg0 = self.root_stmt_list_node(arg0);
        self.grouped_stmt_list_chain
            .iter_all_0(arg0)
            .next()
            .map(|t| t.1)
    }
    /// Enforces that `grouped_stmt_list_chain(arg0)` is defined, adjoining a new element if necessary.
    #[allow(dead_code)]
    pub fn define_grouped_stmt_list_chain(&mut self, mut arg0: StmtListNode) -> Chain {
        arg0 = self.root_stmt_list_node(arg0);
        if let Some(t) = self.grouped_stmt_list_chain.iter_all_0(arg0).next() {
            return t.1;
        }
        let result = self.new_chain();
        self.insert_grouped_stmt_list_chain(arg0, result);
        result
    }
    /// Returns an iterator over tuples in the graph of the `grouped_stmt_list_chain` function.
    /// The relation yielded by the iterator need not be functional if the model is not closed.

    #[allow(dead_code)]
    pub fn iter_grouped_stmt_list_chain(&self) -> impl '_ + Iterator<Item = (StmtListNode, Chain)> {
        self.grouped_stmt_list_chain.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes the equation `grouped_stmt_list_chain(arg0) = result` hold.

    #[allow(dead_code)]
    pub fn insert_grouped_stmt_list_chain(&mut self, arg0: StmtListNode, result: Chain) {
        self.delta
            .as_mut()
            .unwrap()
            .new_grouped_stmt_list_chain
            .push(GroupedStmtListChain(arg0, result));
    }

    /// Returns `true` if `absurd()` holds.
    #[allow(dead_code)]
    pub fn absurd(&self) -> bool {
        self.absurd.contains(Absurd())
    }
    /// Makes `absurd()` hold.

    #[allow(dead_code)]
    pub fn insert_absurd(&mut self) {
        self.delta.as_mut().unwrap().new_absurd.push(Absurd());
    }

    /// Returns `true` if `type_decl(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn type_decl(&self, mut arg0: TypeDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_type_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.type_decl.contains(TypeDecl(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `type_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_type_decl(&self) -> impl '_ + Iterator<Item = (TypeDeclNode, Ident)> {
        self.type_decl.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `type_decl(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_type_decl(&mut self, arg0: TypeDeclNode, arg1: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_type_decl
            .push(TypeDecl(arg0, arg1));
    }

    /// Returns `true` if `arg_decl_node_name(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn arg_decl_node_name(&self, mut arg0: ArgDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_arg_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.arg_decl_node_name
            .contains(ArgDeclNodeName(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `arg_decl_node_name` predicate.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_name(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Ident)> {
        self.arg_decl_node_name.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `arg_decl_node_name(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_name(&mut self, arg0: ArgDeclNode, arg1: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_node_name
            .push(ArgDeclNodeName(arg0, arg1));
    }

    /// Returns `true` if `arg_decl_node_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn arg_decl_node_type(&self, mut arg0: ArgDeclNode, mut arg1: Ident) -> bool {
        arg0 = self.root_arg_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        self.arg_decl_node_type
            .contains(ArgDeclNodeType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `arg_decl_node_type` predicate.

    #[allow(dead_code)]
    pub fn iter_arg_decl_node_type(&self) -> impl '_ + Iterator<Item = (ArgDeclNode, Ident)> {
        self.arg_decl_node_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `arg_decl_node_type(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_arg_decl_node_type(&mut self, arg0: ArgDeclNode, arg1: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_arg_decl_node_type
            .push(ArgDeclNodeType(arg0, arg1));
    }

    /// Returns `true` if `nil_arg_decl_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_arg_decl_list_node(&self, mut arg0: ArgDeclListNode) -> bool {
        arg0 = self.root_arg_decl_list_node(arg0);
        self.nil_arg_decl_list_node
            .contains(NilArgDeclListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_arg_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_arg_decl_list_node(&self) -> impl '_ + Iterator<Item = ArgDeclListNode> {
        self.nil_arg_decl_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_arg_decl_list_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_arg_decl_list_node(&mut self, arg0: ArgDeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_arg_decl_list_node
            .push(NilArgDeclListNode(arg0));
    }

    /// Returns `true` if `cons_arg_decl_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_arg_decl_list_node(
        &self,
        mut arg0: ArgDeclListNode,
        mut arg1: ArgDeclNode,
        mut arg2: ArgDeclListNode,
    ) -> bool {
        arg0 = self.root_arg_decl_list_node(arg0);
        arg1 = self.root_arg_decl_node(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        self.cons_arg_decl_list_node
            .contains(ConsArgDeclListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_arg_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_arg_decl_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ArgDeclListNode, ArgDeclNode, ArgDeclListNode)> {
        self.cons_arg_decl_list_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_arg_decl_list_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_arg_decl_list_node(
        &mut self,
        arg0: ArgDeclListNode,
        arg1: ArgDeclNode,
        arg2: ArgDeclListNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_arg_decl_list_node
            .push(ConsArgDeclListNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `pred_decl(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_decl(
        &self,
        mut arg0: PredDeclNode,
        mut arg1: Ident,
        mut arg2: ArgDeclListNode,
    ) -> bool {
        arg0 = self.root_pred_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        self.pred_decl.contains(PredDecl(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (PredDeclNode, Ident, ArgDeclListNode)> {
        self.pred_decl.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_decl(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_decl(&mut self, arg0: PredDeclNode, arg1: Ident, arg2: ArgDeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_decl
            .push(PredDecl(arg0, arg1, arg2));
    }

    /// Returns `true` if `func_decl(arg0, arg1, arg2, arg3)` holds.
    #[allow(dead_code)]
    pub fn func_decl(
        &self,
        mut arg0: FuncDeclNode,
        mut arg1: Ident,
        mut arg2: ArgDeclListNode,
        mut arg3: Ident,
    ) -> bool {
        arg0 = self.root_func_decl_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_arg_decl_list_node(arg2);
        arg3 = self.root_ident(arg3);
        self.func_decl.contains(FuncDecl(arg0, arg1, arg2, arg3))
    }
    /// Returns an iterator over tuples of elements satisfying the `func_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_func_decl(
        &self,
    ) -> impl '_ + Iterator<Item = (FuncDeclNode, Ident, ArgDeclListNode, Ident)> {
        self.func_decl.iter_all().map(|t| (t.0, t.1, t.2, t.3))
    }
    /// Makes `func_decl(arg0, arg1, arg2, arg3)` hold.

    #[allow(dead_code)]
    pub fn insert_func_decl(
        &mut self,
        arg0: FuncDeclNode,
        arg1: Ident,
        arg2: ArgDeclListNode,
        arg3: Ident,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_decl
            .push(FuncDecl(arg0, arg1, arg2, arg3));
    }

    /// Returns `true` if `nil_term_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_term_list_node(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.nil_term_list_node.contains(NilTermListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_term_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_term_list_node(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.nil_term_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_term_list_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_term_list_node(&mut self, arg0: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_term_list_node
            .push(NilTermListNode(arg0));
    }

    /// Returns `true` if `cons_term_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_term_list_node(
        &self,
        mut arg0: TermListNode,
        mut arg1: TermNode,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.cons_term_list_node
            .contains(ConsTermListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_term_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_term_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (TermListNode, TermNode, TermListNode)> {
        self.cons_term_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_term_list_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_term_list_node(
        &mut self,
        arg0: TermListNode,
        arg1: TermNode,
        arg2: TermListNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_term_list_node
            .push(ConsTermListNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `none_term_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn none_term_node(&self, mut arg0: OptTermNode) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        self.none_term_node.contains(NoneTermNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `none_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_none_term_node(&self) -> impl '_ + Iterator<Item = OptTermNode> {
        self.none_term_node.iter_all().map(|t| t.0)
    }
    /// Makes `none_term_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_none_term_node(&mut self, arg0: OptTermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_none_term_node
            .push(NoneTermNode(arg0));
    }

    /// Returns `true` if `some_term_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn some_term_node(&self, mut arg0: OptTermNode, mut arg1: TermNode) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        arg1 = self.root_term_node(arg1);
        self.some_term_node.contains(SomeTermNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `some_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_some_term_node(&self) -> impl '_ + Iterator<Item = (OptTermNode, TermNode)> {
        self.some_term_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `some_term_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_some_term_node(&mut self, arg0: OptTermNode, arg1: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_some_term_node
            .push(SomeTermNode(arg0, arg1));
    }

    /// Returns `true` if `var_term_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_term_node(&self, mut arg0: TermNode, mut arg1: Ident) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_ident(arg1);
        self.var_term_node.contains(VarTermNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_var_term_node(&self) -> impl '_ + Iterator<Item = (TermNode, Ident)> {
        self.var_term_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_term_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_term_node(&mut self, arg0: TermNode, arg1: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_term_node
            .push(VarTermNode(arg0, arg1));
    }

    /// Returns `true` if `wildcard_term_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn wildcard_term_node(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.wildcard_term_node.contains(WildcardTermNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `wildcard_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_wildcard_term_node(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.wildcard_term_node.iter_all().map(|t| t.0)
    }
    /// Makes `wildcard_term_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_wildcard_term_node(&mut self, arg0: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_wildcard_term_node
            .push(WildcardTermNode(arg0));
    }

    /// Returns `true` if `app_term_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn app_term_node(
        &self,
        mut arg0: TermNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.app_term_node.contains(AppTermNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `app_term_node` predicate.

    #[allow(dead_code)]
    pub fn iter_app_term_node(&self) -> impl '_ + Iterator<Item = (TermNode, Ident, TermListNode)> {
        self.app_term_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `app_term_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_app_term_node(&mut self, arg0: TermNode, arg1: Ident, arg2: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_app_term_node
            .push(AppTermNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `equal_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn equal_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: TermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.equal_if_atom_node
            .contains(EqualIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `equal_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_equal_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode, TermNode)> {
        self.equal_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `equal_if_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_equal_if_atom_node(&mut self, arg0: IfAtomNode, arg1: TermNode, arg2: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_equal_if_atom_node
            .push(EqualIfAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `defined_if_atom_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn defined_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: TermNode) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        self.defined_if_atom_node
            .contains(DefinedIfAtomNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_if_atom_node(&self) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode)> {
        self.defined_if_atom_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `defined_if_atom_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_if_atom_node(&mut self, arg0: IfAtomNode, arg1: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_defined_if_atom_node
            .push(DefinedIfAtomNode(arg0, arg1));
    }

    /// Returns `true` if `pred_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.pred_if_atom_node
            .contains(PredIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, Ident, TermListNode)> {
        self.pred_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_if_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_if_atom_node(&mut self, arg0: IfAtomNode, arg1: Ident, arg2: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_if_atom_node
            .push(PredIfAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `var_if_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn var_if_atom_node(
        &self,
        mut arg0: IfAtomNode,
        mut arg1: TermNode,
        mut arg2: Ident,
    ) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_ident(arg2);
        self.var_if_atom_node
            .contains(VarIfAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_if_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_var_if_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (IfAtomNode, TermNode, Ident)> {
        self.var_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `var_if_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_var_if_atom_node(&mut self, arg0: IfAtomNode, arg1: TermNode, arg2: Ident) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_if_atom_node
            .push(VarIfAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `equal_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn equal_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: TermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.equal_then_atom_node
            .contains(EqualThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `equal_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_equal_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, TermNode, TermNode)> {
        self.equal_then_atom_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `equal_then_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_equal_then_atom_node(
        &mut self,
        arg0: ThenAtomNode,
        arg1: TermNode,
        arg2: TermNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_equal_then_atom_node
            .push(EqualThenAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `defined_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn defined_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: OptTermNode,
        mut arg2: TermNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_opt_term_node(arg1);
        arg2 = self.root_term_node(arg2);
        self.defined_then_atom_node
            .contains(DefinedThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, OptTermNode, TermNode)> {
        self.defined_then_atom_node
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `defined_then_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_then_atom_node(
        &mut self,
        arg0: ThenAtomNode,
        arg1: OptTermNode,
        arg2: TermNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_defined_then_atom_node
            .push(DefinedThenAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `pred_then_atom_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_then_atom_node(
        &self,
        mut arg0: ThenAtomNode,
        mut arg1: Ident,
        mut arg2: TermListNode,
    ) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_term_list_node(arg2);
        self.pred_then_atom_node
            .contains(PredThenAtomNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_then_atom_node` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_then_atom_node(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, Ident, TermListNode)> {
        self.pred_then_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_then_atom_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_then_atom_node(
        &mut self,
        arg0: ThenAtomNode,
        arg1: Ident,
        arg2: TermListNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_then_atom_node
            .push(PredThenAtomNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `if_stmt_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn if_stmt_node(&self, mut arg0: StmtNode, mut arg1: IfAtomNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_if_atom_node(arg1);
        self.if_stmt_node.contains(IfStmtNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `if_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_if_stmt_node(&self) -> impl '_ + Iterator<Item = (StmtNode, IfAtomNode)> {
        self.if_stmt_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `if_stmt_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_if_stmt_node(&mut self, arg0: StmtNode, arg1: IfAtomNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_if_stmt_node
            .push(IfStmtNode(arg0, arg1));
    }

    /// Returns `true` if `then_stmt_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn then_stmt_node(&self, mut arg0: StmtNode, mut arg1: ThenAtomNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_then_atom_node(arg1);
        self.then_stmt_node.contains(ThenStmtNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `then_stmt_node` predicate.

    #[allow(dead_code)]
    pub fn iter_then_stmt_node(&self) -> impl '_ + Iterator<Item = (StmtNode, ThenAtomNode)> {
        self.then_stmt_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `then_stmt_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_then_stmt_node(&mut self, arg0: StmtNode, arg1: ThenAtomNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_then_stmt_node
            .push(ThenStmtNode(arg0, arg1));
    }

    /// Returns `true` if `nil_stmt_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_stmt_list_node(&self, mut arg0: StmtListNode) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        self.nil_stmt_list_node.contains(NilStmtListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_stmt_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_stmt_list_node(&self) -> impl '_ + Iterator<Item = StmtListNode> {
        self.nil_stmt_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_stmt_list_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_stmt_list_node(&mut self, arg0: StmtListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_stmt_list_node
            .push(NilStmtListNode(arg0));
    }

    /// Returns `true` if `cons_stmt_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_stmt_list_node(
        &self,
        mut arg0: StmtListNode,
        mut arg1: StmtNode,
        mut arg2: StmtListNode,
    ) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        arg1 = self.root_stmt_node(arg1);
        arg2 = self.root_stmt_list_node(arg2);
        self.cons_stmt_list_node
            .contains(ConsStmtListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_stmt_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_stmt_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (StmtListNode, StmtNode, StmtListNode)> {
        self.cons_stmt_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_stmt_list_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_stmt_list_node(
        &mut self,
        arg0: StmtListNode,
        arg1: StmtNode,
        arg2: StmtListNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_stmt_list_node
            .push(ConsStmtListNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `rule_decl(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn rule_decl(&self, mut arg0: RuleDeclNode, mut arg1: StmtListNode) -> bool {
        arg0 = self.root_rule_decl_node(arg0);
        arg1 = self.root_stmt_list_node(arg1);
        self.rule_decl.contains(RuleDecl(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `rule_decl` predicate.

    #[allow(dead_code)]
    pub fn iter_rule_decl(&self) -> impl '_ + Iterator<Item = (RuleDeclNode, StmtListNode)> {
        self.rule_decl.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `rule_decl(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_rule_decl(&mut self, arg0: RuleDeclNode, arg1: StmtListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_decl
            .push(RuleDecl(arg0, arg1));
    }

    /// Returns `true` if `decl_node_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_type(&self, mut arg0: DeclNode, mut arg1: TypeDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_type_decl_node(arg1);
        self.decl_node_type.contains(DeclNodeType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_type` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_type(&self) -> impl '_ + Iterator<Item = (DeclNode, TypeDeclNode)> {
        self.decl_node_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_type(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_type(&mut self, arg0: DeclNode, arg1: TypeDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_type
            .push(DeclNodeType(arg0, arg1));
    }

    /// Returns `true` if `decl_node_pred(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_pred(&self, mut arg0: DeclNode, mut arg1: PredDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_pred_decl_node(arg1);
        self.decl_node_pred.contains(DeclNodePred(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_pred` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_pred(&self) -> impl '_ + Iterator<Item = (DeclNode, PredDeclNode)> {
        self.decl_node_pred.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_pred(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_pred(&mut self, arg0: DeclNode, arg1: PredDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_pred
            .push(DeclNodePred(arg0, arg1));
    }

    /// Returns `true` if `decl_node_func(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_func(&self, mut arg0: DeclNode, mut arg1: FuncDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_func_decl_node(arg1);
        self.decl_node_func.contains(DeclNodeFunc(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_func` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_func(&self) -> impl '_ + Iterator<Item = (DeclNode, FuncDeclNode)> {
        self.decl_node_func.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_func(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_func(&mut self, arg0: DeclNode, arg1: FuncDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_func
            .push(DeclNodeFunc(arg0, arg1));
    }

    /// Returns `true` if `decl_node_rule(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decl_node_rule(&self, mut arg0: DeclNode, mut arg1: RuleDeclNode) -> bool {
        arg0 = self.root_decl_node(arg0);
        arg1 = self.root_rule_decl_node(arg1);
        self.decl_node_rule.contains(DeclNodeRule(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decl_node_rule` predicate.

    #[allow(dead_code)]
    pub fn iter_decl_node_rule(&self) -> impl '_ + Iterator<Item = (DeclNode, RuleDeclNode)> {
        self.decl_node_rule.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decl_node_rule(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_decl_node_rule(&mut self, arg0: DeclNode, arg1: RuleDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decl_node_rule
            .push(DeclNodeRule(arg0, arg1));
    }

    /// Returns `true` if `nil_decl_list_node(arg0)` holds.
    #[allow(dead_code)]
    pub fn nil_decl_list_node(&self, mut arg0: DeclListNode) -> bool {
        arg0 = self.root_decl_list_node(arg0);
        self.nil_decl_list_node.contains(NilDeclListNode(arg0))
    }
    /// Returns an iterator over elements satisfying the `nil_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_nil_decl_list_node(&self) -> impl '_ + Iterator<Item = DeclListNode> {
        self.nil_decl_list_node.iter_all().map(|t| t.0)
    }
    /// Makes `nil_decl_list_node(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_nil_decl_list_node(&mut self, arg0: DeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_nil_decl_list_node
            .push(NilDeclListNode(arg0));
    }

    /// Returns `true` if `cons_decl_list_node(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn cons_decl_list_node(
        &self,
        mut arg0: DeclListNode,
        mut arg1: DeclNode,
        mut arg2: DeclListNode,
    ) -> bool {
        arg0 = self.root_decl_list_node(arg0);
        arg1 = self.root_decl_node(arg1);
        arg2 = self.root_decl_list_node(arg2);
        self.cons_decl_list_node
            .contains(ConsDeclListNode(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `cons_decl_list_node` predicate.

    #[allow(dead_code)]
    pub fn iter_cons_decl_list_node(
        &self,
    ) -> impl '_ + Iterator<Item = (DeclListNode, DeclNode, DeclListNode)> {
        self.cons_decl_list_node.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `cons_decl_list_node(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_cons_decl_list_node(
        &mut self,
        arg0: DeclListNode,
        arg1: DeclNode,
        arg2: DeclListNode,
    ) {
        self.delta
            .as_mut()
            .unwrap()
            .new_cons_decl_list_node
            .push(ConsDeclListNode(arg0, arg1, arg2));
    }

    /// Returns `true` if `decls_module_node(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn decls_module_node(&self, mut arg0: ModuleNode, mut arg1: DeclListNode) -> bool {
        arg0 = self.root_module_node(arg0);
        arg1 = self.root_decl_list_node(arg1);
        self.decls_module_node.contains(DeclsModuleNode(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `decls_module_node` predicate.

    #[allow(dead_code)]
    pub fn iter_decls_module_node(&self) -> impl '_ + Iterator<Item = (ModuleNode, DeclListNode)> {
        self.decls_module_node.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `decls_module_node(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_decls_module_node(&mut self, arg0: ModuleNode, arg1: DeclListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_decls_module_node
            .push(DeclsModuleNode(arg0, arg1));
    }

    /// Returns `true` if `rule_child(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn rule_child(&self, mut arg0: RuleChildNode, mut arg1: RuleDeclNode) -> bool {
        arg0 = self.root_rule_child_node(arg0);
        arg1 = self.root_rule_decl_node(arg1);
        self.rule_child.contains(RuleChild(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `rule_child` predicate.

    #[allow(dead_code)]
    pub fn iter_rule_child(&self) -> impl '_ + Iterator<Item = (RuleChildNode, RuleDeclNode)> {
        self.rule_child.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `rule_child(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_rule_child(&mut self, arg0: RuleChildNode, arg1: RuleDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_rule_child
            .push(RuleChild(arg0, arg1));
    }

    /// Returns `true` if `pred_app(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn pred_app(&self, mut arg0: Pred, mut arg1: ElList) -> bool {
        arg0 = self.root_pred(arg0);
        arg1 = self.root_el_list(arg1);
        self.pred_app.contains(PredApp(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_app` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_app(&self) -> impl '_ + Iterator<Item = (Pred, ElList)> {
        self.pred_app.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `pred_app(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_app(&mut self, arg0: Pred, arg1: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_app
            .push(PredApp(arg0, arg1));
    }

    /// Returns `true` if `el_type(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_type(&self, mut arg0: El, mut arg1: Type) -> bool {
        arg0 = self.root_el(arg0);
        arg1 = self.root_type(arg1);
        self.el_type.contains(ElType(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_type` predicate.

    #[allow(dead_code)]
    pub fn iter_el_type(&self) -> impl '_ + Iterator<Item = (El, Type)> {
        self.el_type.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_type(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_type(&mut self, arg0: El, arg1: Type) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_type
            .push(ElType(arg0, arg1));
    }

    /// Returns `true` if `el_types(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_types(&self, mut arg0: ElList, mut arg1: TypeList) -> bool {
        arg0 = self.root_el_list(arg0);
        arg1 = self.root_type_list(arg1);
        self.el_types.contains(ElTypes(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_types` predicate.

    #[allow(dead_code)]
    pub fn iter_el_types(&self) -> impl '_ + Iterator<Item = (ElList, TypeList)> {
        self.el_types.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_types(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_types(&mut self, arg0: ElList, arg1: TypeList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_types
            .push(ElTypes(arg0, arg1));
    }

    /// Returns `true` if `constrained_el(arg0)` holds.
    #[allow(dead_code)]
    pub fn constrained_el(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.constrained_el.contains(ConstrainedEl(arg0))
    }
    /// Returns an iterator over elements satisfying the `constrained_el` predicate.

    #[allow(dead_code)]
    pub fn iter_constrained_el(&self) -> impl '_ + Iterator<Item = El> {
        self.constrained_el.iter_all().map(|t| t.0)
    }
    /// Makes `constrained_el(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_constrained_el(&mut self, arg0: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_constrained_el
            .push(ConstrainedEl(arg0));
    }

    /// Returns `true` if `constrained_els(arg0)` holds.
    #[allow(dead_code)]
    pub fn constrained_els(&self, mut arg0: ElList) -> bool {
        arg0 = self.root_el_list(arg0);
        self.constrained_els.contains(ConstrainedEls(arg0))
    }
    /// Returns an iterator over elements satisfying the `constrained_els` predicate.

    #[allow(dead_code)]
    pub fn iter_constrained_els(&self) -> impl '_ + Iterator<Item = ElList> {
        self.constrained_els.iter_all().map(|t| t.0)
    }
    /// Makes `constrained_els(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_constrained_els(&mut self, arg0: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_constrained_els
            .push(ConstrainedEls(arg0));
    }

    /// Returns `true` if `in_ker(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn in_ker(&self, mut arg0: Morphism, mut arg1: El, mut arg2: El) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        arg2 = self.root_el(arg2);
        self.in_ker.contains(InKer(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `in_ker` predicate.

    #[allow(dead_code)]
    pub fn iter_in_ker(&self) -> impl '_ + Iterator<Item = (Morphism, El, El)> {
        self.in_ker.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `in_ker(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_in_ker(&mut self, arg0: Morphism, arg1: El, arg2: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_in_ker
            .push(InKer(arg0, arg1, arg2));
    }

    /// Returns `true` if `el_in_img(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn el_in_img(&self, mut arg0: Morphism, mut arg1: El) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_el(arg1);
        self.el_in_img.contains(ElInImg(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `el_in_img` predicate.

    #[allow(dead_code)]
    pub fn iter_el_in_img(&self) -> impl '_ + Iterator<Item = (Morphism, El)> {
        self.el_in_img.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `el_in_img(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_el_in_img(&mut self, arg0: Morphism, arg1: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_in_img
            .push(ElInImg(arg0, arg1));
    }

    /// Returns `true` if `pred_tuple_in_img(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_tuple_in_img(&self, mut arg0: Morphism, mut arg1: Pred, mut arg2: ElList) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_pred(arg1);
        arg2 = self.root_el_list(arg2);
        self.pred_tuple_in_img
            .contains(PredTupleInImg(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_tuple_in_img` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_tuple_in_img(&self) -> impl '_ + Iterator<Item = (Morphism, Pred, ElList)> {
        self.pred_tuple_in_img.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_tuple_in_img(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_tuple_in_img(&mut self, arg0: Morphism, arg1: Pred, arg2: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_tuple_in_img
            .push(PredTupleInImg(arg0, arg1, arg2));
    }

    /// Returns `true` if `func_app_in_img(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn func_app_in_img(&self, mut arg0: Morphism, mut arg1: Func, mut arg2: ElList) -> bool {
        arg0 = self.root_morphism(arg0);
        arg1 = self.root_func(arg1);
        arg2 = self.root_el_list(arg2);
        self.func_app_in_img
            .contains(FuncAppInImg(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `func_app_in_img` predicate.

    #[allow(dead_code)]
    pub fn iter_func_app_in_img(&self) -> impl '_ + Iterator<Item = (Morphism, Func, ElList)> {
        self.func_app_in_img.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `func_app_in_img(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_func_app_in_img(&mut self, arg0: Morphism, arg1: Func, arg2: ElList) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_app_in_img
            .push(FuncAppInImg(arg0, arg1, arg2));
    }

    /// Returns `true` if `defined_symbol(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn defined_symbol(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: Loc) -> bool {
        arg0 = self.root_ident(arg0);
        arg1 = self.root_symbol_kind(arg1);
        arg2 = self.root_loc(arg2);
        self.defined_symbol
            .contains(DefinedSymbol(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `defined_symbol` predicate.

    #[allow(dead_code)]
    pub fn iter_defined_symbol(&self) -> impl '_ + Iterator<Item = (Ident, SymbolKind, Loc)> {
        self.defined_symbol.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `defined_symbol(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_defined_symbol(&mut self, arg0: Ident, arg1: SymbolKind, arg2: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_defined_symbol
            .push(DefinedSymbol(arg0, arg1, arg2));
    }

    /// Returns `true` if `should_be_symbol(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn should_be_symbol(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: Loc) -> bool {
        arg0 = self.root_ident(arg0);
        arg1 = self.root_symbol_kind(arg1);
        arg2 = self.root_loc(arg2);
        self.should_be_symbol
            .contains(ShouldBeSymbol(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `should_be_symbol` predicate.

    #[allow(dead_code)]
    pub fn iter_should_be_symbol(&self) -> impl '_ + Iterator<Item = (Ident, SymbolKind, Loc)> {
        self.should_be_symbol.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `should_be_symbol(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_should_be_symbol(&mut self, arg0: Ident, arg1: SymbolKind, arg2: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_should_be_symbol
            .push(ShouldBeSymbol(arg0, arg1, arg2));
    }

    /// Returns `true` if `pred_arg_num_should_match(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn pred_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
        arg0 = self.root_nat(arg0);
        arg1 = self.root_nat(arg1);
        arg2 = self.root_loc(arg2);
        self.pred_arg_num_should_match
            .contains(PredArgNumShouldMatch(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `pred_arg_num_should_match` predicate.

    #[allow(dead_code)]
    pub fn iter_pred_arg_num_should_match(&self) -> impl '_ + Iterator<Item = (Nat, Nat, Loc)> {
        self.pred_arg_num_should_match
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `pred_arg_num_should_match(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_pred_arg_num_should_match(&mut self, arg0: Nat, arg1: Nat, arg2: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_pred_arg_num_should_match
            .push(PredArgNumShouldMatch(arg0, arg1, arg2));
    }

    /// Returns `true` if `func_arg_num_should_match(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn func_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
        arg0 = self.root_nat(arg0);
        arg1 = self.root_nat(arg1);
        arg2 = self.root_loc(arg2);
        self.func_arg_num_should_match
            .contains(FuncArgNumShouldMatch(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `func_arg_num_should_match` predicate.

    #[allow(dead_code)]
    pub fn iter_func_arg_num_should_match(&self) -> impl '_ + Iterator<Item = (Nat, Nat, Loc)> {
        self.func_arg_num_should_match
            .iter_all()
            .map(|t| (t.0, t.1, t.2))
    }
    /// Makes `func_arg_num_should_match(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_func_arg_num_should_match(&mut self, arg0: Nat, arg1: Nat, arg2: Loc) {
        self.delta
            .as_mut()
            .unwrap()
            .new_func_arg_num_should_match
            .push(FuncArgNumShouldMatch(arg0, arg1, arg2));
    }

    /// Returns `true` if `var_before_term(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_term(&self, mut arg0: TermNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_term.contains(VarBeforeTerm(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_term` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_term(&self) -> impl '_ + Iterator<Item = (TermNode, VirtIdent)> {
        self.var_before_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_term(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_term(&mut self, arg0: TermNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_term
            .push(VarBeforeTerm(arg0, arg1));
    }

    /// Returns `true` if `var_before_terms(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_terms(&self, mut arg0: TermListNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_terms.contains(VarBeforeTerms(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_terms` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_terms(&self) -> impl '_ + Iterator<Item = (TermListNode, VirtIdent)> {
        self.var_before_terms.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_terms(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_terms(&mut self, arg0: TermListNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_terms
            .push(VarBeforeTerms(arg0, arg1));
    }

    /// Returns `true` if `var_before_opt_term(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_opt_term(&self, mut arg0: OptTermNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_opt_term
            .contains(VarBeforeOptTerm(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_opt_term` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_opt_term(&self) -> impl '_ + Iterator<Item = (OptTermNode, VirtIdent)> {
        self.var_before_opt_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_opt_term(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_opt_term(&mut self, arg0: OptTermNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_opt_term
            .push(VarBeforeOptTerm(arg0, arg1));
    }

    /// Returns `true` if `var_before_if_atom(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_if_atom(&self, mut arg0: IfAtomNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_if_atom
            .contains(VarBeforeIfAtom(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_if_atom` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_if_atom(&self) -> impl '_ + Iterator<Item = (IfAtomNode, VirtIdent)> {
        self.var_before_if_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_if_atom(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_if_atom(&mut self, arg0: IfAtomNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_if_atom
            .push(VarBeforeIfAtom(arg0, arg1));
    }

    /// Returns `true` if `var_before_then_atom(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_then_atom(&self, mut arg0: ThenAtomNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_then_atom
            .contains(VarBeforeThenAtom(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_then_atom` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_then_atom(
        &self,
    ) -> impl '_ + Iterator<Item = (ThenAtomNode, VirtIdent)> {
        self.var_before_then_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_then_atom(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_then_atom(&mut self, arg0: ThenAtomNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_then_atom
            .push(VarBeforeThenAtom(arg0, arg1));
    }

    /// Returns `true` if `var_before_stmt(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_stmt(&self, mut arg0: StmtNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_stmt.contains(VarBeforeStmt(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_stmt` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_stmt(&self) -> impl '_ + Iterator<Item = (StmtNode, VirtIdent)> {
        self.var_before_stmt.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_stmt(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_stmt(&mut self, arg0: StmtNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_stmt
            .push(VarBeforeStmt(arg0, arg1));
    }

    /// Returns `true` if `var_before_stmts(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_before_stmts(&self, mut arg0: StmtListNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_stmt_list_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_before_stmts.contains(VarBeforeStmts(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_before_stmts` predicate.

    #[allow(dead_code)]
    pub fn iter_var_before_stmts(&self) -> impl '_ + Iterator<Item = (StmtListNode, VirtIdent)> {
        self.var_before_stmts.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_before_stmts(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_before_stmts(&mut self, arg0: StmtListNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_before_stmts
            .push(VarBeforeStmts(arg0, arg1));
    }

    /// Returns `true` if `var_in_term(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_term(&self, mut arg0: TermNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_term.contains(VarInTerm(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_term` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_term(&self) -> impl '_ + Iterator<Item = (TermNode, VirtIdent)> {
        self.var_in_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_term(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_term(&mut self, arg0: TermNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_term
            .push(VarInTerm(arg0, arg1));
    }

    /// Returns `true` if `var_in_terms(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_terms(&self, mut arg0: TermListNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_term_list_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_terms.contains(VarInTerms(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_terms` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_terms(&self) -> impl '_ + Iterator<Item = (TermListNode, VirtIdent)> {
        self.var_in_terms.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_terms(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_terms(&mut self, arg0: TermListNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_terms
            .push(VarInTerms(arg0, arg1));
    }

    /// Returns `true` if `var_in_opt_term(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_opt_term(&self, mut arg0: OptTermNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_opt_term_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_opt_term.contains(VarInOptTerm(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_opt_term` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_opt_term(&self) -> impl '_ + Iterator<Item = (OptTermNode, VirtIdent)> {
        self.var_in_opt_term.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_opt_term(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_opt_term(&mut self, arg0: OptTermNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_opt_term
            .push(VarInOptTerm(arg0, arg1));
    }

    /// Returns `true` if `var_in_if_atom(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_if_atom(&self, mut arg0: IfAtomNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_if_atom_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_if_atom.contains(VarInIfAtom(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_if_atom` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_if_atom(&self) -> impl '_ + Iterator<Item = (IfAtomNode, VirtIdent)> {
        self.var_in_if_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_if_atom(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_if_atom(&mut self, arg0: IfAtomNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_if_atom
            .push(VarInIfAtom(arg0, arg1));
    }

    /// Returns `true` if `var_in_then_atom(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_then_atom(&self, mut arg0: ThenAtomNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_then_atom_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_then_atom.contains(VarInThenAtom(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_then_atom` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_then_atom(&self) -> impl '_ + Iterator<Item = (ThenAtomNode, VirtIdent)> {
        self.var_in_then_atom.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_then_atom(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_then_atom(&mut self, arg0: ThenAtomNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_then_atom
            .push(VarInThenAtom(arg0, arg1));
    }

    /// Returns `true` if `var_in_stmt(arg0, arg1)` holds.
    #[allow(dead_code)]
    pub fn var_in_stmt(&self, mut arg0: StmtNode, mut arg1: VirtIdent) -> bool {
        arg0 = self.root_stmt_node(arg0);
        arg1 = self.root_virt_ident(arg1);
        self.var_in_stmt.contains(VarInStmt(arg0, arg1))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_in_stmt` predicate.

    #[allow(dead_code)]
    pub fn iter_var_in_stmt(&self) -> impl '_ + Iterator<Item = (StmtNode, VirtIdent)> {
        self.var_in_stmt.iter_all().map(|t| (t.0, t.1))
    }
    /// Makes `var_in_stmt(arg0, arg1)` hold.

    #[allow(dead_code)]
    pub fn insert_var_in_stmt(&mut self, arg0: StmtNode, arg1: VirtIdent) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_in_stmt
            .push(VarInStmt(arg0, arg1));
    }

    /// Returns `true` if `term_should_be_epic_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn term_should_be_epic_ok(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.term_should_be_epic_ok
            .contains(TermShouldBeEpicOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `term_should_be_epic_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_term_should_be_epic_ok(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.term_should_be_epic_ok.iter_all().map(|t| t.0)
    }
    /// Makes `term_should_be_epic_ok(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_term_should_be_epic_ok(&mut self, arg0: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_should_be_epic_ok
            .push(TermShouldBeEpicOk(arg0));
    }

    /// Returns `true` if `terms_should_be_epic_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn terms_should_be_epic_ok(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.terms_should_be_epic_ok
            .contains(TermsShouldBeEpicOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `terms_should_be_epic_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_terms_should_be_epic_ok(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.terms_should_be_epic_ok.iter_all().map(|t| t.0)
    }
    /// Makes `terms_should_be_epic_ok(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_terms_should_be_epic_ok(&mut self, arg0: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_terms_should_be_epic_ok
            .push(TermsShouldBeEpicOk(arg0));
    }

    /// Returns `true` if `should_be_surjective(arg0)` holds.
    #[allow(dead_code)]
    pub fn should_be_surjective(&self, mut arg0: Morphism) -> bool {
        arg0 = self.root_morphism(arg0);
        self.should_be_surjective.contains(ShouldBeSurjective(arg0))
    }
    /// Returns an iterator over elements satisfying the `should_be_surjective` predicate.

    #[allow(dead_code)]
    pub fn iter_should_be_surjective(&self) -> impl '_ + Iterator<Item = Morphism> {
        self.should_be_surjective.iter_all().map(|t| t.0)
    }
    /// Makes `should_be_surjective(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_should_be_surjective(&mut self, arg0: Morphism) {
        self.delta
            .as_mut()
            .unwrap()
            .new_should_be_surjective
            .push(ShouldBeSurjective(arg0));
    }

    /// Returns `true` if `term_surjective_exempted(arg0)` holds.
    #[allow(dead_code)]
    pub fn term_surjective_exempted(&self, mut arg0: TermNode) -> bool {
        arg0 = self.root_term_node(arg0);
        self.term_surjective_exempted
            .contains(TermSurjectiveExempted(arg0))
    }
    /// Returns an iterator over elements satisfying the `term_surjective_exempted` predicate.

    #[allow(dead_code)]
    pub fn iter_term_surjective_exempted(&self) -> impl '_ + Iterator<Item = TermNode> {
        self.term_surjective_exempted.iter_all().map(|t| t.0)
    }
    /// Makes `term_surjective_exempted(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_term_surjective_exempted(&mut self, arg0: TermNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_term_surjective_exempted
            .push(TermSurjectiveExempted(arg0));
    }

    /// Returns `true` if `terms_surjective_exempted(arg0)` holds.
    #[allow(dead_code)]
    pub fn terms_surjective_exempted(&self, mut arg0: TermListNode) -> bool {
        arg0 = self.root_term_list_node(arg0);
        self.terms_surjective_exempted
            .contains(TermsSurjectiveExempted(arg0))
    }
    /// Returns an iterator over elements satisfying the `terms_surjective_exempted` predicate.

    #[allow(dead_code)]
    pub fn iter_terms_surjective_exempted(&self) -> impl '_ + Iterator<Item = TermListNode> {
        self.terms_surjective_exempted.iter_all().map(|t| t.0)
    }
    /// Makes `terms_surjective_exempted(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_terms_surjective_exempted(&mut self, arg0: TermListNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_terms_surjective_exempted
            .push(TermsSurjectiveExempted(arg0));
    }

    /// Returns `true` if `el_surjective_exempted(arg0)` holds.
    #[allow(dead_code)]
    pub fn el_surjective_exempted(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.el_surjective_exempted
            .contains(ElSurjectiveExempted(arg0))
    }
    /// Returns an iterator over elements satisfying the `el_surjective_exempted` predicate.

    #[allow(dead_code)]
    pub fn iter_el_surjective_exempted(&self) -> impl '_ + Iterator<Item = El> {
        self.el_surjective_exempted.iter_all().map(|t| t.0)
    }
    /// Makes `el_surjective_exempted(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_el_surjective_exempted(&mut self, arg0: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_surjective_exempted
            .push(ElSurjectiveExempted(arg0));
    }

    /// Returns `true` if `el_should_be_surjective_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn el_should_be_surjective_ok(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.el_should_be_surjective_ok
            .contains(ElShouldBeSurjectiveOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `el_should_be_surjective_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_el_should_be_surjective_ok(&self) -> impl '_ + Iterator<Item = El> {
        self.el_should_be_surjective_ok.iter_all().map(|t| t.0)
    }
    /// Makes `el_should_be_surjective_ok(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_el_should_be_surjective_ok(&mut self, arg0: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_should_be_surjective_ok
            .push(ElShouldBeSurjectiveOk(arg0));
    }

    /// Returns `true` if `el_is_surjective_ok(arg0)` holds.
    #[allow(dead_code)]
    pub fn el_is_surjective_ok(&self, mut arg0: El) -> bool {
        arg0 = self.root_el(arg0);
        self.el_is_surjective_ok.contains(ElIsSurjectiveOk(arg0))
    }
    /// Returns an iterator over elements satisfying the `el_is_surjective_ok` predicate.

    #[allow(dead_code)]
    pub fn iter_el_is_surjective_ok(&self) -> impl '_ + Iterator<Item = El> {
        self.el_is_surjective_ok.iter_all().map(|t| t.0)
    }
    /// Makes `el_is_surjective_ok(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_el_is_surjective_ok(&mut self, arg0: El) {
        self.delta
            .as_mut()
            .unwrap()
            .new_el_is_surjective_ok
            .push(ElIsSurjectiveOk(arg0));
    }

    /// Returns `true` if `var_term_in_rule(arg0, arg1, arg2)` holds.
    #[allow(dead_code)]
    pub fn var_term_in_rule(
        &self,
        mut arg0: TermNode,
        mut arg1: Ident,
        mut arg2: RuleDeclNode,
    ) -> bool {
        arg0 = self.root_term_node(arg0);
        arg1 = self.root_ident(arg1);
        arg2 = self.root_rule_decl_node(arg2);
        self.var_term_in_rule
            .contains(VarTermInRule(arg0, arg1, arg2))
    }
    /// Returns an iterator over tuples of elements satisfying the `var_term_in_rule` predicate.

    #[allow(dead_code)]
    pub fn iter_var_term_in_rule(
        &self,
    ) -> impl '_ + Iterator<Item = (TermNode, Ident, RuleDeclNode)> {
        self.var_term_in_rule.iter_all().map(|t| (t.0, t.1, t.2))
    }
    /// Makes `var_term_in_rule(arg0, arg1, arg2)` hold.

    #[allow(dead_code)]
    pub fn insert_var_term_in_rule(&mut self, arg0: TermNode, arg1: Ident, arg2: RuleDeclNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_var_term_in_rule
            .push(VarTermInRule(arg0, arg1, arg2));
    }

    /// Returns `true` if `if_after_then(arg0)` holds.
    #[allow(dead_code)]
    pub fn if_after_then(&self, mut arg0: StmtNode) -> bool {
        arg0 = self.root_stmt_node(arg0);
        self.if_after_then.contains(IfAfterThen(arg0))
    }
    /// Returns an iterator over elements satisfying the `if_after_then` predicate.

    #[allow(dead_code)]
    pub fn iter_if_after_then(&self) -> impl '_ + Iterator<Item = StmtNode> {
        self.if_after_then.iter_all().map(|t| t.0)
    }
    /// Makes `if_after_then(arg0)` hold.

    #[allow(dead_code)]
    pub fn insert_if_after_then(&mut self, arg0: StmtNode) {
        self.delta
            .as_mut()
            .unwrap()
            .new_if_after_then
            .push(IfAfterThen(arg0));
    }

    fn is_dirty(&self) -> bool {
        self.empty_join_is_dirty
            || self.absurd.is_dirty()
            || self.type_decl.is_dirty()
            || self.arg_decl_node_name.is_dirty()
            || self.arg_decl_node_type.is_dirty()
            || self.nil_arg_decl_list_node.is_dirty()
            || self.cons_arg_decl_list_node.is_dirty()
            || self.pred_decl.is_dirty()
            || self.func_decl.is_dirty()
            || self.nil_term_list_node.is_dirty()
            || self.cons_term_list_node.is_dirty()
            || self.none_term_node.is_dirty()
            || self.some_term_node.is_dirty()
            || self.var_term_node.is_dirty()
            || self.wildcard_term_node.is_dirty()
            || self.app_term_node.is_dirty()
            || self.equal_if_atom_node.is_dirty()
            || self.defined_if_atom_node.is_dirty()
            || self.pred_if_atom_node.is_dirty()
            || self.var_if_atom_node.is_dirty()
            || self.equal_then_atom_node.is_dirty()
            || self.defined_then_atom_node.is_dirty()
            || self.pred_then_atom_node.is_dirty()
            || self.if_stmt_node.is_dirty()
            || self.then_stmt_node.is_dirty()
            || self.nil_stmt_list_node.is_dirty()
            || self.cons_stmt_list_node.is_dirty()
            || self.rule_decl.is_dirty()
            || self.decl_node_type.is_dirty()
            || self.decl_node_pred.is_dirty()
            || self.decl_node_func.is_dirty()
            || self.decl_node_rule.is_dirty()
            || self.nil_decl_list_node.is_dirty()
            || self.cons_decl_list_node.is_dirty()
            || self.decls_module_node.is_dirty()
            || self.rule_child.is_dirty()
            || self.pred_app.is_dirty()
            || self.el_type.is_dirty()
            || self.el_types.is_dirty()
            || self.constrained_el.is_dirty()
            || self.constrained_els.is_dirty()
            || self.in_ker.is_dirty()
            || self.el_in_img.is_dirty()
            || self.pred_tuple_in_img.is_dirty()
            || self.func_app_in_img.is_dirty()
            || self.defined_symbol.is_dirty()
            || self.should_be_symbol.is_dirty()
            || self.pred_arg_num_should_match.is_dirty()
            || self.func_arg_num_should_match.is_dirty()
            || self.var_before_term.is_dirty()
            || self.var_before_terms.is_dirty()
            || self.var_before_opt_term.is_dirty()
            || self.var_before_if_atom.is_dirty()
            || self.var_before_then_atom.is_dirty()
            || self.var_before_stmt.is_dirty()
            || self.var_before_stmts.is_dirty()
            || self.var_in_term.is_dirty()
            || self.var_in_terms.is_dirty()
            || self.var_in_opt_term.is_dirty()
            || self.var_in_if_atom.is_dirty()
            || self.var_in_then_atom.is_dirty()
            || self.var_in_stmt.is_dirty()
            || self.term_should_be_epic_ok.is_dirty()
            || self.terms_should_be_epic_ok.is_dirty()
            || self.should_be_surjective.is_dirty()
            || self.term_surjective_exempted.is_dirty()
            || self.terms_surjective_exempted.is_dirty()
            || self.el_surjective_exempted.is_dirty()
            || self.el_should_be_surjective_ok.is_dirty()
            || self.el_is_surjective_ok.is_dirty()
            || self.var_term_in_rule.is_dirty()
            || self.if_after_then.is_dirty()
            || self.real_virt_ident.is_dirty()
            || self.rule_name.is_dirty()
            || self.type_decl_node_loc.is_dirty()
            || self.arg_decl_node_loc.is_dirty()
            || self.arg_decl_list_node_loc.is_dirty()
            || self.pred_decl_node_loc.is_dirty()
            || self.func_decl_node_loc.is_dirty()
            || self.term_node_loc.is_dirty()
            || self.term_list_node_loc.is_dirty()
            || self.opt_term_node_loc.is_dirty()
            || self.if_atom_node_loc.is_dirty()
            || self.then_atom_node_loc.is_dirty()
            || self.stmt_node_loc.is_dirty()
            || self.stmt_list_node_loc.is_dirty()
            || self.rule_decl_node_loc.is_dirty()
            || self.decl_node_loc.is_dirty()
            || self.decl_list_node_loc.is_dirty()
            || self.module_node_loc.is_dirty()
            || self.rule_child_term.is_dirty()
            || self.rule_child_term_list.is_dirty()
            || self.rule_child_opt_term.is_dirty()
            || self.rule_child_if_atom.is_dirty()
            || self.rule_child_then_atom.is_dirty()
            || self.rule_child_stmt.is_dirty()
            || self.rule_child_stmt_list.is_dirty()
            || self.nil_type_list.is_dirty()
            || self.cons_type_list.is_dirty()
            || self.semantic_type.is_dirty()
            || self.semantic_arg_types.is_dirty()
            || self.semantic_pred.is_dirty()
            || self.arity.is_dirty()
            || self.semantic_func.is_dirty()
            || self.domain.is_dirty()
            || self.codomain.is_dirty()
            || self.nil_el_list.is_dirty()
            || self.cons_el_list.is_dirty()
            || self.func_app.is_dirty()
            || self.var.is_dirty()
            || self.el_structure.is_dirty()
            || self.els_structure.is_dirty()
            || self.dom.is_dirty()
            || self.cod.is_dirty()
            || self.map_el.is_dirty()
            || self.map_els.is_dirty()
            || self.initial_structure.is_dirty()
            || self.initiality_morphism.is_dirty()
            || self.nil_chain.is_dirty()
            || self.chain_tail.is_dirty()
            || self.chain_head_structure.is_dirty()
            || self.chain_head_transition.is_dirty()
            || self.type_symbol.is_dirty()
            || self.pred_symbol.is_dirty()
            || self.func_symbol.is_dirty()
            || self.rule_symbol.is_dirty()
            || self.zero.is_dirty()
            || self.succ.is_dirty()
            || self.type_list_len.is_dirty()
            || self.term_list_len.is_dirty()
            || self.rule_chain.is_dirty()
            || self.stmt_list_chain.is_dirty()
            || self.stmt_structure.is_dirty()
            || self.if_atom_structure.is_dirty()
            || self.then_atom_structure.is_dirty()
            || self.term_structure.is_dirty()
            || self.terms_structure.is_dirty()
            || self.opt_term_structure.is_dirty()
            || self.semantic_el.is_dirty()
            || self.semantic_els.is_dirty()
            || self.wildcard_virt_ident.is_dirty()
            || self.grouped_rule_chain.is_dirty()
            || self.grouped_stmt_list_chain.is_dirty()
            || !self.ident_dirty.is_empty()
            || !self.virt_ident_dirty.is_empty()
            || !self.type_decl_node_dirty.is_empty()
            || !self.arg_decl_node_dirty.is_empty()
            || !self.arg_decl_list_node_dirty.is_empty()
            || !self.pred_decl_node_dirty.is_empty()
            || !self.func_decl_node_dirty.is_empty()
            || !self.term_node_dirty.is_empty()
            || !self.term_list_node_dirty.is_empty()
            || !self.opt_term_node_dirty.is_empty()
            || !self.if_atom_node_dirty.is_empty()
            || !self.then_atom_node_dirty.is_empty()
            || !self.stmt_node_dirty.is_empty()
            || !self.stmt_list_node_dirty.is_empty()
            || !self.rule_decl_node_dirty.is_empty()
            || !self.decl_node_dirty.is_empty()
            || !self.decl_list_node_dirty.is_empty()
            || !self.module_node_dirty.is_empty()
            || !self.loc_dirty.is_empty()
            || !self.rule_child_node_dirty.is_empty()
            || !self.type_dirty.is_empty()
            || !self.type_list_dirty.is_empty()
            || !self.pred_dirty.is_empty()
            || !self.func_dirty.is_empty()
            || !self.structure_dirty.is_empty()
            || !self.el_dirty.is_empty()
            || !self.el_list_dirty.is_empty()
            || !self.morphism_dirty.is_empty()
            || !self.chain_dirty.is_empty()
            || !self.symbol_kind_dirty.is_empty()
            || !self.nat_dirty.is_empty()
    }

    fn record_action_0(&self, delta: &mut ModelDelta, tm1: VirtIdent, tm2: VirtIdent) {
        if tm1 != tm2 {
            delta.new_virt_ident_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_real_virt_ident(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RealVirtIdent(tm0, tm1) in self.real_virt_ident.iter_all() {
            #[allow(unused_variables)]
            for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm0) {
                self.record_action_0(delta, tm1, tm2);
            }
        }
    }
    fn record_action_1(&self, delta: &mut ModelDelta, tm1: Ident, tm2: Ident) {
        if tm1 != tm2 {
            delta.new_ident_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_name(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleName(tm0, tm1) in self.rule_name.iter_all() {
            #[allow(unused_variables)]
            for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                self.record_action_1(delta, tm1, tm2);
            }
        }
    }
    fn record_action_2(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_type_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TypeDeclNodeLoc(tm0, tm1) in self.type_decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(_, tm2) in self.type_decl_node_loc.iter_all_0(tm0) {
                self.record_action_2(delta, tm1, tm2);
            }
        }
    }
    fn record_action_3(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_arg_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ArgDeclNodeLoc(tm0, tm1) in self.arg_decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(_, tm2) in self.arg_decl_node_loc.iter_all_0(tm0) {
                self.record_action_3(delta, tm1, tm2);
            }
        }
    }
    fn record_action_4(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_arg_decl_list_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ArgDeclListNodeLoc(tm0, tm1) in self.arg_decl_list_node_loc.iter_all() {
            #[allow(unused_variables)]
            for ArgDeclListNodeLoc(_, tm2) in self.arg_decl_list_node_loc.iter_all_0(tm0) {
                self.record_action_4(delta, tm1, tm2);
            }
        }
    }
    fn record_action_5(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_pred_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredDeclNodeLoc(tm0, tm1) in self.pred_decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(_, tm2) in self.pred_decl_node_loc.iter_all_0(tm0) {
                self.record_action_5(delta, tm1, tm2);
            }
        }
    }
    fn record_action_6(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_func_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncDeclNodeLoc(tm0, tm1) in self.func_decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(_, tm2) in self.func_decl_node_loc.iter_all_0(tm0) {
                self.record_action_6(delta, tm1, tm2);
            }
        }
    }
    fn record_action_7(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_term_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermNodeLoc(tm0, tm1) in self.term_node_loc.iter_all() {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm2) in self.term_node_loc.iter_all_0(tm0) {
                self.record_action_7(delta, tm1, tm2);
            }
        }
    }
    fn record_action_8(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_term_list_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermListNodeLoc(tm0, tm1) in self.term_list_node_loc.iter_all() {
            #[allow(unused_variables)]
            for TermListNodeLoc(_, tm2) in self.term_list_node_loc.iter_all_0(tm0) {
                self.record_action_8(delta, tm1, tm2);
            }
        }
    }
    fn record_action_9(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_opt_term_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for OptTermNodeLoc(tm0, tm1) in self.opt_term_node_loc.iter_all() {
            #[allow(unused_variables)]
            for OptTermNodeLoc(_, tm2) in self.opt_term_node_loc.iter_all_0(tm0) {
                self.record_action_9(delta, tm1, tm2);
            }
        }
    }
    fn record_action_10(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_if_atom_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfAtomNodeLoc(tm0, tm1) in self.if_atom_node_loc.iter_all() {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm2) in self.if_atom_node_loc.iter_all_0(tm0) {
                self.record_action_10(delta, tm1, tm2);
            }
        }
    }
    fn record_action_11(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_then_atom_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenAtomNodeLoc(tm0, tm1) in self.then_atom_node_loc.iter_all() {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(_, tm2) in self.then_atom_node_loc.iter_all_0(tm0) {
                self.record_action_11(delta, tm1, tm2);
            }
        }
    }
    fn record_action_12(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_stmt_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for StmtNodeLoc(tm0, tm1) in self.stmt_node_loc.iter_all() {
            #[allow(unused_variables)]
            for StmtNodeLoc(_, tm2) in self.stmt_node_loc.iter_all_0(tm0) {
                self.record_action_12(delta, tm1, tm2);
            }
        }
    }
    fn record_action_13(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_stmt_list_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for StmtListNodeLoc(tm0, tm1) in self.stmt_list_node_loc.iter_all() {
            #[allow(unused_variables)]
            for StmtListNodeLoc(_, tm2) in self.stmt_list_node_loc.iter_all_0(tm0) {
                self.record_action_13(delta, tm1, tm2);
            }
        }
    }
    fn record_action_14(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDeclNodeLoc(tm0, tm1) in self.rule_decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(_, tm2) in self.rule_decl_node_loc.iter_all_0(tm0) {
                self.record_action_14(delta, tm1, tm2);
            }
        }
    }
    fn record_action_15(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_decl_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DeclNodeLoc(tm0, tm1) in self.decl_node_loc.iter_all() {
            #[allow(unused_variables)]
            for DeclNodeLoc(_, tm2) in self.decl_node_loc.iter_all_0(tm0) {
                self.record_action_15(delta, tm1, tm2);
            }
        }
    }
    fn record_action_16(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_decl_list_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DeclListNodeLoc(tm0, tm1) in self.decl_list_node_loc.iter_all() {
            #[allow(unused_variables)]
            for DeclListNodeLoc(_, tm2) in self.decl_list_node_loc.iter_all_0(tm0) {
                self.record_action_16(delta, tm1, tm2);
            }
        }
    }
    fn record_action_17(&self, delta: &mut ModelDelta, tm1: Loc, tm2: Loc) {
        if tm1 != tm2 {
            delta.new_loc_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_module_node_loc(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ModuleNodeLoc(tm0, tm1) in self.module_node_loc.iter_all() {
            #[allow(unused_variables)]
            for ModuleNodeLoc(_, tm2) in self.module_node_loc.iter_all_0(tm0) {
                self.record_action_17(delta, tm1, tm2);
            }
        }
    }
    fn record_action_18(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_term(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildTerm(tm0, tm1) in self.rule_child_term.iter_all() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm2) in self.rule_child_term.iter_all_0(tm0) {
                self.record_action_18(delta, tm1, tm2);
            }
        }
    }
    fn record_action_19(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_term_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildTermList(tm0, tm1) in self.rule_child_term_list.iter_all() {
            #[allow(unused_variables)]
            for RuleChildTermList(_, tm2) in self.rule_child_term_list.iter_all_0(tm0) {
                self.record_action_19(delta, tm1, tm2);
            }
        }
    }
    fn record_action_20(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_opt_term(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildOptTerm(tm0, tm1) in self.rule_child_opt_term.iter_all() {
            #[allow(unused_variables)]
            for RuleChildOptTerm(_, tm2) in self.rule_child_opt_term.iter_all_0(tm0) {
                self.record_action_20(delta, tm1, tm2);
            }
        }
    }
    fn record_action_21(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_if_atom(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm0, tm1) in self.rule_child_if_atom.iter_all() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(_, tm2) in self.rule_child_if_atom.iter_all_0(tm0) {
                self.record_action_21(delta, tm1, tm2);
            }
        }
    }
    fn record_action_22(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_then_atom(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildThenAtom(tm0, tm1) in self.rule_child_then_atom.iter_all() {
            #[allow(unused_variables)]
            for RuleChildThenAtom(_, tm2) in self.rule_child_then_atom.iter_all_0(tm0) {
                self.record_action_22(delta, tm1, tm2);
            }
        }
    }
    fn record_action_23(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_stmt(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildStmt(tm0, tm1) in self.rule_child_stmt.iter_all() {
            #[allow(unused_variables)]
            for RuleChildStmt(_, tm2) in self.rule_child_stmt.iter_all_0(tm0) {
                self.record_action_23(delta, tm1, tm2);
            }
        }
    }
    fn record_action_24(&self, delta: &mut ModelDelta, tm1: RuleChildNode, tm2: RuleChildNode) {
        if tm1 != tm2 {
            delta.new_rule_child_node_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_child_stmt_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChildStmtList(tm0, tm1) in self.rule_child_stmt_list.iter_all() {
            #[allow(unused_variables)]
            for RuleChildStmtList(_, tm2) in self.rule_child_stmt_list.iter_all_0(tm0) {
                self.record_action_24(delta, tm1, tm2);
            }
        }
    }
    fn record_action_25(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList) {
        if tm0 != tm1 {
            delta.new_type_list_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_nil_type_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilTypeList(tm0) in self.nil_type_list.iter_all() {
            #[allow(unused_variables)]
            for NilTypeList(tm1) in self.nil_type_list.iter_all() {
                self.record_action_25(delta, tm0, tm1);
            }
        }
    }
    fn record_action_26(&self, delta: &mut ModelDelta, tm2: TypeList, tm3: TypeList) {
        if tm2 != tm3 {
            delta.new_type_list_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_cons_type_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_all() {
            #[allow(unused_variables)]
            for ConsTypeList(_, _, tm3) in self.cons_type_list.iter_all_0_1(tm0, tm1) {
                self.record_action_26(delta, tm2, tm3);
            }
        }
    }
    fn record_action_27(&self, delta: &mut ModelDelta, tm1: Type, tm2: Type) {
        if tm1 != tm2 {
            delta.new_type_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticType(tm0, tm1) in self.semantic_type.iter_all() {
            #[allow(unused_variables)]
            for SemanticType(_, tm2) in self.semantic_type.iter_all_0(tm0) {
                self.record_action_27(delta, tm1, tm2);
            }
        }
    }
    fn record_action_28(&self, delta: &mut ModelDelta, tm1: TypeList, tm2: TypeList) {
        if tm1 != tm2 {
            delta.new_type_list_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_arg_types(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticArgTypes(tm0, tm1) in self.semantic_arg_types.iter_all() {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm2) in self.semantic_arg_types.iter_all_0(tm0) {
                self.record_action_28(delta, tm1, tm2);
            }
        }
    }
    fn record_action_29(&self, delta: &mut ModelDelta, tm1: Pred, tm2: Pred) {
        if tm1 != tm2 {
            delta.new_pred_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticPred(tm0, tm1) in self.semantic_pred.iter_all() {
            #[allow(unused_variables)]
            for SemanticPred(_, tm2) in self.semantic_pred.iter_all_0(tm0) {
                self.record_action_29(delta, tm1, tm2);
            }
        }
    }
    fn record_action_30(&self, delta: &mut ModelDelta, tm1: TypeList, tm2: TypeList) {
        if tm1 != tm2 {
            delta.new_type_list_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_arity(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Arity(tm0, tm1) in self.arity.iter_all() {
            #[allow(unused_variables)]
            for Arity(_, tm2) in self.arity.iter_all_0(tm0) {
                self.record_action_30(delta, tm1, tm2);
            }
        }
    }
    fn record_action_31(&self, delta: &mut ModelDelta, tm1: Func, tm2: Func) {
        if tm1 != tm2 {
            delta.new_func_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_func(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticFunc(tm0, tm1) in self.semantic_func.iter_all() {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm2) in self.semantic_func.iter_all_0(tm0) {
                self.record_action_31(delta, tm1, tm2);
            }
        }
    }
    fn record_action_32(&self, delta: &mut ModelDelta, tm1: TypeList, tm2: TypeList) {
        if tm1 != tm2 {
            delta.new_type_list_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_domain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Domain(tm0, tm1) in self.domain.iter_all() {
            #[allow(unused_variables)]
            for Domain(_, tm2) in self.domain.iter_all_0(tm0) {
                self.record_action_32(delta, tm1, tm2);
            }
        }
    }
    fn record_action_33(&self, delta: &mut ModelDelta, tm1: Type, tm2: Type) {
        if tm1 != tm2 {
            delta.new_type_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_codomain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Codomain(tm0, tm1) in self.codomain.iter_all() {
            #[allow(unused_variables)]
            for Codomain(_, tm2) in self.codomain.iter_all_0(tm0) {
                self.record_action_33(delta, tm1, tm2);
            }
        }
    }
    fn record_action_34(&self, delta: &mut ModelDelta, tm1: ElList, tm2: ElList) {
        if tm1 != tm2 {
            delta.new_el_list_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_nil_el_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilElList(tm0, tm1) in self.nil_el_list.iter_all() {
            #[allow(unused_variables)]
            for NilElList(_, tm2) in self.nil_el_list.iter_all_0(tm0) {
                self.record_action_34(delta, tm1, tm2);
            }
        }
    }
    fn record_action_35(&self, delta: &mut ModelDelta, tm2: ElList, tm3: ElList) {
        if tm2 != tm3 {
            delta.new_el_list_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_cons_el_list(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_all() {
            #[allow(unused_variables)]
            for ConsElList(_, _, tm3) in self.cons_el_list.iter_all_0_1(tm0, tm1) {
                self.record_action_35(delta, tm2, tm3);
            }
        }
    }
    fn record_action_36(&self, delta: &mut ModelDelta, tm2: El, tm3: El) {
        if tm2 != tm3 {
            delta.new_el_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_func_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncApp(tm0, tm1, tm2) in self.func_app.iter_all() {
            #[allow(unused_variables)]
            for FuncApp(_, _, tm3) in self.func_app.iter_all_0_1(tm0, tm1) {
                self.record_action_36(delta, tm2, tm3);
            }
        }
    }
    fn record_action_37(&self, delta: &mut ModelDelta, tm2: El, tm3: El) {
        if tm2 != tm3 {
            delta.new_el_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Var(tm0, tm1, tm2) in self.var.iter_all() {
            #[allow(unused_variables)]
            for Var(_, _, tm3) in self.var.iter_all_0_1(tm0, tm1) {
                self.record_action_37(delta, tm2, tm3);
            }
        }
    }
    fn record_action_38(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_el_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElStructure(tm0, tm1) in self.el_structure.iter_all() {
            #[allow(unused_variables)]
            for ElStructure(_, tm2) in self.el_structure.iter_all_0(tm0) {
                self.record_action_38(delta, tm1, tm2);
            }
        }
    }
    fn record_action_39(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_els_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElsStructure(tm0, tm1) in self.els_structure.iter_all() {
            #[allow(unused_variables)]
            for ElsStructure(_, tm2) in self.els_structure.iter_all_0(tm0) {
                self.record_action_39(delta, tm1, tm2);
            }
        }
    }
    fn record_action_40(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_dom(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Dom(tm0, tm1) in self.dom.iter_all() {
            #[allow(unused_variables)]
            for Dom(_, tm2) in self.dom.iter_all_0(tm0) {
                self.record_action_40(delta, tm1, tm2);
            }
        }
    }
    fn record_action_41(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_cod(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Cod(tm0, tm1) in self.cod.iter_all() {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                self.record_action_41(delta, tm1, tm2);
            }
        }
    }
    fn record_action_42(&self, delta: &mut ModelDelta, tm2: El, tm3: El) {
        if tm2 != tm3 {
            delta.new_el_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_map_el(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for MapEl(tm0, tm1, tm2) in self.map_el.iter_all() {
            #[allow(unused_variables)]
            for MapEl(_, _, tm3) in self.map_el.iter_all_0_1(tm0, tm1) {
                self.record_action_42(delta, tm2, tm3);
            }
        }
    }
    fn record_action_43(&self, delta: &mut ModelDelta, tm2: ElList, tm3: ElList) {
        if tm2 != tm3 {
            delta.new_el_list_equalities.push((tm2, tm3));
        }
    }
    fn query_and_record_functionality_map_els(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for MapEls(tm0, tm1, tm2) in self.map_els.iter_all() {
            #[allow(unused_variables)]
            for MapEls(_, _, tm3) in self.map_els.iter_all_0_1(tm0, tm1) {
                self.record_action_43(delta, tm2, tm3);
            }
        }
    }
    fn record_action_44(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Structure) {
        if tm0 != tm1 {
            delta.new_structure_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_initial_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for InitialStructure(tm0) in self.initial_structure.iter_all() {
            #[allow(unused_variables)]
            for InitialStructure(tm1) in self.initial_structure.iter_all() {
                self.record_action_44(delta, tm0, tm1);
            }
        }
    }
    fn record_action_45(&self, delta: &mut ModelDelta, tm1: Morphism, tm2: Morphism) {
        if tm1 != tm2 {
            delta.new_morphism_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_initiality_morphism(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for InitialityMorphism(tm0, tm1) in self.initiality_morphism.iter_all() {
            #[allow(unused_variables)]
            for InitialityMorphism(_, tm2) in self.initiality_morphism.iter_all_0(tm0) {
                self.record_action_45(delta, tm1, tm2);
            }
        }
    }
    fn record_action_46(&self, delta: &mut ModelDelta, tm0: Chain, tm1: Chain) {
        if tm0 != tm1 {
            delta.new_chain_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_nil_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilChain(tm0) in self.nil_chain.iter_all() {
            #[allow(unused_variables)]
            for NilChain(tm1) in self.nil_chain.iter_all() {
                self.record_action_46(delta, tm0, tm1);
            }
        }
    }
    fn record_action_47(&self, delta: &mut ModelDelta, tm1: Chain, tm2: Chain) {
        if tm1 != tm2 {
            delta.new_chain_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_chain_tail(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainTail(tm0, tm1) in self.chain_tail.iter_all() {
            #[allow(unused_variables)]
            for ChainTail(_, tm2) in self.chain_tail.iter_all_0(tm0) {
                self.record_action_47(delta, tm1, tm2);
            }
        }
    }
    fn record_action_48(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_chain_head_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainHeadStructure(tm0, tm1) in self.chain_head_structure.iter_all() {
            #[allow(unused_variables)]
            for ChainHeadStructure(_, tm2) in self.chain_head_structure.iter_all_0(tm0) {
                self.record_action_48(delta, tm1, tm2);
            }
        }
    }
    fn record_action_49(&self, delta: &mut ModelDelta, tm1: Morphism, tm2: Morphism) {
        if tm1 != tm2 {
            delta.new_morphism_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_chain_head_transition(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainHeadTransition(tm0, tm1) in self.chain_head_transition.iter_all() {
            #[allow(unused_variables)]
            for ChainHeadTransition(_, tm2) in self.chain_head_transition.iter_all_0(tm0) {
                self.record_action_49(delta, tm1, tm2);
            }
        }
    }
    fn record_action_50(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        if tm0 != tm1 {
            delta.new_symbol_kind_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_type_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TypeSymbol(tm0) in self.type_symbol.iter_all() {
            #[allow(unused_variables)]
            for TypeSymbol(tm1) in self.type_symbol.iter_all() {
                self.record_action_50(delta, tm0, tm1);
            }
        }
    }
    fn record_action_51(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        if tm0 != tm1 {
            delta.new_symbol_kind_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_pred_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredSymbol(tm0) in self.pred_symbol.iter_all() {
            #[allow(unused_variables)]
            for PredSymbol(tm1) in self.pred_symbol.iter_all() {
                self.record_action_51(delta, tm0, tm1);
            }
        }
    }
    fn record_action_52(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        if tm0 != tm1 {
            delta.new_symbol_kind_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_func_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncSymbol(tm0) in self.func_symbol.iter_all() {
            #[allow(unused_variables)]
            for FuncSymbol(tm1) in self.func_symbol.iter_all() {
                self.record_action_52(delta, tm0, tm1);
            }
        }
    }
    fn record_action_53(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
        if tm0 != tm1 {
            delta.new_symbol_kind_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_rule_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleSymbol(tm0) in self.rule_symbol.iter_all() {
            #[allow(unused_variables)]
            for RuleSymbol(tm1) in self.rule_symbol.iter_all() {
                self.record_action_53(delta, tm0, tm1);
            }
        }
    }
    fn record_action_54(&self, delta: &mut ModelDelta, tm0: Nat, tm1: Nat) {
        if tm0 != tm1 {
            delta.new_nat_equalities.push((tm0, tm1));
        }
    }
    fn query_and_record_functionality_zero(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Zero(tm0) in self.zero.iter_all() {
            #[allow(unused_variables)]
            for Zero(tm1) in self.zero.iter_all() {
                self.record_action_54(delta, tm0, tm1);
            }
        }
    }
    fn record_action_55(&self, delta: &mut ModelDelta, tm1: Nat, tm2: Nat) {
        if tm1 != tm2 {
            delta.new_nat_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_succ(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Succ(tm0, tm1) in self.succ.iter_all() {
            #[allow(unused_variables)]
            for Succ(_, tm2) in self.succ.iter_all_0(tm0) {
                self.record_action_55(delta, tm1, tm2);
            }
        }
    }
    fn record_action_56(&self, delta: &mut ModelDelta, tm1: Nat, tm2: Nat) {
        if tm1 != tm2 {
            delta.new_nat_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_type_list_len(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TypeListLen(tm0, tm1) in self.type_list_len.iter_all() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm2) in self.type_list_len.iter_all_0(tm0) {
                self.record_action_56(delta, tm1, tm2);
            }
        }
    }
    fn record_action_57(&self, delta: &mut ModelDelta, tm1: Nat, tm2: Nat) {
        if tm1 != tm2 {
            delta.new_nat_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_term_list_len(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermListLen(tm0, tm1) in self.term_list_len.iter_all() {
            #[allow(unused_variables)]
            for TermListLen(_, tm2) in self.term_list_len.iter_all_0(tm0) {
                self.record_action_57(delta, tm1, tm2);
            }
        }
    }
    fn record_action_58(&self, delta: &mut ModelDelta, tm1: Chain, tm2: Chain) {
        if tm1 != tm2 {
            delta.new_chain_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_rule_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleChain(tm0, tm1) in self.rule_chain.iter_all() {
            #[allow(unused_variables)]
            for RuleChain(_, tm2) in self.rule_chain.iter_all_0(tm0) {
                self.record_action_58(delta, tm1, tm2);
            }
        }
    }
    fn record_action_59(&self, delta: &mut ModelDelta, tm1: Chain, tm2: Chain) {
        if tm1 != tm2 {
            delta.new_chain_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_stmt_list_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for StmtListChain(tm0, tm1) in self.stmt_list_chain.iter_all() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm2) in self.stmt_list_chain.iter_all_0(tm0) {
                self.record_action_59(delta, tm1, tm2);
            }
        }
    }
    fn record_action_60(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_stmt_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for StmtStructure(tm0, tm1) in self.stmt_structure.iter_all() {
            #[allow(unused_variables)]
            for StmtStructure(_, tm2) in self.stmt_structure.iter_all_0(tm0) {
                self.record_action_60(delta, tm1, tm2);
            }
        }
    }
    fn record_action_61(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_if_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfAtomStructure(tm0, tm1) in self.if_atom_structure.iter_all() {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm2) in self.if_atom_structure.iter_all_0(tm0) {
                self.record_action_61(delta, tm1, tm2);
            }
        }
    }
    fn record_action_62(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_then_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenAtomStructure(tm0, tm1) in self.then_atom_structure.iter_all() {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm2) in self.then_atom_structure.iter_all_0(tm0) {
                self.record_action_62(delta, tm1, tm2);
            }
        }
    }
    fn record_action_63(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_term_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermStructure(tm0, tm1) in self.term_structure.iter_all() {
            #[allow(unused_variables)]
            for TermStructure(_, tm2) in self.term_structure.iter_all_0(tm0) {
                self.record_action_63(delta, tm1, tm2);
            }
        }
    }
    fn record_action_64(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_terms_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermsStructure(tm0, tm1) in self.terms_structure.iter_all() {
            #[allow(unused_variables)]
            for TermsStructure(_, tm2) in self.terms_structure.iter_all_0(tm0) {
                self.record_action_64(delta, tm1, tm2);
            }
        }
    }
    fn record_action_65(&self, delta: &mut ModelDelta, tm1: Structure, tm2: Structure) {
        if tm1 != tm2 {
            delta.new_structure_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_opt_term_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for OptTermStructure(tm0, tm1) in self.opt_term_structure.iter_all() {
            #[allow(unused_variables)]
            for OptTermStructure(_, tm2) in self.opt_term_structure.iter_all_0(tm0) {
                self.record_action_65(delta, tm1, tm2);
            }
        }
    }
    fn record_action_66(&self, delta: &mut ModelDelta, tm1: El, tm2: El) {
        if tm1 != tm2 {
            delta.new_el_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_el(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm1) in self.semantic_el.iter_all() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2) in self.semantic_el.iter_all_0(tm0) {
                self.record_action_66(delta, tm1, tm2);
            }
        }
    }
    fn record_action_67(&self, delta: &mut ModelDelta, tm1: ElList, tm2: ElList) {
        if tm1 != tm2 {
            delta.new_el_list_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_semantic_els(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SemanticEls(tm0, tm1) in self.semantic_els.iter_all() {
            #[allow(unused_variables)]
            for SemanticEls(_, tm2) in self.semantic_els.iter_all_0(tm0) {
                self.record_action_67(delta, tm1, tm2);
            }
        }
    }
    fn record_action_68(&self, delta: &mut ModelDelta, tm1: VirtIdent, tm2: VirtIdent) {
        if tm1 != tm2 {
            delta.new_virt_ident_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_wildcard_virt_ident(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for WildcardVirtIdent(tm0, tm1) in self.wildcard_virt_ident.iter_all() {
            #[allow(unused_variables)]
            for WildcardVirtIdent(_, tm2) in self.wildcard_virt_ident.iter_all_0(tm0) {
                self.record_action_68(delta, tm1, tm2);
            }
        }
    }
    fn record_action_69(&self, delta: &mut ModelDelta, tm1: Chain, tm2: Chain) {
        if tm1 != tm2 {
            delta.new_chain_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_grouped_rule_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for GroupedRuleChain(tm0, tm1) in self.grouped_rule_chain.iter_all() {
            #[allow(unused_variables)]
            for GroupedRuleChain(_, tm2) in self.grouped_rule_chain.iter_all_0(tm0) {
                self.record_action_69(delta, tm1, tm2);
            }
        }
    }
    fn record_action_70(&self, delta: &mut ModelDelta, tm1: Chain, tm2: Chain) {
        if tm1 != tm2 {
            delta.new_chain_equalities.push((tm1, tm2));
        }
    }
    fn query_and_record_functionality_grouped_stmt_list_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm0, tm1) in self.grouped_stmt_list_chain.iter_all() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm2) in self.grouped_stmt_list_chain.iter_all_0(tm0) {
                self.record_action_70(delta, tm1, tm2);
            }
        }
    }
    fn record_action_71(&self, delta: &mut ModelDelta, tm0: Ident) {
        let existing_row = self.real_virt_ident.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RealVirtIdent(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_virt_ident(self);
                delta.new_real_virt_ident.push(RealVirtIdent(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_real_virt_ident_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.ident_dirty.iter().copied() {
            self.record_action_71(delta, tm0);
        }
    }
    fn record_action_72(&self, delta: &mut ModelDelta, tm0: TermNode) {
        let existing_row = self.rule_child_term.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildTerm(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta.new_rule_child_term.push(RuleChildTerm(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_term_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.term_node_dirty.iter().copied() {
            self.record_action_72(delta, tm0);
        }
    }
    fn record_action_73(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        let existing_row = self.rule_child_term_list.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildTermList(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta
                    .new_rule_child_term_list
                    .push(RuleChildTermList(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_term_list_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.term_list_node_dirty.iter().copied() {
            self.record_action_73(delta, tm0);
        }
    }
    fn record_action_74(&self, delta: &mut ModelDelta, tm0: OptTermNode) {
        let existing_row = self.rule_child_opt_term.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildOptTerm(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta
                    .new_rule_child_opt_term
                    .push(RuleChildOptTerm(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_opt_term_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.opt_term_node_dirty.iter().copied() {
            self.record_action_74(delta, tm0);
        }
    }
    fn record_action_75(&self, delta: &mut ModelDelta, tm0: IfAtomNode) {
        let existing_row = self.rule_child_if_atom.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildIfAtom(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta.new_rule_child_if_atom.push(RuleChildIfAtom(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_if_atom_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.if_atom_node_dirty.iter().copied() {
            self.record_action_75(delta, tm0);
        }
    }
    fn record_action_76(&self, delta: &mut ModelDelta, tm0: ThenAtomNode) {
        let existing_row = self.rule_child_then_atom.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildThenAtom(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta
                    .new_rule_child_then_atom
                    .push(RuleChildThenAtom(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_then_atom_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.then_atom_node_dirty.iter().copied() {
            self.record_action_76(delta, tm0);
        }
    }
    fn record_action_77(&self, delta: &mut ModelDelta, tm0: StmtNode) {
        let existing_row = self.rule_child_stmt.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildStmt(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta.new_rule_child_stmt.push(RuleChildStmt(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_stmt_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.stmt_node_dirty.iter().copied() {
            self.record_action_77(delta, tm0);
        }
    }
    fn record_action_78(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
        let existing_row = self.rule_child_stmt_list.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChildStmtList(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_rule_child_node(self);
                delta
                    .new_rule_child_stmt_list
                    .push(RuleChildStmtList(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_child_stmt_list_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.stmt_list_node_dirty.iter().copied() {
            self.record_action_78(delta, tm0);
        }
    }
    fn record_action_79(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm2: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm2, tm0));
                ()
            }
        };
    }
    fn query_and_record_rule_child_rule_decl(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildStmtList(_, tm2) in self.rule_child_stmt_list.iter_all_0(tm1) {
                self.record_action_79(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmtList(tm1, tm2) in self.rule_child_stmt_list.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDecl(tm0, _) in self.rule_decl.iter_all_1(tm1) {
                self.record_action_79(delta, tm0, tm2);
            }
        }
    }
    fn record_action_80(
        &self,
        delta: &mut ModelDelta,
        tm4: RuleDeclNode,
        tm5: RuleChildNode,
        tm6: RuleChildNode,
    ) {
        let existing_row = self.rule_child.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm6, tm4));
                ()
            }
        };
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_stmts_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildStmtList(_, tm6) in self.rule_child_stmt_list.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm5) in self.rule_child_stmt.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for RuleChildStmtList(_, tm3) in self.rule_child_stmt_list.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_80(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildStmtList(tm0, _) in self.rule_child_stmt_list.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildStmtList(_, tm6) in self.rule_child_stmt_list.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for RuleChildStmt(_, tm5) in self.rule_child_stmt.iter_all_0(tm1) {
                            self.record_action_80(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmt(tm1, tm5) in self.rule_child_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, _, tm2) in self.cons_stmt_list_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildStmtList(_, tm3) in self.rule_child_stmt_list.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for RuleChildStmtList(_, tm6) in self.rule_child_stmt_list.iter_all_0(tm2) {
                            self.record_action_80(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmtList(tm2, tm6) in self.rule_child_stmt_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm1, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm5) in self.rule_child_stmt.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for RuleChildStmtList(_, tm3) in self.rule_child_stmt_list.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_80(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmtList(tm0, tm3) in self.rule_child_stmt_list.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildStmtList(_, tm6) in self.rule_child_stmt_list.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for RuleChildStmt(_, tm5) in self.rule_child_stmt.iter_all_0(tm1) {
                            self.record_action_80(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }
    fn record_action_81(&self, delta: &mut ModelDelta, tm3: RuleDeclNode, tm4: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_rule_child_stmt_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(_, tm4) in self.rule_child_if_atom.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm2) in self.rule_child_stmt.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_81(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm2, tm3) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildStmt(tm0, _) in self.rule_child_stmt.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildIfAtom(_, tm4) in self.rule_child_if_atom.iter_all_0(tm1) {
                        self.record_action_81(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm1, tm4) in self.rule_child_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, _) in self.if_stmt_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm2) in self.rule_child_stmt.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_81(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmt(tm0, tm2) in self.rule_child_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildIfAtom(_, tm4) in self.rule_child_if_atom.iter_all_0(tm1) {
                        self.record_action_81(delta, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_82(&self, delta: &mut ModelDelta, tm3: RuleDeclNode, tm4: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_rule_child_stmt_then(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildThenAtom(_, tm4) in self.rule_child_then_atom.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm2) in self.rule_child_stmt.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_82(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm2, tm3) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildStmt(tm0, _) in self.rule_child_stmt.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm4) in self.rule_child_then_atom.iter_all_0(tm1) {
                        self.record_action_82(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildThenAtom(tm1, tm4) in self.rule_child_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildStmt(_, tm2) in self.rule_child_stmt.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_82(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildStmt(tm0, tm2) in self.rule_child_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm4) in self.rule_child_then_atom.iter_all_0(tm1) {
                        self.record_action_82(delta, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_83(
        &self,
        delta: &mut ModelDelta,
        tm4: RuleDeclNode,
        tm5: RuleChildNode,
        tm6: RuleChildNode,
    ) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
        let existing_row = self.rule_child.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_if_atom_equal(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_83(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(tm0, _) in self.rule_child_if_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_83(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm2, tm5) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, _) in self.equal_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                            self.record_action_83(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm6) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, _, tm2) in self.equal_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_83(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm0, tm3) in self.rule_child_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_83(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }
    fn record_action_84(&self, delta: &mut ModelDelta, tm3: RuleDeclNode, tm4: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_rule_child_if_atom_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm2) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_84(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm2, tm3) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(tm0, _) in self.rule_child_if_atom.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_84(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm4) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(tm0, _) in self.defined_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm2) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_84(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm0, tm2) in self.rule_child_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_84(delta, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_85(&self, delta: &mut ModelDelta, tm4: RuleDeclNode, tm5: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_if_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_85(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(tm0, _) in self.rule_child_if_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_85(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTermList(tm2, tm5) in self.rule_child_term_list.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, _) in self.pred_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_85(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm0, tm3) in self.rule_child_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_85(delta, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_86(&self, delta: &mut ModelDelta, tm4: RuleDeclNode, tm5: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_if_atom_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_86(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildIfAtom(tm0, _) in self.rule_child_if_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_86(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm5) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, _, tm2) in self.var_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildIfAtom(_, tm3) in self.rule_child_if_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_86(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildIfAtom(tm0, tm3) in self.rule_child_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_86(delta, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_87(
        &self,
        delta: &mut ModelDelta,
        tm4: RuleDeclNode,
        tm5: RuleChildNode,
        tm6: RuleChildNode,
    ) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
        let existing_row = self.rule_child.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_then_atom_equal(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_87(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildThenAtom(tm0, _) in self.rule_child_then_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_87(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm2, tm5) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, _) in self.equal_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                            self.record_action_87(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm6) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, _, tm2) in self.equal_then_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_87(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildThenAtom(tm0, tm3) in self.rule_child_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm6) in self.rule_child_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_87(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }
    fn record_action_88(
        &self,
        delta: &mut ModelDelta,
        tm4: RuleDeclNode,
        tm5: RuleChildNode,
        tm6: RuleChildNode,
    ) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
        let existing_row = self.rule_child.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_then_atom_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildOptTerm(_, tm6) in self.rule_child_opt_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_88(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildThenAtom(tm0, _) in self.rule_child_then_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for RuleChildOptTerm(_, tm6) in self.rule_child_opt_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_88(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm2, tm5) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, _) in self.defined_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for RuleChildOptTerm(_, tm6) in self.rule_child_opt_term.iter_all_0(tm1) {
                            self.record_action_88(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildOptTerm(tm1, tm6) in self.rule_child_opt_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, _, tm2) in self.defined_then_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_88(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildThenAtom(tm0, tm3) in self.rule_child_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0)
                {
                    #[allow(unused_variables)]
                    for RuleChildOptTerm(_, tm6) in self.rule_child_opt_term.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm2) {
                            self.record_action_88(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }
    fn record_action_89(&self, delta: &mut ModelDelta, tm4: RuleDeclNode, tm5: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_then_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_89(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildThenAtom(tm0, _) in self.rule_child_then_atom.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_89(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTermList(tm2, tm5) in self.rule_child_term_list.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, _) in self.pred_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildThenAtom(_, tm3) in self.rule_child_then_atom.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_89(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildThenAtom(tm0, tm3) in self.rule_child_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_89(delta, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_90(
        &self,
        delta: &mut ModelDelta,
        tm4: RuleDeclNode,
        tm5: RuleChildNode,
        tm6: RuleChildNode,
    ) {
        let existing_row = self.rule_child.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm6, tm4));
                ()
            }
        };
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_terms_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTermList(_, tm6) in self.rule_child_term_list.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm3) in self.rule_child_term_list.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_90(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTermList(tm0, _) in self.rule_child_term_list.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm6) in self.rule_child_term_list.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                            self.record_action_90(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm5) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, _, tm2) in self.cons_term_list_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildTermList(_, tm3) in self.rule_child_term_list.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for RuleChildTermList(_, tm6) in self.rule_child_term_list.iter_all_0(tm2) {
                            self.record_action_90(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTermList(tm2, tm6) in self.rule_child_term_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, _) in self.cons_term_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm3) in self.rule_child_term_list.iter_all_0(tm0) {
                        #[allow(unused_variables)]
                        for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                            self.record_action_90(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTermList(tm0, tm3) in self.rule_child_term_list.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm6) in self.rule_child_term_list.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for RuleChildTerm(_, tm5) in self.rule_child_term.iter_all_0(tm1) {
                            self.record_action_90(delta, tm4, tm5, tm6);
                        }
                    }
                }
            }
        }
    }
    fn record_action_91(&self, delta: &mut ModelDelta, tm3: RuleDeclNode, tm4: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_rule_child_opt_term_some(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for RuleChildOptTerm(_, tm2) in self.rule_child_opt_term.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_91(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm2, tm3) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildOptTerm(tm0, _) in self.rule_child_opt_term.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_91(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm1, tm4) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for SomeTermNode(tm0, _) in self.some_term_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChildOptTerm(_, tm2) in self.rule_child_opt_term.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                        self.record_action_91(delta, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildOptTerm(tm0, tm2) in self.rule_child_opt_term.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTerm(_, tm4) in self.rule_child_term.iter_all_0(tm1) {
                        self.record_action_91(delta, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_92(&self, delta: &mut ModelDelta, tm4: RuleDeclNode, tm5: RuleChildNode) {
        let existing_row = self.rule_child.iter_all_0_1(tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(RuleChild(_, _)) => (),
            None => {
                delta.new_rule_child.push(RuleChild(tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_child_term_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm3) in self.rule_child_term.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_92(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm3, tm4) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(tm0, _) in self.rule_child_term.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_92(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm0, tm3) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChildTermList(_, tm5) in self.rule_child_term_list.iter_all_0(tm2) {
                        self.record_action_92(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTermList(tm2, tm5) in self.rule_child_term_list.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, _) in self.app_term_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for RuleChildTerm(_, tm3) in self.rule_child_term.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleChild(_, tm4) in self.rule_child.iter_all_0(tm3) {
                        self.record_action_92(delta, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_93(&self, delta: &mut ModelDelta) {
        let existing_row = self.absurd.iter_all().next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Absurd()) => (),
            None => {
                delta.new_absurd.push(Absurd());
                ()
            }
        };
    }
    fn query_and_record_type_list_nil_not_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilTypeList(tm0) in self.nil_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm1, tm2, _) in self.cons_type_list.iter_all_2(tm0) {
                self.record_action_93(delta);
            }
        }
        #[allow(unused_variables)]
        for ConsTypeList(tm1, tm2, tm0) in self.cons_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for NilTypeList(_) in self.nil_type_list.iter_all_0(tm0) {
                self.record_action_93(delta);
            }
        }
    }
    fn record_action_94(
        &self,
        delta: &mut ModelDelta,
        tm0: Type,
        tm1: TypeList,
        tm3: Type,
        tm4: TypeList,
    ) {
        if tm0 != tm3 {
            delta.new_type_equalities.push((tm0, tm3));
        }
        if tm1 != tm4 {
            delta.new_type_list_equalities.push((tm1, tm4));
        }
        if tm3 != tm0 {
            delta.new_type_equalities.push((tm3, tm0));
        }
        if tm4 != tm1 {
            delta.new_type_list_equalities.push((tm4, tm1));
        }
    }
    fn query_and_record_type_list_cons_injective(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm3, tm4, _) in self.cons_type_list.iter_all_2(tm2) {
                self.record_action_94(delta, tm0, tm1, tm3, tm4);
            }
        }
        #[allow(unused_variables)]
        for ConsTypeList(tm3, tm4, tm2) in self.cons_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, _) in self.cons_type_list.iter_all_2(tm2) {
                self.record_action_94(delta, tm0, tm1, tm3, tm4);
            }
        }
    }
    fn record_action_95(&self, delta: &mut ModelDelta, tm1: Ident) {
        let existing_row = self.semantic_type.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let (tm2,) = match existing_row {
            Some(SemanticType(_, tm2)) => (tm2,),
            None => {
                let tm2 = delta.new_type(self);
                delta.new_semantic_type.push(SemanticType(tm1, tm2));
                (tm2,)
            }
        };
    }
    fn query_and_record_semantic_decl_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TypeDecl(tm0, tm1) in self.type_decl.iter_dirty() {
            self.record_action_95(delta, tm1);
        }
    }
    fn record_action_96(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
        let existing_row = self.nil_type_list.iter_all().next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(NilTypeList(tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_type_list(self);
                delta.new_nil_type_list.push(NilTypeList(tm1));
                (tm1,)
            }
        };
        let existing_row = self.semantic_arg_types.iter_all_0_1(tm0, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(SemanticArgTypes(_, _)) => (),
            None => {
                delta
                    .new_semantic_arg_types
                    .push(SemanticArgTypes(tm0, tm1));
                ()
            }
        };
    }
    fn query_and_record_semantic_arg_types_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilArgDeclListNode(tm0) in self.nil_arg_decl_list_node.iter_dirty() {
            self.record_action_96(delta, tm0);
        }
    }
    fn record_action_97(
        &self,
        delta: &mut ModelDelta,
        tm2: ArgDeclListNode,
        tm4: Type,
        tm5: TypeList,
    ) {
        let existing_row = self.cons_type_list.iter_all_0_1(tm4, tm5).next();
        #[allow(unused_variables)]
        let (tm6,) = match existing_row {
            Some(ConsTypeList(_, _, tm6)) => (tm6,),
            None => {
                let tm6 = delta.new_type_list(self);
                delta.new_cons_type_list.push(ConsTypeList(tm4, tm5, tm6));
                (tm6,)
            }
        };
        let existing_row = self.semantic_arg_types.iter_all_0_1(tm2, tm6).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(SemanticArgTypes(_, _)) => (),
            None => {
                delta
                    .new_semantic_arg_types
                    .push(SemanticArgTypes(tm2, tm6));
                ()
            }
        };
    }
    fn query_and_record_semantic_arg_types_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ArgDeclNodeType(tm0, tm1) in self.arg_decl_node_type.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for ConsArgDeclListNode(tm2, _, tm3) in self.cons_arg_decl_list_node.iter_all_1(tm0)
                {
                    #[allow(unused_variables)]
                    for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm3) {
                        self.record_action_97(delta, tm2, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsArgDeclListNode(tm2, tm0, tm3) in self.cons_arg_decl_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for ArgDeclNodeType(_, tm1) in self.arg_decl_node_type.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm1) {
                        self.record_action_97(delta, tm2, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticType(tm1, tm4) in self.semantic_type.iter_dirty() {
            #[allow(unused_variables)]
            for ArgDeclNodeType(tm0, _) in self.arg_decl_node_type.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for ConsArgDeclListNode(tm2, _, tm3) in self.cons_arg_decl_list_node.iter_all_1(tm0)
                {
                    #[allow(unused_variables)]
                    for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm3) {
                        self.record_action_97(delta, tm2, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticArgTypes(tm3, tm5) in self.semantic_arg_types.iter_dirty() {
            #[allow(unused_variables)]
            for ConsArgDeclListNode(tm2, tm0, _) in self.cons_arg_decl_list_node.iter_all_2(tm3) {
                #[allow(unused_variables)]
                for ArgDeclNodeType(_, tm1) in self.arg_decl_node_type.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm1) {
                        self.record_action_97(delta, tm2, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_98(&self, delta: &mut ModelDelta, tm1: Ident) {
        let existing_row = self.semantic_pred.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let (tm3,) = match existing_row {
            Some(SemanticPred(_, tm3)) => (tm3,),
            None => {
                let tm3 = delta.new_pred(self);
                delta.new_semantic_pred.push(SemanticPred(tm1, tm3));
                (tm3,)
            }
        };
    }
    fn query_and_record_semantic_decl_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
            self.record_action_98(delta, tm1);
        }
    }
    fn record_action_99(&self, delta: &mut ModelDelta, tm3: TypeList, tm4: Pred) {
        let existing_row = self.arity.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Arity(_, _)) => (),
            None => {
                delta.new_arity.push(Arity(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_arity_decl(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm3) in self.semantic_arg_types.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    self.record_action_99(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticArgTypes(tm2, tm3) in self.semantic_arg_types.iter_dirty() {
            #[allow(unused_variables)]
            for PredDecl(tm0, tm1, _) in self.pred_decl.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    self.record_action_99(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticPred(tm1, tm4) in self.semantic_pred.iter_dirty() {
            #[allow(unused_variables)]
            for PredDecl(tm0, _, tm2) in self.pred_decl.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticArgTypes(_, tm3) in self.semantic_arg_types.iter_all_0(tm2) {
                    self.record_action_99(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_100(&self, delta: &mut ModelDelta, tm1: Ident) {
        let existing_row = self.semantic_func.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let (tm4,) = match existing_row {
            Some(SemanticFunc(_, tm4)) => (tm4,),
            None => {
                let tm4 = delta.new_func(self);
                delta.new_semantic_func.push(SemanticFunc(tm1, tm4));
                (tm4,)
            }
        };
    }
    fn query_and_record_semantic_decl_func(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
            self.record_action_100(delta, tm1);
        }
    }
    fn record_action_101(&self, delta: &mut ModelDelta, tm4: Type, tm5: TypeList, tm6: Func) {
        let existing_row = self.domain.iter_all_0_1(tm6, tm5).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Domain(_, _)) => (),
            None => {
                delta.new_domain.push(Domain(tm6, tm5));
                ()
            }
        };
        let existing_row = self.codomain.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Codomain(_, _)) => (),
            None => {
                delta.new_codomain.push(Codomain(tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_domain_decl(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for SemanticFunc(_, tm6) in self.semantic_func.iter_all_0(tm1) {
                        self.record_action_101(delta, tm4, tm5, tm6);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticType(tm3, tm4) in self.semantic_type.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, tm2, _) in self.func_decl.iter_all_3(tm3) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm6) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                        self.record_action_101(delta, tm4, tm5, tm6);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticArgTypes(tm2, tm5) in self.semantic_arg_types.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDecl(tm0, tm1, _, tm3) in self.func_decl.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for SemanticFunc(_, tm6) in self.semantic_func.iter_all_0(tm1) {
                        self.record_action_101(delta, tm4, tm5, tm6);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticFunc(tm1, tm6) in self.semantic_func.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDecl(tm0, _, tm2, tm3) in self.func_decl.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticType(_, tm4) in self.semantic_type.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for SemanticArgTypes(_, tm5) in self.semantic_arg_types.iter_all_0(tm2) {
                        self.record_action_101(delta, tm4, tm5, tm6);
                    }
                }
            }
        }
    }
    fn record_action_102(
        &self,
        delta: &mut ModelDelta,
        tm0: El,
        tm1: ElList,
        tm3: El,
        tm4: ElList,
    ) {
        if tm0 != tm3 {
            delta.new_el_equalities.push((tm0, tm3));
        }
        if tm1 != tm4 {
            delta.new_el_list_equalities.push((tm1, tm4));
        }
        if tm3 != tm0 {
            delta.new_el_equalities.push((tm3, tm0));
        }
        if tm4 != tm1 {
            delta.new_el_list_equalities.push((tm4, tm1));
        }
    }
    fn query_and_record_el_list_cons_injective(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm3, tm4, _) in self.cons_el_list.iter_all_2(tm2) {
                self.record_action_102(delta, tm0, tm1, tm3, tm4);
            }
        }
        #[allow(unused_variables)]
        for ConsElList(tm3, tm4, tm2) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm2) {
                self.record_action_102(delta, tm0, tm1, tm3, tm4);
            }
        }
    }
    fn record_action_103(&self, delta: &mut ModelDelta) {
        let existing_row = self.absurd.iter_all().next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Absurd()) => (),
            None => {
                delta.new_absurd.push(Absurd());
                ()
            }
        };
    }
    fn query_and_record_el_list_cons_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm2, tm3, _) in self.cons_el_list.iter_all_2(tm1) {
                self.record_action_103(delta);
            }
        }
        #[allow(unused_variables)]
        for ConsElList(tm2, tm3, tm1) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for NilElList(tm0, _) in self.nil_el_list.iter_all_1(tm1) {
                self.record_action_103(delta);
            }
        }
    }
    fn record_action_104(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList) {
        let existing_row = self.els_structure.iter_all_0_1(tm1, tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElsStructure(_, _)) => (),
            None => {
                delta.new_els_structure.push(ElsStructure(tm1, tm0));
                ()
            }
        };
    }
    fn query_and_record_nil_els_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
            self.record_action_104(delta, tm0, tm1);
        }
    }
    fn record_action_105(&self, delta: &mut ModelDelta, tm1: ElList, tm2: ElList, tm3: Structure) {
        let existing_row = self.els_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElsStructure(_, _)) => (),
            None => {
                delta.new_els_structure.push(ElsStructure(tm1, tm3));
                ()
            }
        };
        let existing_row = self.els_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElsStructure(_, _)) => (),
            None => {
                delta.new_els_structure.push(ElsStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_cons_els_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ElStructure(_, tm3) in self.el_structure.iter_all_0(tm0) {
                self.record_action_105(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for ElStructure(tm0, tm3) in self.el_structure.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(_, tm1, tm2) in self.cons_el_list.iter_all_0(tm0) {
                self.record_action_105(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_106(&self, delta: &mut ModelDelta, tm2: El, tm3: Structure) {
        let existing_row = self.el_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElStructure(_, _)) => (),
            None => {
                delta.new_el_structure.push(ElStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_func_app_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncApp(tm0, tm1, tm2) in self.func_app.iter_dirty() {
            #[allow(unused_variables)]
            for ElsStructure(_, tm3) in self.els_structure.iter_all_0(tm1) {
                self.record_action_106(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for ElsStructure(tm1, tm3) in self.els_structure.iter_dirty() {
            #[allow(unused_variables)]
            for FuncApp(tm0, _, tm2) in self.func_app.iter_all_1(tm1) {
                self.record_action_106(delta, tm2, tm3);
            }
        }
    }
    fn record_action_107(&self, delta: &mut ModelDelta, tm0: Structure, tm2: El) {
        let existing_row = self.el_structure.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElStructure(_, _)) => (),
            None => {
                delta.new_el_structure.push(ElStructure(tm2, tm0));
                ()
            }
        };
    }
    fn query_and_record_var_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Var(tm0, tm1, tm2) in self.var.iter_dirty() {
            self.record_action_107(delta, tm0, tm2);
        }
    }
    fn record_action_108(&self, delta: &mut ModelDelta, tm1: ElList) {
        let existing_row = self.nil_type_list.iter_all().next();
        #[allow(unused_variables)]
        let (tm2,) = match existing_row {
            Some(NilTypeList(tm2)) => (tm2,),
            None => {
                let tm2 = delta.new_type_list(self);
                delta.new_nil_type_list.push(NilTypeList(tm2));
                (tm2,)
            }
        };
        let existing_row = self.el_types.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElTypes(_, _)) => (),
            None => {
                delta.new_el_types.push(ElTypes(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_nil_el_types(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
            self.record_action_108(delta, tm1);
        }
    }
    fn record_action_109(&self, delta: &mut ModelDelta, tm1: Type, tm3: TypeList, tm4: ElList) {
        let existing_row = self.cons_type_list.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let (tm5,) = match existing_row {
            Some(ConsTypeList(_, _, tm5)) => (tm5,),
            None => {
                let tm5 = delta.new_type_list(self);
                delta.new_cons_type_list.push(ConsTypeList(tm1, tm3, tm5));
                (tm5,)
            }
        };
        let existing_row = self.el_types.iter_all_0_1(tm4, tm5).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElTypes(_, _)) => (),
            None => {
                delta.new_el_types.push(ElTypes(tm4, tm5));
                ()
            }
        };
    }
    fn query_and_record_cons_el_types(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElType(tm0, tm1) in self.el_type.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(_, tm2, tm4) in self.cons_el_list.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ElTypes(_, tm3) in self.el_types.iter_all_0(tm2) {
                    self.record_action_109(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for ElTypes(tm2, tm3) in self.el_types.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm0, _, tm4) in self.cons_el_list.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ElType(_, tm1) in self.el_type.iter_all_0(tm0) {
                    self.record_action_109(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for ConsElList(tm0, tm2, tm4) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ElTypes(_, tm3) in self.el_types.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for ElType(_, tm1) in self.el_type.iter_all_0(tm0) {
                    self.record_action_109(delta, tm1, tm3, tm4);
                }
            }
        }
    }
    fn record_action_110(
        &self,
        delta: &mut ModelDelta,
        tm2: Type,
        tm3: TypeList,
        tm4: El,
        tm5: ElList,
    ) {
        let existing_row = self.el_type.iter_all_0_1(tm4, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElType(_, _)) => (),
            None => {
                delta.new_el_type.push(ElType(tm4, tm2));
                ()
            }
        };
        let existing_row = self.el_types.iter_all_0_1(tm5, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElTypes(_, _)) => (),
            None => {
                delta.new_el_types.push(ElTypes(tm5, tm3));
                ()
            }
        };
    }
    fn query_and_record_cons_el_types_reverse(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElTypes(tm0, tm1) in self.el_types.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm2, tm3, _) in self.cons_type_list.iter_all_2(tm1) {
                #[allow(unused_variables)]
                for ConsElList(tm4, tm5, _) in self.cons_el_list.iter_all_2(tm0) {
                    self.record_action_110(delta, tm2, tm3, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for ConsTypeList(tm2, tm3, tm1) in self.cons_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for ElTypes(tm0, _) in self.el_types.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for ConsElList(tm4, tm5, _) in self.cons_el_list.iter_all_2(tm0) {
                    self.record_action_110(delta, tm2, tm3, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for ConsElList(tm4, tm5, tm0) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ElTypes(_, tm1) in self.el_types.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ConsTypeList(tm2, tm3, _) in self.cons_type_list.iter_all_2(tm1) {
                    self.record_action_110(delta, tm2, tm3, tm4, tm5);
                }
            }
        }
    }
    fn record_action_111(
        &self,
        delta: &mut ModelDelta,
        tm1: TypeList,
        tm2: Type,
        tm3: ElList,
        tm4: El,
    ) {
        let existing_row = self.el_type.iter_all_0_1(tm4, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElType(_, _)) => (),
            None => {
                delta.new_el_type.push(ElType(tm4, tm2));
                ()
            }
        };
        let existing_row = self.el_types.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElTypes(_, _)) => (),
            None => {
                delta.new_el_types.push(ElTypes(tm3, tm1));
                ()
            }
        };
    }
    fn query_and_record_func_app_types(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Domain(tm0, tm1) in self.domain.iter_dirty() {
            #[allow(unused_variables)]
            for Codomain(_, tm2) in self.codomain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for FuncApp(_, tm3, tm4) in self.func_app.iter_all_0(tm0) {
                    self.record_action_111(delta, tm1, tm2, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for Codomain(tm0, tm2) in self.codomain.iter_dirty() {
            #[allow(unused_variables)]
            for FuncApp(_, tm3, tm4) in self.func_app.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for Domain(_, tm1) in self.domain.iter_all_0(tm0) {
                    self.record_action_111(delta, tm1, tm2, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for FuncApp(tm0, tm3, tm4) in self.func_app.iter_dirty() {
            #[allow(unused_variables)]
            for Codomain(_, tm2) in self.codomain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for Domain(_, tm1) in self.domain.iter_all_0(tm0) {
                    self.record_action_111(delta, tm1, tm2, tm3, tm4);
                }
            }
        }
    }
    fn record_action_112(&self, delta: &mut ModelDelta, tm1: ElList, tm2: TypeList) {
        let existing_row = self.el_types.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElTypes(_, _)) => (),
            None => {
                delta.new_el_types.push(ElTypes(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_pred_app_types(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredApp(tm0, tm1) in self.pred_app.iter_dirty() {
            #[allow(unused_variables)]
            for Arity(_, tm2) in self.arity.iter_all_0(tm0) {
                self.record_action_112(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for Arity(tm0, tm2) in self.arity.iter_dirty() {
            #[allow(unused_variables)]
            for PredApp(_, tm1) in self.pred_app.iter_all_0(tm0) {
                self.record_action_112(delta, tm1, tm2);
            }
        }
    }
    fn record_action_113(&self, delta: &mut ModelDelta, tm1: ElList, tm2: El) {
        let existing_row = self.constrained_el.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConstrainedEl(_)) => (),
            None => {
                delta.new_constrained_el.push(ConstrainedEl(tm2));
                ()
            }
        };
        let existing_row = self.constrained_els.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConstrainedEls(_)) => (),
            None => {
                delta.new_constrained_els.push(ConstrainedEls(tm1));
                ()
            }
        };
    }
    fn query_and_record_func_app_constrained(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncApp(tm0, tm1, tm2) in self.func_app.iter_dirty() {
            self.record_action_113(delta, tm1, tm2);
        }
    }
    fn record_action_114(&self, delta: &mut ModelDelta, tm1: ElList) {
        let existing_row = self.constrained_els.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConstrainedEls(_)) => (),
            None => {
                delta.new_constrained_els.push(ConstrainedEls(tm1));
                ()
            }
        };
    }
    fn query_and_record_pred_app_constrained(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredApp(tm0, tm1) in self.pred_app.iter_dirty() {
            self.record_action_114(delta, tm1);
        }
    }
    fn record_action_115(&self, delta: &mut ModelDelta, tm1: El, tm2: ElList) {
        let existing_row = self.constrained_el.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConstrainedEl(_)) => (),
            None => {
                delta.new_constrained_el.push(ConstrainedEl(tm1));
                ()
            }
        };
        let existing_row = self.constrained_els.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConstrainedEls(_)) => (),
            None => {
                delta.new_constrained_els.push(ConstrainedEls(tm2));
                ()
            }
        };
    }
    fn query_and_record_constrained_head_tail(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConstrainedEls(tm0) in self.constrained_els.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm1, tm2, _) in self.cons_el_list.iter_all_2(tm0) {
                self.record_action_115(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for ConsElList(tm1, tm2, tm0) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for ConstrainedEls(_) in self.constrained_els.iter_all_0(tm0) {
                self.record_action_115(delta, tm1, tm2);
            }
        }
    }
    fn record_action_116(&self, delta: &mut ModelDelta, tm1: Structure, tm3: El) {
        let existing_row = self.el_structure.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElStructure(_, _)) => (),
            None => {
                delta.new_el_structure.push(ElStructure(tm3, tm1));
                ()
            }
        };
    }
    fn query_and_record_map_el_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Cod(tm0, tm1) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(_, tm2, tm3) in self.map_el.iter_all_0(tm0) {
                self.record_action_116(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm0, tm2, tm3) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm1) in self.cod.iter_all_0(tm0) {
                self.record_action_116(delta, tm1, tm3);
            }
        }
    }
    fn record_action_117(&self, delta: &mut ModelDelta, tm1: Structure, tm3: ElList) {
        let existing_row = self.els_structure.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElsStructure(_, _)) => (),
            None => {
                delta.new_els_structure.push(ElsStructure(tm3, tm1));
                ()
            }
        };
    }
    fn query_and_record_map_els_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Cod(tm0, tm1) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(_, tm2, tm3) in self.map_els.iter_all_0(tm0) {
                self.record_action_117(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm0, tm2, tm3) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm1) in self.cod.iter_all_0(tm0) {
                self.record_action_117(delta, tm1, tm3);
            }
        }
    }
    fn record_action_118(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism) {
        let existing_row = self.map_el.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let (tm3,) = match existing_row {
            Some(MapEl(_, _, tm3)) => (tm3,),
            None => {
                let tm3 = delta.new_el(self);
                delta.new_map_el.push(MapEl(tm2, tm0, tm3));
                (tm3,)
            }
        };
    }
    fn query_and_record_map_el_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElStructure(tm0, tm1) in self.el_structure.iter_dirty() {
            #[allow(unused_variables)]
            for Dom(tm2, _) in self.dom.iter_all_1(tm1) {
                self.record_action_118(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for Dom(tm2, tm1) in self.dom.iter_dirty() {
            #[allow(unused_variables)]
            for ElStructure(tm0, _) in self.el_structure.iter_all_1(tm1) {
                self.record_action_118(delta, tm0, tm2);
            }
        }
    }
    fn record_action_119(&self, delta: &mut ModelDelta, tm0: ElList, tm2: Morphism) {
        let existing_row = self.map_els.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let (tm3,) = match existing_row {
            Some(MapEls(_, _, tm3)) => (tm3,),
            None => {
                let tm3 = delta.new_el_list(self);
                delta.new_map_els.push(MapEls(tm2, tm0, tm3));
                (tm3,)
            }
        };
    }
    fn query_and_record_map_els_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElsStructure(tm0, tm1) in self.els_structure.iter_dirty() {
            #[allow(unused_variables)]
            for Dom(tm2, _) in self.dom.iter_all_1(tm1) {
                self.record_action_119(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for Dom(tm2, tm1) in self.dom.iter_dirty() {
            #[allow(unused_variables)]
            for ElsStructure(tm0, _) in self.els_structure.iter_all_1(tm1) {
                self.record_action_119(delta, tm0, tm2);
            }
        }
    }
    fn record_action_120(&self, delta: &mut ModelDelta, tm3: Structure, tm4: ElList) {
        let existing_row = self.nil_el_list.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(NilElList(_, _)) => (),
            None => {
                delta.new_nil_el_list.push(NilElList(tm3, tm4));
                ()
            }
        };
    }
    fn query_and_record_map_nil_els(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilElList(tm0, tm1) in self.nil_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(tm2, _, tm4) in self.map_els.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for Cod(_, tm3) in self.cod.iter_all_0(tm2) {
                    self.record_action_120(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for Cod(tm2, tm3) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(_, tm1, tm4) in self.map_els.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for NilElList(tm0, _) in self.nil_el_list.iter_all_1(tm1) {
                    self.record_action_120(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm2, tm1, tm4) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm3) in self.cod.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for NilElList(tm0, _) in self.nil_el_list.iter_all_1(tm1) {
                    self.record_action_120(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_121(
        &self,
        delta: &mut ModelDelta,
        tm0: El,
        tm1: ElList,
        tm3: Morphism,
        tm4: ElList,
    ) {
        let existing_row = self.map_el.iter_all_0_1(tm3, tm0).next();
        #[allow(unused_variables)]
        let (tm5,) = match existing_row {
            Some(MapEl(_, _, tm5)) => (tm5,),
            None => {
                let tm5 = delta.new_el(self);
                delta.new_map_el.push(MapEl(tm3, tm0, tm5));
                (tm5,)
            }
        };
        let existing_row = self.map_els.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let (tm6,) = match existing_row {
            Some(MapEls(_, _, tm6)) => (tm6,),
            None => {
                let tm6 = delta.new_el_list(self);
                delta.new_map_els.push(MapEls(tm3, tm1, tm6));
                (tm6,)
            }
        };
        let existing_row = self.cons_el_list.iter_all_0_1_2(tm5, tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConsElList(_, _, _)) => (),
            None => {
                delta.new_cons_el_list.push(ConsElList(tm5, tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_map_cons_els(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsElList(tm0, tm1, tm2) in self.cons_el_list.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(tm3, _, tm4) in self.map_els.iter_all_1(tm2) {
                self.record_action_121(delta, tm0, tm1, tm3, tm4);
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm3, tm2, tm4) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for ConsElList(tm0, tm1, _) in self.cons_el_list.iter_all_2(tm2) {
                self.record_action_121(delta, tm0, tm1, tm3, tm4);
            }
        }
    }
    fn record_action_122(&self, delta: &mut ModelDelta, tm0: Func, tm4: El, tm5: ElList) {
        let existing_row = self.func_app.iter_all_0_1_2(tm0, tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(FuncApp(_, _, _)) => (),
            None => {
                delta.new_func_app.push(FuncApp(tm0, tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_map_app_func(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncApp(tm0, tm1, tm2) in self.func_app.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(tm3, _, tm4) in self.map_el.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for MapEls(_, _, tm5) in self.map_els.iter_all_0_1(tm3, tm1) {
                    self.record_action_122(delta, tm0, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm3, tm2, tm4) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(_, tm1, tm5) in self.map_els.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for FuncApp(tm0, _, _) in self.func_app.iter_all_1_2(tm1, tm2) {
                    self.record_action_122(delta, tm0, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm3, tm1, tm5) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(_, tm2, tm4) in self.map_el.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for FuncApp(tm0, _, _) in self.func_app.iter_all_1_2(tm1, tm2) {
                    self.record_action_122(delta, tm0, tm4, tm5);
                }
            }
        }
    }
    fn record_action_123(&self, delta: &mut ModelDelta, tm1: VirtIdent, tm4: Structure, tm5: El) {
        let existing_row = self.var.iter_all_0_1_2(tm4, tm1, tm5).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Var(_, _, _)) => (),
            None => {
                delta.new_var.push(Var(tm4, tm1, tm5));
                ()
            }
        };
    }
    fn query_and_record_map_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Var(tm0, tm1, tm2) in self.var.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(tm3, _, tm5) in self.map_el.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for Cod(_, tm4) in self.cod.iter_all_0(tm3) {
                    self.record_action_123(delta, tm1, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for Cod(tm3, tm4) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(_, tm2, tm5) in self.map_el.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for Var(tm0, tm1, _) in self.var.iter_all_2(tm2) {
                    self.record_action_123(delta, tm1, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm3, tm2, tm5) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm4) in self.cod.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for Var(tm0, tm1, _) in self.var.iter_all_2(tm2) {
                    self.record_action_123(delta, tm1, tm4, tm5);
                }
            }
        }
    }
    fn record_action_124(&self, delta: &mut ModelDelta, tm0: Pred, tm3: ElList) {
        let existing_row = self.pred_app.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredApp(_, _)) => (),
            None => {
                delta.new_pred_app.push(PredApp(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_map_pred_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredApp(tm0, tm1) in self.pred_app.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(tm2, _, tm3) in self.map_els.iter_all_1(tm1) {
                self.record_action_124(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm2, tm1, tm3) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for PredApp(tm0, _) in self.pred_app.iter_all_1(tm1) {
                self.record_action_124(delta, tm0, tm3);
            }
        }
    }
    fn record_action_125(&self, delta: &mut ModelDelta, tm1: Type, tm3: El) {
        let existing_row = self.el_type.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElType(_, _)) => (),
            None => {
                delta.new_el_type.push(ElType(tm3, tm1));
                ()
            }
        };
    }
    fn query_and_record_map_preserves_el_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElType(tm0, tm1) in self.el_type.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(tm2, _, tm3) in self.map_el.iter_all_1(tm0) {
                self.record_action_125(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm2, tm0, tm3) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for ElType(_, tm1) in self.el_type.iter_all_0(tm0) {
                self.record_action_125(delta, tm1, tm3);
            }
        }
    }
    fn record_action_126(&self, delta: &mut ModelDelta, tm1: Type, tm3: El) {
        let existing_row = self.el_type.iter_all_0_1(tm3, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElType(_, _)) => (),
            None => {
                delta.new_el_type.push(ElType(tm3, tm1));
                ()
            }
        };
    }
    fn query_and_record_map_reflects_el_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElType(tm0, tm1) in self.el_type.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(tm2, tm3, _) in self.map_el.iter_all_2(tm0) {
                self.record_action_126(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm2, tm3, tm0) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for ElType(_, tm1) in self.el_type.iter_all_0(tm0) {
                self.record_action_126(delta, tm1, tm3);
            }
        }
    }
    fn record_action_127(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: El, tm3: El) {
        let existing_row = self.in_ker.iter_all_0_1_2(tm0, tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(InKer(_, _, _)) => (),
            None => {
                delta.new_in_ker.push(InKer(tm0, tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_in_ker_rule(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(_, tm3, _) in self.map_el.iter_all_0_2(tm0, tm2) {
                self.record_action_127(delta, tm0, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEl(tm0, tm3, tm2) in self.map_el.iter_dirty() {
            #[allow(unused_variables)]
            for MapEl(_, tm1, _) in self.map_el.iter_all_0_2(tm0, tm2) {
                self.record_action_127(delta, tm0, tm1, tm3);
            }
        }
    }
    fn record_action_128(&self, delta: &mut ModelDelta, tm0: Morphism, tm2: El) {
        let existing_row = self.el_in_img.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElInImg(_, _)) => (),
            None => {
                delta.new_el_in_img.push(ElInImg(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_el_in_img_rule(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for MapEl(tm0, tm1, tm2) in self.map_el.iter_dirty() {
            self.record_action_128(delta, tm0, tm2);
        }
    }
    fn record_action_129(&self, delta: &mut ModelDelta, tm0: Pred, tm2: Morphism, tm3: ElList) {
        let existing_row = self.pred_tuple_in_img.iter_all_0_1_2(tm2, tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredTupleInImg(_, _, _)) => (),
            None => {
                delta
                    .new_pred_tuple_in_img
                    .push(PredTupleInImg(tm2, tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_tuple_in_img_rule(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredApp(tm0, tm1) in self.pred_app.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(tm2, _, tm3) in self.map_els.iter_all_1(tm1) {
                self.record_action_129(delta, tm0, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm2, tm1, tm3) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for PredApp(tm0, _) in self.pred_app.iter_all_1(tm1) {
                self.record_action_129(delta, tm0, tm2, tm3);
            }
        }
    }
    fn record_action_130(&self, delta: &mut ModelDelta, tm0: Func, tm3: Morphism, tm4: ElList) {
        let existing_row = self.func_app_in_img.iter_all_0_1_2(tm3, tm0, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(FuncAppInImg(_, _, _)) => (),
            None => {
                delta.new_func_app_in_img.push(FuncAppInImg(tm3, tm0, tm4));
                ()
            }
        };
    }
    fn query_and_record_func_app_in_img_rule(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncApp(tm0, tm1, tm2) in self.func_app.iter_dirty() {
            #[allow(unused_variables)]
            for MapEls(tm3, _, tm4) in self.map_els.iter_all_1(tm1) {
                self.record_action_130(delta, tm0, tm3, tm4);
            }
        }
        #[allow(unused_variables)]
        for MapEls(tm3, tm1, tm4) in self.map_els.iter_dirty() {
            #[allow(unused_variables)]
            for FuncApp(tm0, _, tm2) in self.func_app.iter_all_1(tm1) {
                self.record_action_130(delta, tm0, tm3, tm4);
            }
        }
    }
    fn record_action_131(&self, delta: &mut ModelDelta) {
        let existing_row = self.initial_structure.iter_all().next();
        #[allow(unused_variables)]
        let (tm0,) = match existing_row {
            Some(InitialStructure(tm0)) => (tm0,),
            None => {
                let tm0 = delta.new_structure(self);
                delta.new_initial_structure.push(InitialStructure(tm0));
                (tm0,)
            }
        };
    }
    fn query_and_record_initial_structure_total(&self, delta: &mut ModelDelta) {
        if self.empty_join_is_dirty {
            self.record_action_131(delta);
        }
    }
    fn record_action_132(&self, delta: &mut ModelDelta, tm0: Structure) {
        let existing_row = self.initiality_morphism.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(InitialityMorphism(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_morphism(self);
                delta
                    .new_initiality_morphism
                    .push(InitialityMorphism(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_initiality_morphism_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.structure_dirty.iter().copied() {
            self.record_action_132(delta, tm0);
        }
    }
    fn record_action_133(
        &self,
        delta: &mut ModelDelta,
        tm0: Structure,
        tm1: Structure,
        tm2: Morphism,
    ) {
        let existing_row = self.dom.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Dom(_, _)) => (),
            None => {
                delta.new_dom.push(Dom(tm2, tm0));
                ()
            }
        };
        let existing_row = self.cod.iter_all_0_1(tm2, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Cod(_, _)) => (),
            None => {
                delta.new_cod.push(Cod(tm2, tm1));
                ()
            }
        };
    }
    fn query_and_record_dom_cod_initiality_morphism(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for InitialStructure(tm0) in self.initial_structure.iter_dirty() {
            #[allow(unused_variables)]
            for InitialityMorphism(tm1, tm2) in self.initiality_morphism.iter_all() {
                self.record_action_133(delta, tm0, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for InitialityMorphism(tm1, tm2) in self.initiality_morphism.iter_dirty() {
            #[allow(unused_variables)]
            for InitialStructure(tm0) in self.initial_structure.iter_all() {
                self.record_action_133(delta, tm0, tm1, tm2);
            }
        }
    }
    fn record_action_134(&self, delta: &mut ModelDelta, tm0: Morphism, tm2: Structure) {
        let existing_row = self.initiality_morphism.iter_all_0_1(tm2, tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(InitialityMorphism(_, _)) => (),
            None => {
                delta
                    .new_initiality_morphism
                    .push(InitialityMorphism(tm2, tm0));
                ()
            }
        };
    }
    fn query_and_record_initiality_uniqueness(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for Dom(tm0, tm1) in self.dom.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for InitialStructure(_) in self.initial_structure.iter_all_0(tm1) {
                    self.record_action_134(delta, tm0, tm2);
                }
            }
        }
        #[allow(unused_variables)]
        for Cod(tm0, tm2) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for Dom(_, tm1) in self.dom.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for InitialStructure(_) in self.initial_structure.iter_all_0(tm1) {
                    self.record_action_134(delta, tm0, tm2);
                }
            }
        }
        #[allow(unused_variables)]
        for InitialStructure(tm1) in self.initial_structure.iter_dirty() {
            #[allow(unused_variables)]
            for Dom(tm0, _) in self.dom.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                    self.record_action_134(delta, tm0, tm2);
                }
            }
        }
    }
    fn record_action_135(&self, delta: &mut ModelDelta, tm0: Chain) {
        let existing_row = self.chain_head_structure.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm2,) = match existing_row {
            Some(ChainHeadStructure(_, tm2)) => (tm2,),
            None => {
                let tm2 = delta.new_structure(self);
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm0, tm2));
                (tm2,)
            }
        };
    }
    fn query_and_record_chain_head_structure_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainTail(tm0, tm1) in self.chain_tail.iter_dirty() {
            self.record_action_135(delta, tm0);
        }
    }
    fn record_action_136(&self, delta: &mut ModelDelta, tm0: Chain) {
        let existing_row = self.chain_head_transition.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm3,) = match existing_row {
            Some(ChainHeadTransition(_, tm3)) => (tm3,),
            None => {
                let tm3 = delta.new_morphism(self);
                delta
                    .new_chain_head_transition
                    .push(ChainHeadTransition(tm0, tm3));
                (tm3,)
            }
        };
    }
    fn query_and_record_chain_head_transition_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainTail(tm0, tm1) in self.chain_tail.iter_dirty() {
            #[allow(unused_variables)]
            for ChainTail(_, tm2) in self.chain_tail.iter_all_0(tm1) {
                self.record_action_136(delta, tm0);
            }
        }
        #[allow(unused_variables)]
        for ChainTail(tm1, tm2) in self.chain_tail.iter_dirty() {
            #[allow(unused_variables)]
            for ChainTail(tm0, _) in self.chain_tail.iter_all_1(tm1) {
                self.record_action_136(delta, tm0);
            }
        }
    }
    fn record_action_137(
        &self,
        delta: &mut ModelDelta,
        tm2: Structure,
        tm3: Structure,
        tm4: Morphism,
    ) {
        let existing_row = self.dom.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Dom(_, _)) => (),
            None => {
                delta.new_dom.push(Dom(tm4, tm3));
                ()
            }
        };
        let existing_row = self.cod.iter_all_0_1(tm4, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Cod(_, _)) => (),
            None => {
                delta.new_cod.push(Cod(tm4, tm2));
                ()
            }
        };
    }
    fn query_and_record_chain_transition_signature(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ChainTail(tm0, tm1) in self.chain_tail.iter_dirty() {
            #[allow(unused_variables)]
            for ChainHeadStructure(_, tm3) in self.chain_head_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm2) in self.chain_head_structure.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ChainHeadTransition(_, tm4) in self.chain_head_transition.iter_all_0(tm0) {
                        self.record_action_137(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm1, tm2) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for ChainTail(tm0, _) in self.chain_tail.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for ChainHeadTransition(_, tm4) in self.chain_head_transition.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm3) in self.chain_head_structure.iter_all_0(tm0) {
                        self.record_action_137(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm0, tm3) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for ChainHeadTransition(_, tm4) in self.chain_head_transition.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ChainTail(_, tm1) in self.chain_tail.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm2) in self.chain_head_structure.iter_all_0(tm1) {
                        self.record_action_137(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadTransition(tm0, tm4) in self.chain_head_transition.iter_dirty() {
            #[allow(unused_variables)]
            for ChainHeadStructure(_, tm3) in self.chain_head_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ChainTail(_, tm1) in self.chain_tail.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm2) in self.chain_head_structure.iter_all_0(tm1) {
                        self.record_action_137(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_138(&self, delta: &mut ModelDelta) {
        let existing_row = self.type_symbol.iter_all().next();
        #[allow(unused_variables)]
        let (tm0,) = match existing_row {
            Some(TypeSymbol(tm0)) => (tm0,),
            None => {
                let tm0 = delta.new_symbol_kind(self);
                delta.new_type_symbol.push(TypeSymbol(tm0));
                (tm0,)
            }
        };
        let existing_row = self.pred_symbol.iter_all().next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(PredSymbol(tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_symbol_kind(self);
                delta.new_pred_symbol.push(PredSymbol(tm1));
                (tm1,)
            }
        };
        let existing_row = self.func_symbol.iter_all().next();
        #[allow(unused_variables)]
        let (tm2,) = match existing_row {
            Some(FuncSymbol(tm2)) => (tm2,),
            None => {
                let tm2 = delta.new_symbol_kind(self);
                delta.new_func_symbol.push(FuncSymbol(tm2));
                (tm2,)
            }
        };
        let existing_row = self.rule_symbol.iter_all().next();
        #[allow(unused_variables)]
        let (tm3,) = match existing_row {
            Some(RuleSymbol(tm3)) => (tm3,),
            None => {
                let tm3 = delta.new_symbol_kind(self);
                delta.new_rule_symbol.push(RuleSymbol(tm3));
                (tm3,)
            }
        };
    }
    fn query_and_record_138(&self, delta: &mut ModelDelta) {
        if self.empty_join_is_dirty {
            self.record_action_138(delta);
        }
    }
    fn record_action_139(&self, delta: &mut ModelDelta, tm1: Ident, tm2: Loc, tm3: SymbolKind) {
        let existing_row = self.defined_symbol.iter_all_0_1_2(tm1, tm3, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(DefinedSymbol(_, _, _)) => (),
            None => {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm3, tm2));
                ()
            }
        };
    }
    fn query_and_record_type_decl_defines_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TypeDecl(tm0, tm1) in self.type_decl.iter_dirty() {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(_, tm2) in self.type_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                    self.record_action_139(delta, tm1, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeDeclNodeLoc(tm0, tm2) in self.type_decl_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for TypeDecl(_, tm1) in self.type_decl.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                    self.record_action_139(delta, tm1, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeSymbol(tm3) in self.type_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for TypeDeclNodeLoc(tm0, tm2) in self.type_decl_node_loc.iter_all() {
                #[allow(unused_variables)]
                for TypeDecl(_, tm1) in self.type_decl.iter_all_0(tm0) {
                    self.record_action_139(delta, tm1, tm2, tm3);
                }
            }
        }
    }
    fn record_action_140(&self, delta: &mut ModelDelta, tm1: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.defined_symbol.iter_all_0_1_2(tm1, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(DefinedSymbol(_, _, _)) => (),
            None => {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_decl_defines_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredDecl(tm0, tm1, tm2) in self.pred_decl.iter_dirty() {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(_, tm3) in self.pred_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_140(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for PredDeclNodeLoc(tm0, tm3) in self.pred_decl_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for PredDecl(_, tm1, tm2) in self.pred_decl.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_140(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for PredSymbol(tm4) in self.pred_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for PredDeclNodeLoc(tm0, tm3) in self.pred_decl_node_loc.iter_all() {
                #[allow(unused_variables)]
                for PredDecl(_, tm1, tm2) in self.pred_decl.iter_all_0(tm0) {
                    self.record_action_140(delta, tm1, tm3, tm4);
                }
            }
        }
    }
    fn record_action_141(&self, delta: &mut ModelDelta, tm1: Ident, tm4: Loc, tm5: SymbolKind) {
        let existing_row = self.defined_symbol.iter_all_0_1_2(tm1, tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(DefinedSymbol(_, _, _)) => (),
            None => {
                delta.new_defined_symbol.push(DefinedSymbol(tm1, tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_func_decl_defines_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for FuncDecl(tm0, tm1, tm2, tm3) in self.func_decl.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(_, tm4) in self.func_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for FuncSymbol(tm5) in self.func_symbol.iter_all() {
                    self.record_action_141(delta, tm1, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for FuncDeclNodeLoc(tm0, tm4) in self.func_decl_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDecl(_, tm1, tm2, tm3) in self.func_decl.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for FuncSymbol(tm5) in self.func_symbol.iter_all() {
                    self.record_action_141(delta, tm1, tm4, tm5);
                }
            }
        }
        #[allow(unused_variables)]
        for FuncSymbol(tm5) in self.func_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for FuncDeclNodeLoc(tm0, tm4) in self.func_decl_node_loc.iter_all() {
                #[allow(unused_variables)]
                for FuncDecl(_, tm1, tm2, tm3) in self.func_decl.iter_all_0(tm0) {
                    self.record_action_141(delta, tm1, tm4, tm5);
                }
            }
        }
    }
    fn record_action_142(&self, delta: &mut ModelDelta, tm2: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.defined_symbol.iter_all_0_1_2(tm2, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(DefinedSymbol(_, _, _)) => (),
            None => {
                delta.new_defined_symbol.push(DefinedSymbol(tm2, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_rule_decl_defines_symbol(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(_, tm3) in self.rule_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleSymbol(tm4) in self.rule_symbol.iter_all() {
                        self.record_action_142(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleName(tm0, tm2) in self.rule_name.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(_, tm3) in self.rule_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleSymbol(tm4) in self.rule_symbol.iter_all() {
                        self.record_action_142(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleDeclNodeLoc(tm0, tm3) in self.rule_decl_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleSymbol(tm4) in self.rule_symbol.iter_all() {
                        self.record_action_142(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RuleSymbol(tm4) in self.rule_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDeclNodeLoc(tm0, tm3) in self.rule_decl_node_loc.iter_all() {
                #[allow(unused_variables)]
                for RuleName(_, tm2) in self.rule_name.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                        self.record_action_142(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_143(&self, delta: &mut ModelDelta, tm1: Ident, tm2: Loc, tm3: SymbolKind) {
        let existing_row = self.should_be_symbol.iter_all_0_1_2(tm1, tm3, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSymbol(_, _, _)) => (),
            None => {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm3, tm2));
                ()
            }
        };
    }
    fn query_and_record_arg_decl_should_be_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ArgDeclNodeType(tm0, tm1) in self.arg_decl_node_type.iter_dirty() {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(_, tm2) in self.arg_decl_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                    self.record_action_143(delta, tm1, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for ArgDeclNodeLoc(tm0, tm2) in self.arg_decl_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for ArgDeclNodeType(_, tm1) in self.arg_decl_node_type.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm3) in self.type_symbol.iter_all() {
                    self.record_action_143(delta, tm1, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeSymbol(tm3) in self.type_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for ArgDeclNodeLoc(tm0, tm2) in self.arg_decl_node_loc.iter_all() {
                #[allow(unused_variables)]
                for ArgDeclNodeType(_, tm1) in self.arg_decl_node_type.iter_all_0(tm0) {
                    self.record_action_143(delta, tm1, tm2, tm3);
                }
            }
        }
    }
    fn record_action_144(&self, delta: &mut ModelDelta, tm2: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.should_be_symbol.iter_all_0_1_2(tm2, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSymbol(_, _, _)) => (),
            None => {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm2, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_atom_should_be_type(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm4) in self.type_symbol.iter_all() {
                    self.record_action_144(delta, tm2, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for IfAtomNodeLoc(tm0, tm3) in self.if_atom_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TypeSymbol(tm4) in self.type_symbol.iter_all() {
                    self.record_action_144(delta, tm2, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeSymbol(tm4) in self.type_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm3) in self.if_atom_node_loc.iter_all() {
                #[allow(unused_variables)]
                for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                    self.record_action_144(delta, tm2, tm3, tm4);
                }
            }
        }
    }
    fn record_action_145(&self, delta: &mut ModelDelta, tm1: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.should_be_symbol.iter_all_0_1_2(tm1, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSymbol(_, _, _)) => (),
            None => {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_if_atom_should_be_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_145(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for IfAtomNodeLoc(tm0, tm3) in self.if_atom_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_145(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for PredSymbol(tm4) in self.pred_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomNodeLoc(tm0, tm3) in self.if_atom_node_loc.iter_all() {
                #[allow(unused_variables)]
                for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                    self.record_action_145(delta, tm1, tm3, tm4);
                }
            }
        }
    }
    fn record_action_146(&self, delta: &mut ModelDelta, tm1: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.should_be_symbol.iter_all_0_1_2(tm1, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSymbol(_, _, _)) => (),
            None => {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_then_atom_should_be_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_146(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for ThenAtomNodeLoc(tm0, tm3) in self.then_atom_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for PredSymbol(tm4) in self.pred_symbol.iter_all() {
                    self.record_action_146(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for PredSymbol(tm4) in self.pred_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for ThenAtomNodeLoc(tm0, tm3) in self.then_atom_node_loc.iter_all() {
                #[allow(unused_variables)]
                for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                    self.record_action_146(delta, tm1, tm3, tm4);
                }
            }
        }
    }
    fn record_action_147(&self, delta: &mut ModelDelta, tm1: Ident, tm3: Loc, tm4: SymbolKind) {
        let existing_row = self.should_be_symbol.iter_all_0_1_2(tm1, tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSymbol(_, _, _)) => (),
            None => {
                delta
                    .new_should_be_symbol
                    .push(ShouldBeSymbol(tm1, tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_app_atom_should_be_func(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for FuncSymbol(tm4) in self.func_symbol.iter_all() {
                    self.record_action_147(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TermNodeLoc(tm0, tm3) in self.term_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for FuncSymbol(tm4) in self.func_symbol.iter_all() {
                    self.record_action_147(delta, tm1, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for FuncSymbol(tm4) in self.func_symbol.iter_dirty() {
            #[allow(unused_variables)]
            for TermNodeLoc(tm0, tm3) in self.term_node_loc.iter_all() {
                #[allow(unused_variables)]
                for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                    self.record_action_147(delta, tm1, tm3, tm4);
                }
            }
        }
    }
    fn record_action_148(&self, delta: &mut ModelDelta, tm0: TypeList) {
        let existing_row = self.type_list_len.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(TypeListLen(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_nat(self);
                delta.new_type_list_len.push(TypeListLen(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_type_list_len_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.type_list_dirty.iter().copied() {
            self.record_action_148(delta, tm0);
        }
    }
    fn record_action_149(&self, delta: &mut ModelDelta, tm1: Nat) {
        let existing_row = self.zero.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Zero(_)) => (),
            None => {
                delta.new_zero.push(Zero(tm1));
                ()
            }
        };
    }
    fn query_and_record_type_list_len_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilTypeList(tm0) in self.nil_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm1) in self.type_list_len.iter_all_0(tm0) {
                self.record_action_149(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm0, tm1) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for NilTypeList(_) in self.nil_type_list.iter_all_0(tm0) {
                self.record_action_149(delta, tm1);
            }
        }
    }
    fn record_action_150(&self, delta: &mut ModelDelta, tm3: Nat, tm4: Nat) {
        let existing_row = self.succ.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Succ(_, _)) => (),
            None => {
                delta.new_succ.push(Succ(tm3, tm4));
                ()
            }
        };
    }
    fn query_and_record_type_list_len_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTypeList(tm0, tm1, tm2) in self.cons_type_list.iter_dirty() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm4) in self.type_list_len.iter_all_0(tm2) {
                    self.record_action_150(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm1, tm3) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, _, tm2) in self.cons_type_list.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm4) in self.type_list_len.iter_all_0(tm2) {
                    self.record_action_150(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm2, tm4) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTypeList(tm0, tm1, _) in self.cons_type_list.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm3) in self.type_list_len.iter_all_0(tm1) {
                    self.record_action_150(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_151(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        let existing_row = self.term_list_len.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(TermListLen(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_nat(self);
                delta.new_term_list_len.push(TermListLen(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_term_list_len_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.term_list_node_dirty.iter().copied() {
            self.record_action_151(delta, tm0);
        }
    }
    fn record_action_152(&self, delta: &mut ModelDelta, tm1: Nat) {
        let existing_row = self.zero.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Zero(_)) => (),
            None => {
                delta.new_zero.push(Zero(tm1));
                ()
            }
        };
    }
    fn query_and_record_term_list_len_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilTermListNode(tm0) in self.nil_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermListLen(_, tm1) in self.term_list_len.iter_all_0(tm0) {
                self.record_action_152(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm0, tm1) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                self.record_action_152(delta, tm1);
            }
        }
    }
    fn record_action_153(&self, delta: &mut ModelDelta, tm3: Nat, tm4: Nat) {
        let existing_row = self.succ.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Succ(_, _)) => (),
            None => {
                delta.new_succ.push(Succ(tm3, tm4));
                ()
            }
        };
    }
    fn query_and_record_term_list_len_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for TermListLen(_, tm4) in self.term_list_len.iter_all_0(tm0) {
                    self.record_action_153(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm2, tm3) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, _) in self.cons_term_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for TermListLen(_, tm4) in self.term_list_len.iter_all_0(tm0) {
                    self.record_action_153(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm0, tm4) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TermListLen(_, tm3) in self.term_list_len.iter_all_0(tm2) {
                    self.record_action_153(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_154(&self, delta: &mut ModelDelta, tm3: Loc, tm6: Nat, tm7: Nat) {
        let existing_row = self
            .pred_arg_num_should_match
            .iter_all_0_1_2(tm7, tm6, tm3)
            .next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredArgNumShouldMatch(_, _, _)) => (),
            None => {
                delta
                    .new_pred_arg_num_should_match
                    .push(PredArgNumShouldMatch(tm7, tm6, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_if_atom_arg_num_should_match(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for IfAtomNodeLoc(tm0, tm3) in self.if_atom_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticPred(tm1, tm4) in self.semantic_pred.iter_dirty() {
            #[allow(unused_variables)]
            for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for Arity(tm4, tm5) in self.arity.iter_dirty() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for Arity(tm4, _) in self.arity.iter_all_1(tm5) {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm2, tm7) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, _) in self.pred_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for IfAtomNodeLoc(_, tm3) in self.if_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_154(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_155(&self, delta: &mut ModelDelta, tm3: Loc, tm6: Nat, tm7: Nat) {
        let existing_row = self
            .pred_arg_num_should_match
            .iter_all_0_1_2(tm7, tm6, tm3)
            .next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredArgNumShouldMatch(_, _, _)) => (),
            None => {
                delta
                    .new_pred_arg_num_should_match
                    .push(PredArgNumShouldMatch(tm7, tm6, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_then_atom_arg_num_should_match(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ThenAtomNodeLoc(tm0, tm3) in self.then_atom_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticPred(tm1, tm4) in self.semantic_pred.iter_dirty() {
            #[allow(unused_variables)]
            for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for Arity(tm4, tm5) in self.arity.iter_dirty() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for Arity(tm4, _) in self.arity.iter_all_1(tm5) {
                #[allow(unused_variables)]
                for SemanticPred(tm1, _) in self.semantic_pred.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm2, tm7) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, _) in self.pred_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm4) in self.semantic_pred.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Arity(_, tm5) in self.arity.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for ThenAtomNodeLoc(_, tm3) in self.then_atom_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_155(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_156(&self, delta: &mut ModelDelta, tm3: Loc, tm6: Nat, tm7: Nat) {
        let existing_row = self
            .func_arg_num_should_match
            .iter_all_0_1_2(tm7, tm6, tm3)
            .next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(FuncArgNumShouldMatch(_, _, _)) => (),
            None => {
                delta
                    .new_func_arg_num_should_match
                    .push(FuncArgNumShouldMatch(tm7, tm6, tm3));
                ()
            }
        };
    }
    fn query_and_record_app_term_arg_num_should_match(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                        #[allow(unused_variables)]
                        for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermNodeLoc(tm0, tm3) in self.term_node_loc.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticFunc(tm1, tm4) in self.semantic_func.iter_dirty() {
            #[allow(unused_variables)]
            for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for Domain(tm4, tm5) in self.domain.iter_dirty() {
            #[allow(unused_variables)]
            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TypeListLen(tm5, tm6) in self.type_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for Domain(tm4, _) in self.domain.iter_all_1(tm5) {
                #[allow(unused_variables)]
                for SemanticFunc(tm1, _) in self.semantic_func.iter_all_1(tm4) {
                    #[allow(unused_variables)]
                    for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                        #[allow(unused_variables)]
                        for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TermListLen(_, tm7) in self.term_list_len.iter_all_0(tm2) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermListLen(tm2, tm7) in self.term_list_len.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, _) in self.app_term_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm4) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for Domain(_, tm5) in self.domain.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for TermNodeLoc(_, tm3) in self.term_node_loc.iter_all_0(tm0) {
                            #[allow(unused_variables)]
                            for TypeListLen(_, tm6) in self.type_list_len.iter_all_0(tm5) {
                                self.record_action_156(delta, tm3, tm6, tm7);
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_157(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        let existing_row = self.rule_chain.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(RuleChain(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_chain(self);
                delta.new_rule_chain.push(RuleChain(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_rule_chain_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.rule_decl_node_dirty.iter().copied() {
            self.record_action_157(delta, tm0);
        }
    }
    fn record_action_158(&self, delta: &mut ModelDelta, tm2: Chain, tm3: Chain) {
        let existing_row = self.initial_structure.iter_all().next();
        #[allow(unused_variables)]
        let (tm4,) = match existing_row {
            Some(InitialStructure(tm4)) => (tm4,),
            None => {
                let tm4 = delta.new_structure(self);
                delta.new_initial_structure.push(InitialStructure(tm4));
                (tm4,)
            }
        };
        let existing_row = self.chain_tail.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm2, tm3));
                ()
            }
        };
        let existing_row = self.chain_head_structure.iter_all_0_1(tm2, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainHeadStructure(_, _)) => (),
            None => {
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm2, tm4));
                ()
            }
        };
    }
    fn query_and_record_rule_stmt_list_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChain(_, tm2) in self.rule_chain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                    self.record_action_158(delta, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChain(tm0, tm2) in self.rule_chain.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                    self.record_action_158(delta, tm2, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm1, tm3) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDecl(tm0, _) in self.rule_decl.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for RuleChain(_, tm2) in self.rule_chain.iter_all_0(tm0) {
                    self.record_action_158(delta, tm2, tm3);
                }
            }
        }
    }
    fn record_action_159(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
        let existing_row = self.stmt_list_chain.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(StmtListChain(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_chain(self);
                delta.new_stmt_list_chain.push(StmtListChain(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_stmt_list_chain_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.stmt_list_node_dirty.iter().copied() {
            self.record_action_159(delta, tm0);
        }
    }
    fn record_action_160(&self, delta: &mut ModelDelta, tm1: Chain) {
        let existing_row = self.nil_chain.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(NilChain(_)) => (),
            None => {
                delta.new_nil_chain.push(NilChain(tm1));
                ()
            }
        };
    }
    fn query_and_record_stmt_list_chain_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilStmtListNode(tm0) in self.nil_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm1) in self.stmt_list_chain.iter_all_0(tm0) {
                self.record_action_160(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm0, tm1) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                self.record_action_160(delta, tm1);
            }
        }
    }
    fn record_action_161(&self, delta: &mut ModelDelta, tm3: Chain, tm4: Chain) {
        let existing_row = self.chain_tail.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_stmt_list_chain_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm4) in self.stmt_list_chain.iter_all_0(tm0) {
                    self.record_action_161(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm2, tm3) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, tm1, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm4) in self.stmt_list_chain.iter_all_0(tm0) {
                    self.record_action_161(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm0, tm4) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm2) {
                    self.record_action_161(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_162(&self, delta: &mut ModelDelta, tm1: StmtNode, tm4: Structure) {
        let existing_row = self.stmt_structure.iter_all_0_1(tm1, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(StmtStructure(_, _)) => (),
            None => {
                delta.new_stmt_structure.push(StmtStructure(tm1, tm4));
                ()
            }
        };
    }
    fn query_and_record_stmt_structure_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                    self.record_action_162(delta, tm1, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm3, tm4) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(tm0, _) in self.stmt_list_chain.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                    self.record_action_162(delta, tm1, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm0, tm3) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                    self.record_action_162(delta, tm1, tm4);
                }
            }
        }
    }
    fn record_action_163(&self, delta: &mut ModelDelta, tm1: IfAtomNode, tm2: Structure) {
        let existing_row = self.if_atom_structure.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(IfAtomStructure(_, _)) => (),
            None => {
                delta.new_if_atom_structure.push(IfAtomStructure(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_if_stmt_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtStructure(_, tm2) in self.stmt_structure.iter_all_0(tm0) {
                self.record_action_163(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for StmtStructure(tm0, tm2) in self.stmt_structure.iter_dirty() {
            #[allow(unused_variables)]
            for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                self.record_action_163(delta, tm1, tm2);
            }
        }
    }
    fn record_action_164(&self, delta: &mut ModelDelta, tm1: ThenAtomNode, tm2: Structure) {
        let existing_row = self.then_atom_structure.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ThenAtomStructure(_, _)) => (),
            None => {
                delta
                    .new_then_atom_structure
                    .push(ThenAtomStructure(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_then_stmt_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtStructure(_, tm2) in self.stmt_structure.iter_all_0(tm0) {
                self.record_action_164(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for StmtStructure(tm0, tm2) in self.stmt_structure.iter_dirty() {
            #[allow(unused_variables)]
            for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                self.record_action_164(delta, tm1, tm2);
            }
        }
    }
    fn record_action_165(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: Structure,
    ) {
        let existing_row = self.term_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
                ()
            }
        };
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_equal_if_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.record_action_165(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                self.record_action_165(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_166(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: Structure) {
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_defined_if_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm2) in self.if_atom_structure.iter_all_0(tm0) {
                self.record_action_166(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for IfAtomStructure(tm0, tm2) in self.if_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                self.record_action_166(delta, tm1, tm2);
            }
        }
    }
    fn record_action_167(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: Structure) {
        let existing_row = self.terms_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsStructure(_, _)) => (),
            None => {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_if_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.record_action_167(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                self.record_action_167(delta, tm2, tm3);
            }
        }
    }
    fn record_action_168(&self, delta: &mut ModelDelta, tm1: TermNode, tm3: Structure) {
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_if_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for IfAtomStructure(_, tm3) in self.if_atom_structure.iter_all_0(tm0) {
                self.record_action_168(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for IfAtomStructure(tm0, tm3) in self.if_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                self.record_action_168(delta, tm1, tm3);
            }
        }
    }
    fn record_action_169(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: Structure,
    ) {
        let existing_row = self.term_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
                ()
            }
        };
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_equal_then_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.record_action_169(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                self.record_action_169(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_170(
        &self,
        delta: &mut ModelDelta,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: Structure,
    ) {
        let existing_row = self.term_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm2, tm3));
                ()
            }
        };
        let existing_row = self.opt_term_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(OptTermStructure(_, _)) => (),
            None => {
                delta
                    .new_opt_term_structure
                    .push(OptTermStructure(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_defined_then_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.record_action_170(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0) {
                self.record_action_170(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_171(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: Structure) {
        let existing_row = self.terms_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsStructure(_, _)) => (),
            None => {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_pred_then_atom_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for ThenAtomStructure(_, tm3) in self.then_atom_structure.iter_all_0(tm0) {
                self.record_action_171(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for ThenAtomStructure(tm0, tm3) in self.then_atom_structure.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                self.record_action_171(delta, tm2, tm3);
            }
        }
    }
    fn record_action_172(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm3: Structure,
    ) {
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm3));
                ()
            }
        };
        let existing_row = self.terms_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsStructure(_, _)) => (),
            None => {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_cons_term_list_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermsStructure(_, tm3) in self.terms_structure.iter_all_0(tm0) {
                self.record_action_172(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for TermsStructure(tm0, tm3) in self.terms_structure.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.record_action_172(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_173(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: Structure) {
        let existing_row = self.term_structure.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermStructure(_, _)) => (),
            None => {
                delta.new_term_structure.push(TermStructure(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_some_opt_term_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for OptTermStructure(_, tm2) in self.opt_term_structure.iter_all_0(tm0) {
                self.record_action_173(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for OptTermStructure(tm0, tm2) in self.opt_term_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                self.record_action_173(delta, tm1, tm2);
            }
        }
    }
    fn record_action_174(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: Structure) {
        let existing_row = self.terms_structure.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsStructure(_, _)) => (),
            None => {
                delta.new_terms_structure.push(TermsStructure(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_app_term_structure(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermStructure(_, tm3) in self.term_structure.iter_all_0(tm0) {
                self.record_action_174(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for TermStructure(tm0, tm3) in self.term_structure.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.record_action_174(delta, tm2, tm3);
            }
        }
    }
    fn record_action_175(&self, delta: &mut ModelDelta, tm0: TermNode) {
        let existing_row = self.semantic_el.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(SemanticEl(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_el(self);
                delta.new_semantic_el.push(SemanticEl(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_semantic_el_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.term_node_dirty.iter().copied() {
            self.record_action_175(delta, tm0);
        }
    }
    fn record_action_176(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        let existing_row = self.semantic_els.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(SemanticEls(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_el_list(self);
                delta.new_semantic_els.push(SemanticEls(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_semantic_els_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.term_list_node_dirty.iter().copied() {
            self.record_action_176(delta, tm0);
        }
    }
    fn record_action_177(&self, delta: &mut ModelDelta, tm1: Structure, tm2: ElList) {
        let existing_row = self.nil_el_list.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(NilElList(_, _)) => (),
            None => {
                delta.new_nil_el_list.push(NilElList(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_semantic_els_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilTermListNode(tm0) in self.nil_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermsStructure(_, tm1) in self.terms_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm2) in self.semantic_els.iter_all_0(tm0) {
                    self.record_action_177(delta, tm1, tm2);
                }
            }
        }
        #[allow(unused_variables)]
        for TermsStructure(tm0, tm1) in self.terms_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEls(_, tm2) in self.semantic_els.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                    self.record_action_177(delta, tm1, tm2);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm0, tm2) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for TermsStructure(_, tm1) in self.terms_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for NilTermListNode(_) in self.nil_term_list_node.iter_all_0(tm0) {
                    self.record_action_177(delta, tm1, tm2);
                }
            }
        }
    }
    fn record_action_178(&self, delta: &mut ModelDelta, tm3: El, tm4: ElList, tm5: ElList) {
        let existing_row = self.cons_el_list.iter_all_0_1_2(tm3, tm4, tm5).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ConsElList(_, _, _)) => (),
            None => {
                delta.new_cons_el_list.push(ConsElList(tm3, tm4, tm5));
                ()
            }
        };
    }
    fn query_and_record_semantic_els_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm0) {
                        self.record_action_178(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm1, tm3) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, _, tm2) in self.cons_term_list_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                        self.record_action_178(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm2, tm4) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, _) in self.cons_term_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm0) {
                        self.record_action_178(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm0, tm5) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                        self.record_action_178(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_179(&self, delta: &mut ModelDelta, tm1: Structure, tm2: El) {
        let existing_row = self.el_structure.iter_all_0_1(tm2, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElStructure(_, _)) => (),
            None => {
                delta.new_el_structure.push(ElStructure(tm2, tm1));
                ()
            }
        };
    }
    fn query_and_record_semantic_el_struct(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermStructure(tm0, tm1) in self.term_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2) in self.semantic_el.iter_all_0(tm0) {
                self.record_action_179(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm2) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for TermStructure(_, tm1) in self.term_structure.iter_all_0(tm0) {
                self.record_action_179(delta, tm1, tm2);
            }
        }
    }
    fn record_action_180(&self, delta: &mut ModelDelta, tm1: Structure, tm2: ElList) {
        let existing_row = self.els_structure.iter_all_0_1(tm2, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElsStructure(_, _)) => (),
            None => {
                delta.new_els_structure.push(ElsStructure(tm2, tm1));
                ()
            }
        };
    }
    fn query_and_record_semantic_els_struct(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermsStructure(tm0, tm1) in self.terms_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEls(_, tm2) in self.semantic_els.iter_all_0(tm0) {
                self.record_action_180(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm0, tm2) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for TermsStructure(_, tm1) in self.terms_structure.iter_all_0(tm0) {
                self.record_action_180(delta, tm1, tm2);
            }
        }
    }
    fn record_action_181(&self, delta: &mut ModelDelta, tm3: Func, tm4: El, tm5: ElList) {
        let existing_row = self.func_app.iter_all_0_1_2(tm3, tm5, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(FuncApp(_, _, _)) => (),
            None => {
                delta.new_func_app.push(FuncApp(tm3, tm5, tm4));
                ()
            }
        };
    }
    fn query_and_record_app_term_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm2) {
                        self.record_action_181(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticFunc(tm1, tm3) in self.semantic_func.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(tm0, _, tm2) in self.app_term_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                        self.record_action_181(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEls(_, tm5) in self.semantic_els.iter_all_0(tm2) {
                        self.record_action_181(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm2, tm5) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, _) in self.app_term_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticFunc(_, tm3) in self.semantic_func.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                        self.record_action_181(delta, tm3, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_182(&self, delta: &mut ModelDelta, tm2: VirtIdent, tm3: Structure, tm4: El) {
        let existing_row = self.var.iter_all_0_1_2(tm3, tm2, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Var(_, _, _)) => (),
            None => {
                delta.new_var.push(Var(tm3, tm2, tm4));
                ()
            }
        };
    }
    fn query_and_record_var_term_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermStructure(_, tm3) in self.term_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                        self.record_action_182(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for RealVirtIdent(tm1, tm2) in self.real_virt_ident.iter_dirty() {
            #[allow(unused_variables)]
            for VarTermNode(tm0, _) in self.var_term_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for TermStructure(_, tm3) in self.term_structure.iter_all_0(tm0) {
                        self.record_action_182(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermStructure(tm0, tm3) in self.term_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm1) {
                        self.record_action_182(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for TermStructure(_, tm3) in self.term_structure.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm1) {
                        self.record_action_182(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_183(&self, delta: &mut ModelDelta, tm0: TermNode) {
        let existing_row = self.wildcard_virt_ident.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(WildcardVirtIdent(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_virt_ident(self);
                delta
                    .new_wildcard_virt_ident
                    .push(WildcardVirtIdent(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_wildcard_virt_ident_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for WildcardTermNode(tm0) in self.wildcard_term_node.iter_dirty() {
            self.record_action_183(delta, tm0);
        }
    }
    fn record_action_184(&self, delta: &mut ModelDelta, tm1: Structure, tm2: El, tm3: VirtIdent) {
        let existing_row = self.var.iter_all_0_1_2(tm1, tm3, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(Var(_, _, _)) => (),
            None => {
                delta.new_var.push(Var(tm1, tm3, tm2));
                ()
            }
        };
    }
    fn query_and_record_wildcard_term_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for WildcardTermNode(tm0) in self.wildcard_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2) in self.semantic_el.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TermStructure(_, tm1) in self.term_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for WildcardVirtIdent(_, tm3) in self.wildcard_virt_ident.iter_all_0(tm0) {
                        self.record_action_184(delta, tm1, tm2, tm3);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for TermStructure(tm0, tm1) in self.term_structure.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2) in self.semantic_el.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for WildcardVirtIdent(_, tm3) in self.wildcard_virt_ident.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                        self.record_action_184(delta, tm1, tm2, tm3);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm2) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for WildcardVirtIdent(_, tm3) in self.wildcard_virt_ident.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TermStructure(_, tm1) in self.term_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                        self.record_action_184(delta, tm1, tm2, tm3);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for WildcardVirtIdent(tm0, tm3) in self.wildcard_virt_ident.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm2) in self.semantic_el.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for TermStructure(_, tm1) in self.term_structure.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                        self.record_action_184(delta, tm1, tm2, tm3);
                    }
                }
            }
        }
    }
    fn record_action_185(&self, delta: &mut ModelDelta, tm3: El, tm4: El) {
        if tm3 != tm4 {
            delta.new_el_equalities.push((tm3, tm4));
        }
        if tm4 != tm3 {
            delta.new_el_equalities.push((tm4, tm3));
        }
    }
    fn query_and_record_equal_if_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_185(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm2, tm3) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, _) in self.equal_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_185(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm1, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, _, tm2) in self.equal_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm2) {
                    self.record_action_185(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_186(&self, delta: &mut ModelDelta, tm3: Pred, tm4: ElList) {
        let existing_row = self.pred_app.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredApp(_, _)) => (),
            None => {
                delta.new_pred_app.push(PredApp(tm3, tm4));
                ()
            }
        };
    }
    fn query_and_record_pred_if_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                    self.record_action_186(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, _, tm2) in self.pred_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                    self.record_action_186(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm2, tm4) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, _) in self.pred_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                    self.record_action_186(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_187(&self, delta: &mut ModelDelta, tm3: Type, tm4: El) {
        let existing_row = self.el_type.iter_all_0_1(tm4, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElType(_, _)) => (),
            None => {
                delta.new_el_type.push(ElType(tm4, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_if_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticType(_, tm3) in self.semantic_type.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_187(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticType(tm2, tm3) in self.semantic_type.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, tm1, _) in self.var_if_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_187(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm1, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, _, tm2) in self.var_if_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticType(_, tm3) in self.semantic_type.iter_all_0(tm2) {
                    self.record_action_187(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_188(&self, delta: &mut ModelDelta, tm3: El, tm4: El) {
        if tm3 != tm4 {
            delta.new_el_equalities.push((tm3, tm4));
        }
        if tm4 != tm3 {
            delta.new_el_equalities.push((tm4, tm3));
        }
    }
    fn query_and_record_equal_then_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_188(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm2, tm3) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, _) in self.equal_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm1) {
                    self.record_action_188(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm1, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, _, tm2) in self.equal_then_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm3) in self.semantic_el.iter_all_0(tm2) {
                    self.record_action_188(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_189(&self, delta: &mut ModelDelta, tm4: El, tm5: El) {
        if tm4 != tm5 {
            delta.new_el_equalities.push((tm4, tm5));
        }
        if tm5 != tm4 {
            delta.new_el_equalities.push((tm5, tm4));
        }
    }
    fn query_and_record_defined_then_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm2, _, tm3) in self.defined_then_atom_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm5) in self.semantic_el.iter_all_0(tm1) {
                        self.record_action_189(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm2, tm0, tm3) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm3) {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm5) in self.semantic_el.iter_all_0(tm1) {
                        self.record_action_189(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm3, tm4) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm2, tm0, _) in self.defined_then_atom_node.iter_all_2(tm3) {
                #[allow(unused_variables)]
                for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm5) in self.semantic_el.iter_all_0(tm1) {
                        self.record_action_189(delta, tm4, tm5);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm1, tm5) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for SomeTermNode(tm0, _) in self.some_term_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for DefinedThenAtomNode(tm2, _, tm3) in self.defined_then_atom_node.iter_all_1(tm0)
                {
                    #[allow(unused_variables)]
                    for SemanticEl(_, tm4) in self.semantic_el.iter_all_0(tm3) {
                        self.record_action_189(delta, tm4, tm5);
                    }
                }
            }
        }
    }
    fn record_action_190(&self, delta: &mut ModelDelta, tm3: Pred, tm4: ElList) {
        let existing_row = self.pred_app.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(PredApp(_, _)) => (),
            None => {
                delta.new_pred_app.push(PredApp(tm3, tm4));
                ()
            }
        };
    }
    fn query_and_record_pred_then_atom_semantics(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                    self.record_action_190(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticPred(tm1, tm3) in self.semantic_pred.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, _, tm2) in self.pred_then_atom_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for SemanticEls(_, tm4) in self.semantic_els.iter_all_0(tm2) {
                    self.record_action_190(delta, tm3, tm4);
                }
            }
        }
        #[allow(unused_variables)]
        for SemanticEls(tm2, tm4) in self.semantic_els.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, _) in self.pred_then_atom_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for SemanticPred(_, tm3) in self.semantic_pred.iter_all_0(tm1) {
                    self.record_action_190(delta, tm3, tm4);
                }
            }
        }
    }
    fn record_action_191(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
        let existing_row = self.grouped_rule_chain.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm2,) = match existing_row {
            Some(GroupedRuleChain(_, tm2)) => (tm2,),
            None => {
                let tm2 = delta.new_chain(self);
                delta
                    .new_grouped_rule_chain
                    .push(GroupedRuleChain(tm0, tm2));
                (tm2,)
            }
        };
    }
    fn query_and_record_grouped_rule_chain_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
            self.record_action_191(delta, tm0);
        }
    }
    fn record_action_192(&self, delta: &mut ModelDelta, tm2: Structure, tm3: Chain, tm4: Chain) {
        let existing_row = self.chain_tail.iter_all_0_1(tm3, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm3, tm4));
                ()
            }
        };
        let existing_row = self.chain_head_structure.iter_all_0_1(tm3, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainHeadStructure(_, _)) => (),
            None => {
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm3, tm2));
                ()
            }
        };
    }
    fn query_and_record_grouped_rule_stmt_list_chain(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for RuleDecl(tm0, tm1) in self.rule_decl.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedRuleChain(_, tm3) in self.grouped_rule_chain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm4) in self.grouped_stmt_list_chain.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for InitialStructure(tm2) in self.initial_structure.iter_all() {
                        self.record_action_192(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for InitialStructure(tm2) in self.initial_structure.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedRuleChain(tm0, tm3) in self.grouped_rule_chain.iter_all() {
                #[allow(unused_variables)]
                for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for GroupedStmtListChain(_, tm4) in self.grouped_stmt_list_chain.iter_all_0(tm1)
                    {
                        self.record_action_192(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedRuleChain(tm0, tm3) in self.grouped_rule_chain.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDecl(_, tm1) in self.rule_decl.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm4) in self.grouped_stmt_list_chain.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for InitialStructure(tm2) in self.initial_structure.iter_all() {
                        self.record_action_192(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm1, tm4) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for RuleDecl(tm0, _) in self.rule_decl.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for GroupedRuleChain(_, tm3) in self.grouped_rule_chain.iter_all_0(tm0) {
                    #[allow(unused_variables)]
                    for InitialStructure(tm2) in self.initial_structure.iter_all() {
                        self.record_action_192(delta, tm2, tm3, tm4);
                    }
                }
            }
        }
    }
    fn record_action_193(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
        let existing_row = self.grouped_stmt_list_chain.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let (tm1,) = match existing_row {
            Some(GroupedStmtListChain(_, tm1)) => (tm1,),
            None => {
                let tm1 = delta.new_chain(self);
                delta
                    .new_grouped_stmt_list_chain
                    .push(GroupedStmtListChain(tm0, tm1));
                (tm1,)
            }
        };
    }
    fn query_and_record_grouped_stmt_list_chain_total(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for tm0 in self.stmt_list_node_dirty.iter().copied() {
            self.record_action_193(delta, tm0);
        }
    }
    fn record_action_194(&self, delta: &mut ModelDelta, tm1: Chain) {
        let existing_row = self.nil_chain.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(NilChain(_)) => (),
            None => {
                delta.new_nil_chain.push(NilChain(tm1));
                ()
            }
        };
    }
    fn query_and_record_grouped_stmt_list_chain_nil(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilStmtListNode(tm0) in self.nil_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm1) in self.grouped_stmt_list_chain.iter_all_0(tm0) {
                self.record_action_194(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm0, tm1) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                self.record_action_194(delta, tm1);
            }
        }
    }
    fn record_action_195(&self, delta: &mut ModelDelta, tm4: StmtListNode, tm7: Chain) {
        let existing_row = self.grouped_stmt_list_chain.iter_all_0_1(tm4, tm7).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(GroupedStmtListChain(_, _)) => (),
            None => {
                delta
                    .new_grouped_stmt_list_chain
                    .push(GroupedStmtListChain(tm4, tm7));
                ()
            }
        };
    }
    fn query_and_record_grouped_chain_if_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, _, tm5) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm7) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            self.record_action_195(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for IfStmtNode(tm2, tm3) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6)
                    {
                        #[allow(unused_variables)]
                        for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                            self.record_action_195(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm0, tm5) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                            self.record_action_195(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm6, tm2, tm4) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                            self.record_action_195(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm6, tm7) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm3) in self.if_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                            self.record_action_195(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
    }
    fn record_action_196(&self, delta: &mut ModelDelta, tm4: StmtListNode, tm7: Chain) {
        let existing_row = self.grouped_stmt_list_chain.iter_all_0_1(tm4, tm7).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(GroupedStmtListChain(_, _)) => (),
            None => {
                delta
                    .new_grouped_stmt_list_chain
                    .push(GroupedStmtListChain(tm4, tm7));
                ()
            }
        };
    }
    fn query_and_record_stmt_list_chain_then_then(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, _, tm5) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm7) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            self.record_action_196(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ThenStmtNode(tm2, tm3) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6)
                    {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_196(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm0, tm5) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_196(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm6, tm2, tm4) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm7) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_196(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm6, tm7) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm2, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_196(delta, tm4, tm7);
                        }
                    }
                }
            }
        }
    }
    fn record_action_197(&self, delta: &mut ModelDelta, tm4: Structure, tm5: Chain, tm6: Chain) {
        let existing_row = self.chain_tail.iter_all_0_1(tm6, tm5).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm6, tm5));
                ()
            }
        };
        let existing_row = self.chain_head_structure.iter_all_0_1(tm6, tm4).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainHeadStructure(_, _)) => (),
            None => {
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm6, tm4));
                ()
            }
        };
    }
    fn query_and_record_stmt_list_chain_singleton(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for NilStmtListNode(tm0) in self.nil_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm5) in self.grouped_stmt_list_chain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm1, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm0) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3)
                        {
                            #[allow(unused_variables)]
                            for GroupedStmtListChain(_, tm6) in
                                self.grouped_stmt_list_chain.iter_all_0(tm1)
                            {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm1, tm2, tm0) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm5) in self.grouped_stmt_list_chain.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm6) in
                            self.grouped_stmt_list_chain.iter_all_0(tm1)
                        {
                            #[allow(unused_variables)]
                            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm3, tm4) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(tm1, _) in self.stmt_list_chain.iter_all_1(tm3) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm6) in self.grouped_stmt_list_chain.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm0) in self.cons_stmt_list_node.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm5) in
                            self.grouped_stmt_list_chain.iter_all_0(tm0)
                        {
                            #[allow(unused_variables)]
                            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm1, tm3) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm6) in self.grouped_stmt_list_chain.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm0) in self.cons_stmt_list_node.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm5) in
                            self.grouped_stmt_list_chain.iter_all_0(tm0)
                        {
                            #[allow(unused_variables)]
                            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm0, tm5) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm1, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm6) in
                            self.grouped_stmt_list_chain.iter_all_0(tm1)
                        {
                            #[allow(unused_variables)]
                            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm1, tm6) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm3) in self.stmt_list_chain.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm4) in self.chain_head_structure.iter_all_0(tm3) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm0) in self.cons_stmt_list_node.iter_all_0(tm1) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm5) in
                            self.grouped_stmt_list_chain.iter_all_0(tm0)
                        {
                            #[allow(unused_variables)]
                            for NilStmtListNode(_) in self.nil_stmt_list_node.iter_all_0(tm0) {
                                self.record_action_197(delta, tm4, tm5, tm6);
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_198(&self, delta: &mut ModelDelta, tm8: Structure, tm9: Chain, tm10: Chain) {
        let existing_row = self.chain_tail.iter_all_0_1(tm10, tm9).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm10, tm9));
                ()
            }
        };
        let existing_row = self.chain_head_structure.iter_all_0_1(tm10, tm8).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainHeadStructure(_, _)) => (),
            None => {
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm10, tm8));
                ()
            }
        };
    }
    fn query_and_record_grouped_chain_if_then(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for GroupedStmtListChain(_, tm10) in
                                        self.grouped_stmt_list_chain.iter_all_0(tm6)
                                    {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ThenStmtNode(tm2, tm3) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, _, tm5) in self.cons_stmt_list_node.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm0, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7)
                        {
                            #[allow(unused_variables)]
                            for GroupedStmtListChain(_, tm9) in
                                self.grouped_stmt_list_chain.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for GroupedStmtListChain(_, tm10) in
                                    self.grouped_stmt_list_chain.iter_all_0(tm6)
                                {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm2, tm5) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm9) in self.grouped_stmt_list_chain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm0, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7)
                        {
                            #[allow(unused_variables)]
                            for GroupedStmtListChain(_, tm10) in
                                self.grouped_stmt_list_chain.iter_all_0(tm6)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm6, tm0, tm4) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm9) in self.grouped_stmt_list_chain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm10) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm7, tm8) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(tm6, _) in self.stmt_list_chain.iter_all_1(tm7) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm10) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm6, tm7) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm10) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm4, tm9) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, tm0, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm10) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm6, tm10) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm2, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_198(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_199(&self, delta: &mut ModelDelta, tm8: Structure, tm9: Chain, tm10: Chain) {
        let existing_row = self.chain_tail.iter_all_0_1(tm10, tm9).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainTail(_, _)) => (),
            None => {
                delta.new_chain_tail.push(ChainTail(tm10, tm9));
                ()
            }
        };
        let existing_row = self.chain_head_structure.iter_all_0_1(tm10, tm8).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ChainHeadStructure(_, _)) => (),
            None => {
                delta
                    .new_chain_head_structure
                    .push(ChainHeadStructure(tm10, tm8));
                ()
            }
        };
    }
    fn query_and_record_grouped_chain_then_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, _, tm5) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7)
                        {
                            #[allow(unused_variables)]
                            for GroupedStmtListChain(_, tm9) in
                                self.grouped_stmt_list_chain.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for GroupedStmtListChain(_, tm10) in
                                        self.grouped_stmt_list_chain.iter_all_0(tm6)
                                    {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ThenStmtNode(tm2, tm3) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for GroupedStmtListChain(_, tm10) in
                                    self.grouped_stmt_list_chain.iter_all_0(tm6)
                                {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm0, tm5) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm9) in self.grouped_stmt_list_chain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7)
                        {
                            #[allow(unused_variables)]
                            for GroupedStmtListChain(_, tm10) in
                                self.grouped_stmt_list_chain.iter_all_0(tm6)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm6, tm2, tm4) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm9) in self.grouped_stmt_list_chain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm10) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadStructure(tm7, tm8) in self.chain_head_structure.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(tm6, _) in self.stmt_list_chain.iter_all_1(tm7) {
                #[allow(unused_variables)]
                for GroupedStmtListChain(_, tm10) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm6, tm7) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for GroupedStmtListChain(_, tm10) in self.grouped_stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm4, tm9) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm10) in
                            self.grouped_stmt_list_chain.iter_all_0(tm6)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for GroupedStmtListChain(tm6, tm10) in self.grouped_stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm7) in self.stmt_list_chain.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ChainHeadStructure(_, tm8) in self.chain_head_structure.iter_all_0(tm7) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm2, tm4) in self.cons_stmt_list_node.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for GroupedStmtListChain(_, tm9) in
                            self.grouped_stmt_list_chain.iter_all_0(tm4)
                        {
                            #[allow(unused_variables)]
                            for ConsStmtListNode(_, tm0, tm5) in
                                self.cons_stmt_list_node.iter_all_0(tm4)
                            {
                                #[allow(unused_variables)]
                                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                                    #[allow(unused_variables)]
                                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                                        self.record_action_199(delta, tm8, tm9, tm10);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn record_action_200(
        &self,
        delta: &mut ModelDelta,
        tm1: StmtNode,
        tm2: StmtListNode,
        tm3: VirtIdent,
    ) {
        let existing_row = self.var_before_stmt.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeStmt(_, _)) => (),
            None => {
                delta.new_var_before_stmt.push(VarBeforeStmt(tm1, tm3));
                ()
            }
        };
        let existing_row = self.var_before_stmts.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeStmts(_, _)) => (),
            None => {
                delta.new_var_before_stmts.push(VarBeforeStmts(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_stmts_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeStmts(_, tm3) in self.var_before_stmts.iter_all_0(tm0) {
                self.record_action_200(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeStmts(tm0, tm3) in self.var_before_stmts.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm1, tm2) in self.cons_stmt_list_node.iter_all_0(tm0) {
                self.record_action_200(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_201(&self, delta: &mut ModelDelta, tm1: IfAtomNode, tm2: VirtIdent) {
        let existing_row = self.var_before_if_atom.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeIfAtom(_, _)) => (),
            None => {
                delta.new_var_before_if_atom.push(VarBeforeIfAtom(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_before_stmt_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeStmt(_, tm2) in self.var_before_stmt.iter_all_0(tm0) {
                self.record_action_201(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeStmt(tm0, tm2) in self.var_before_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                self.record_action_201(delta, tm1, tm2);
            }
        }
    }
    fn record_action_202(&self, delta: &mut ModelDelta, tm1: ThenAtomNode, tm2: VirtIdent) {
        let existing_row = self.var_before_then_atom.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeThenAtom(_, _)) => (),
            None => {
                delta
                    .new_var_before_then_atom
                    .push(VarBeforeThenAtom(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_before_stmt_then(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeStmt(_, tm2) in self.var_before_stmt.iter_all_0(tm0) {
                self.record_action_202(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeStmt(tm0, tm2) in self.var_before_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                self.record_action_202(delta, tm1, tm2);
            }
        }
    }
    fn record_action_203(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: VirtIdent,
    ) {
        let existing_row = self.var_before_term.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm2, tm3));
                ()
            }
        };
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_if_atom_equal(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeIfAtom(_, tm3) in self.var_before_if_atom.iter_all_0(tm0) {
                self.record_action_203(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeIfAtom(tm0, tm3) in self.var_before_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(_, tm1, tm2) in self.equal_if_atom_node.iter_all_0(tm0) {
                self.record_action_203(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_204(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: VirtIdent) {
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_before_if_atom_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeIfAtom(_, tm2) in self.var_before_if_atom.iter_all_0(tm0) {
                self.record_action_204(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeIfAtom(tm0, tm2) in self.var_before_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(_, tm1) in self.defined_if_atom_node.iter_all_0(tm0) {
                self.record_action_204(delta, tm1, tm2);
            }
        }
    }
    fn record_action_205(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: VirtIdent) {
        let existing_row = self.var_before_terms.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerms(_, _)) => (),
            None => {
                delta.new_var_before_terms.push(VarBeforeTerms(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_if_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeIfAtom(_, tm3) in self.var_before_if_atom.iter_all_0(tm0) {
                self.record_action_205(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeIfAtom(tm0, tm3) in self.var_before_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(_, tm1, tm2) in self.pred_if_atom_node.iter_all_0(tm0) {
                self.record_action_205(delta, tm2, tm3);
            }
        }
    }
    fn record_action_206(&self, delta: &mut ModelDelta, tm1: TermNode, tm3: VirtIdent) {
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_if_atom_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeIfAtom(_, tm3) in self.var_before_if_atom.iter_all_0(tm0) {
                self.record_action_206(delta, tm1, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeIfAtom(tm0, tm3) in self.var_before_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(_, tm1, tm2) in self.var_if_atom_node.iter_all_0(tm0) {
                self.record_action_206(delta, tm1, tm3);
            }
        }
    }
    fn record_action_207(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermNode,
        tm3: VirtIdent,
    ) {
        let existing_row = self.var_before_term.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm2, tm3));
                ()
            }
        };
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_then_atom_equal(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeThenAtom(_, tm3) in self.var_before_then_atom.iter_all_0(tm0) {
                self.record_action_207(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeThenAtom(tm0, tm3) in self.var_before_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(_, tm1, tm2) in self.equal_then_atom_node.iter_all_0(tm0) {
                self.record_action_207(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_208(
        &self,
        delta: &mut ModelDelta,
        tm1: OptTermNode,
        tm2: TermNode,
        tm3: VirtIdent,
    ) {
        let existing_row = self.var_before_term.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm2, tm3));
                ()
            }
        };
        let existing_row = self.var_before_opt_term.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeOptTerm(_, _)) => (),
            None => {
                delta
                    .new_var_before_opt_term
                    .push(VarBeforeOptTerm(tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_then_atom_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeThenAtom(_, tm3) in self.var_before_then_atom.iter_all_0(tm0) {
                self.record_action_208(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeThenAtom(tm0, tm3) in self.var_before_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(_, tm1, tm2) in self.defined_then_atom_node.iter_all_0(tm0) {
                self.record_action_208(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_209(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: VirtIdent) {
        let existing_row = self.var_before_terms.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerms(_, _)) => (),
            None => {
                delta.new_var_before_terms.push(VarBeforeTerms(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_then_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeThenAtom(_, tm3) in self.var_before_then_atom.iter_all_0(tm0) {
                self.record_action_209(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeThenAtom(tm0, tm3) in self.var_before_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(_, tm1, tm2) in self.pred_then_atom_node.iter_all_0(tm0) {
                self.record_action_209(delta, tm2, tm3);
            }
        }
    }
    fn record_action_210(
        &self,
        delta: &mut ModelDelta,
        tm1: TermNode,
        tm2: TermListNode,
        tm3: VirtIdent,
    ) {
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm3));
                ()
            }
        };
        let existing_row = self.var_before_terms.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerms(_, _)) => (),
            None => {
                delta.new_var_before_terms.push(VarBeforeTerms(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_terms_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeTerms(_, tm3) in self.var_before_terms.iter_all_0(tm0) {
                self.record_action_210(delta, tm1, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeTerms(tm0, tm3) in self.var_before_terms.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.record_action_210(delta, tm1, tm2, tm3);
            }
        }
    }
    fn record_action_211(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: VirtIdent) {
        let existing_row = self.var_before_term.iter_all_0_1(tm1, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerm(_, _)) => (),
            None => {
                delta.new_var_before_term.push(VarBeforeTerm(tm1, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_before_opt_term_some(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeOptTerm(_, tm2) in self.var_before_opt_term.iter_all_0(tm0) {
                self.record_action_211(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeOptTerm(tm0, tm2) in self.var_before_opt_term.iter_dirty() {
            #[allow(unused_variables)]
            for SomeTermNode(_, tm1) in self.some_term_node.iter_all_0(tm0) {
                self.record_action_211(delta, tm1, tm2);
            }
        }
    }
    fn record_action_212(&self, delta: &mut ModelDelta, tm2: TermListNode, tm3: VirtIdent) {
        let existing_row = self.var_before_terms.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeTerms(_, _)) => (),
            None => {
                delta.new_var_before_terms.push(VarBeforeTerms(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_before_term_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarBeforeTerm(_, tm3) in self.var_before_term.iter_all_0(tm0) {
                self.record_action_212(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarBeforeTerm(tm0, tm3) in self.var_before_term.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.record_action_212(delta, tm2, tm3);
            }
        }
    }
    fn record_action_213(&self, delta: &mut ModelDelta, tm0: TermNode, tm2: VirtIdent) {
        let existing_row = self.var_in_term.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInTerm(_, _)) => (),
            None => {
                delta.new_var_in_term.push(VarInTerm(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_in_term_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for RealVirtIdent(_, tm2) in self.real_virt_ident.iter_all_0(tm1) {
                self.record_action_213(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for RealVirtIdent(tm1, tm2) in self.real_virt_ident.iter_dirty() {
            #[allow(unused_variables)]
            for VarTermNode(tm0, _) in self.var_term_node.iter_all_1(tm1) {
                self.record_action_213(delta, tm0, tm2);
            }
        }
    }
    fn record_action_214(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
        let existing_row = self.var_in_term.iter_all_0_1(tm0, tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInTerm(_, _)) => (),
            None => {
                delta.new_var_in_term.push(VarInTerm(tm0, tm1));
                ()
            }
        };
    }
    fn query_and_record_var_in_term_wildcard(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for WildcardTermNode(tm0) in self.wildcard_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for WildcardVirtIdent(_, tm1) in self.wildcard_virt_ident.iter_all_0(tm0) {
                self.record_action_214(delta, tm0, tm1);
            }
        }
        #[allow(unused_variables)]
        for WildcardVirtIdent(tm0, tm1) in self.wildcard_virt_ident.iter_dirty() {
            #[allow(unused_variables)]
            for WildcardTermNode(_) in self.wildcard_term_node.iter_all_0(tm0) {
                self.record_action_214(delta, tm0, tm1);
            }
        }
    }
    fn record_action_215(&self, delta: &mut ModelDelta, tm0: TermNode, tm3: VirtIdent) {
        let existing_row = self.var_in_term.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInTerm(_, _)) => (),
            None => {
                delta.new_var_in_term.push(VarInTerm(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_term_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerms(_, tm3) in self.var_in_terms.iter_all_0(tm2) {
                self.record_action_215(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerms(tm2, tm3) in self.var_in_terms.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(tm0, tm1, _) in self.app_term_node.iter_all_2(tm2) {
                self.record_action_215(delta, tm0, tm3);
            }
        }
    }
    fn record_action_216(&self, delta: &mut ModelDelta, tm0: TermListNode, tm3: VirtIdent) {
        let existing_row = self.var_in_terms.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInTerms(_, _)) => (),
            None => {
                delta.new_var_in_terms.push(VarInTerms(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_terms_cons_head(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_216(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, _, tm2) in self.cons_term_list_node.iter_all_1(tm1) {
                self.record_action_216(delta, tm0, tm3);
            }
        }
    }
    fn record_action_217(&self, delta: &mut ModelDelta, tm0: TermListNode, tm3: VirtIdent) {
        let existing_row = self.var_in_terms.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInTerms(_, _)) => (),
            None => {
                delta.new_var_in_terms.push(VarInTerms(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_terms_cons_tail(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerms(_, tm3) in self.var_in_terms.iter_all_0(tm2) {
                self.record_action_217(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerms(tm2, tm3) in self.var_in_terms.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, _) in self.cons_term_list_node.iter_all_2(tm2) {
                self.record_action_217(delta, tm0, tm3);
            }
        }
    }
    fn record_action_218(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm2: VirtIdent) {
        let existing_row = self.var_in_opt_term.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInOptTerm(_, _)) => (),
            None => {
                delta.new_var_in_opt_term.push(VarInOptTerm(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_in_opt_terms(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for SomeTermNode(tm0, tm1) in self.some_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm2) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_218(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm2) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for SomeTermNode(tm0, _) in self.some_term_node.iter_all_1(tm1) {
                self.record_action_218(delta, tm0, tm2);
            }
        }
    }
    fn record_action_219(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_if_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInIfAtom(_, _)) => (),
            None => {
                delta.new_var_in_if_atom.push(VarInIfAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_if_atom_equal_lhs(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_219(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, _, tm2) in self.equal_if_atom_node.iter_all_1(tm1) {
                self.record_action_219(delta, tm0, tm3);
            }
        }
    }
    fn record_action_220(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_if_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInIfAtom(_, _)) => (),
            None => {
                delta.new_var_in_if_atom.push(VarInIfAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_if_atom_equal_rhs(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualIfAtomNode(tm0, tm1, tm2) in self.equal_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm2) {
                self.record_action_220(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm2, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualIfAtomNode(tm0, tm1, _) in self.equal_if_atom_node.iter_all_2(tm2) {
                self.record_action_220(delta, tm0, tm3);
            }
        }
    }
    fn record_action_221(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm2: VirtIdent) {
        let existing_row = self.var_in_if_atom.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInIfAtom(_, _)) => (),
            None => {
                delta.new_var_in_if_atom.push(VarInIfAtom(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_in_if_atom_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedIfAtomNode(tm0, tm1) in self.defined_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm2) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_221(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm2) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedIfAtomNode(tm0, _) in self.defined_if_atom_node.iter_all_1(tm1) {
                self.record_action_221(delta, tm0, tm2);
            }
        }
    }
    fn record_action_222(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_if_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInIfAtom(_, _)) => (),
            None => {
                delta.new_var_in_if_atom.push(VarInIfAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_if_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredIfAtomNode(tm0, tm1, tm2) in self.pred_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerms(_, tm3) in self.var_in_terms.iter_all_0(tm2) {
                self.record_action_222(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerms(tm2, tm3) in self.var_in_terms.iter_dirty() {
            #[allow(unused_variables)]
            for PredIfAtomNode(tm0, tm1, _) in self.pred_if_atom_node.iter_all_2(tm2) {
                self.record_action_222(delta, tm0, tm3);
            }
        }
    }
    fn record_action_223(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_if_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInIfAtom(_, _)) => (),
            None => {
                delta.new_var_in_if_atom.push(VarInIfAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_if_atom_var(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarIfAtomNode(tm0, tm1, tm2) in self.var_if_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_223(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for VarIfAtomNode(tm0, _, tm2) in self.var_if_atom_node.iter_all_1(tm1) {
                self.record_action_223(delta, tm0, tm3);
            }
        }
    }
    fn record_action_224(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_then_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInThenAtom(_, _)) => (),
            None => {
                delta.new_var_in_then_atom.push(VarInThenAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_then_atom_equal_lhs(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm1) {
                self.record_action_224(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm1, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, _, tm2) in self.equal_then_atom_node.iter_all_1(tm1) {
                self.record_action_224(delta, tm0, tm3);
            }
        }
    }
    fn record_action_225(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_then_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInThenAtom(_, _)) => (),
            None => {
                delta.new_var_in_then_atom.push(VarInThenAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_then_atom_equal_rhs(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm2) {
                self.record_action_225(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm2, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for EqualThenAtomNode(tm0, tm1, _) in self.equal_then_atom_node.iter_all_2(tm2) {
                self.record_action_225(delta, tm0, tm3);
            }
        }
    }
    fn record_action_226(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_then_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInThenAtom(_, _)) => (),
            None => {
                delta.new_var_in_then_atom.push(VarInThenAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_then_atom_defined_var_term(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInOptTerm(_, tm3) in self.var_in_opt_term.iter_all_0(tm1) {
                self.record_action_226(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInOptTerm(tm1, tm3) in self.var_in_opt_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, _, tm2) in self.defined_then_atom_node.iter_all_1(tm1) {
                self.record_action_226(delta, tm0, tm3);
            }
        }
    }
    fn record_action_227(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_then_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInThenAtom(_, _)) => (),
            None => {
                delta.new_var_in_then_atom.push(VarInThenAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_then_atom_defined_term(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerm(_, tm3) in self.var_in_term.iter_all_0(tm2) {
                self.record_action_227(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerm(tm2, tm3) in self.var_in_term.iter_dirty() {
            #[allow(unused_variables)]
            for DefinedThenAtomNode(tm0, tm1, _) in self.defined_then_atom_node.iter_all_2(tm2) {
                self.record_action_227(delta, tm0, tm3);
            }
        }
    }
    fn record_action_228(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm3: VirtIdent) {
        let existing_row = self.var_in_then_atom.iter_all_0_1(tm0, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInThenAtom(_, _)) => (),
            None => {
                delta.new_var_in_then_atom.push(VarInThenAtom(tm0, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_then_atom_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInTerms(_, tm3) in self.var_in_terms.iter_all_0(tm2) {
                self.record_action_228(delta, tm0, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInTerms(tm2, tm3) in self.var_in_terms.iter_dirty() {
            #[allow(unused_variables)]
            for PredThenAtomNode(tm0, tm1, _) in self.pred_then_atom_node.iter_all_2(tm2) {
                self.record_action_228(delta, tm0, tm3);
            }
        }
    }
    fn record_action_229(&self, delta: &mut ModelDelta, tm0: StmtNode, tm2: VirtIdent) {
        let existing_row = self.var_in_stmt.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInStmt(_, _)) => (),
            None => {
                delta.new_var_in_stmt.push(VarInStmt(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_in_stmt_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInIfAtom(_, tm2) in self.var_in_if_atom.iter_all_0(tm1) {
                self.record_action_229(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarInIfAtom(tm1, tm2) in self.var_in_if_atom.iter_dirty() {
            #[allow(unused_variables)]
            for IfStmtNode(tm0, _) in self.if_stmt_node.iter_all_1(tm1) {
                self.record_action_229(delta, tm0, tm2);
            }
        }
    }
    fn record_action_230(&self, delta: &mut ModelDelta, tm0: StmtNode, tm2: VirtIdent) {
        let existing_row = self.var_in_stmt.iter_all_0_1(tm0, tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarInStmt(_, _)) => (),
            None => {
                delta.new_var_in_stmt.push(VarInStmt(tm0, tm2));
                ()
            }
        };
    }
    fn query_and_record_var_in_stmt_then(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInThenAtom(_, tm2) in self.var_in_then_atom.iter_all_0(tm1) {
                self.record_action_230(delta, tm0, tm2);
            }
        }
        #[allow(unused_variables)]
        for VarInThenAtom(tm1, tm2) in self.var_in_then_atom.iter_dirty() {
            #[allow(unused_variables)]
            for ThenStmtNode(tm0, _) in self.then_stmt_node.iter_all_1(tm1) {
                self.record_action_230(delta, tm0, tm2);
            }
        }
    }
    fn record_action_231(&self, delta: &mut ModelDelta, tm2: StmtListNode, tm3: VirtIdent) {
        let existing_row = self.var_before_stmts.iter_all_0_1(tm2, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarBeforeStmts(_, _)) => (),
            None => {
                delta.new_var_before_stmts.push(VarBeforeStmts(tm2, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_in_var_before(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsStmtListNode(tm0, tm1, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for VarInStmt(_, tm3) in self.var_in_stmt.iter_all_0(tm1) {
                self.record_action_231(delta, tm2, tm3);
            }
        }
        #[allow(unused_variables)]
        for VarInStmt(tm1, tm3) in self.var_in_stmt.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm0, _, tm2) in self.cons_stmt_list_node.iter_all_1(tm1) {
                self.record_action_231(delta, tm2, tm3);
            }
        }
    }
    fn record_action_232(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: TermListNode) {
        let existing_row = self.term_should_be_epic_ok.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm1));
                ()
            }
        };
        let existing_row = self.terms_should_be_epic_ok.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
                ()
            }
        };
    }
    fn query_and_record_terms_should_be_epic_ok_cons(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermsShouldBeEpicOk(_) in self.terms_should_be_epic_ok.iter_all_0(tm0) {
                self.record_action_232(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for TermsShouldBeEpicOk(tm0) in self.terms_should_be_epic_ok.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.record_action_232(delta, tm1, tm2);
            }
        }
    }
    fn record_action_233(&self, delta: &mut ModelDelta, tm2: TermListNode) {
        let existing_row = self.terms_should_be_epic_ok.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
                ()
            }
        };
    }
    fn query_and_record_terms_should_be_epic_ok_app(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermShouldBeEpicOk(_) in self.term_should_be_epic_ok.iter_all_0(tm0) {
                self.record_action_233(delta, tm2);
            }
        }
        #[allow(unused_variables)]
        for TermShouldBeEpicOk(tm0) in self.term_should_be_epic_ok.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.record_action_233(delta, tm2);
            }
        }
    }
    fn record_action_234(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: TermNode) {
        let existing_row = self.term_should_be_epic_ok.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm2));
                ()
            }
        };
        let existing_row = self.term_should_be_epic_ok.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm1));
                ()
            }
        };
    }
    fn query_and_record_then_atom_epic_ok_equal(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for EqualThenAtomNode(tm0, tm1, tm2) in self.equal_then_atom_node.iter_dirty() {
            self.record_action_234(delta, tm1, tm2);
        }
    }
    fn record_action_235(&self, delta: &mut ModelDelta, tm2: TermNode) {
        let existing_row = self.term_should_be_epic_ok.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_term_should_be_epic_ok
                    .push(TermShouldBeEpicOk(tm2));
                ()
            }
        };
    }
    fn query_and_record_then_atom_epic_ok_defined(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            self.record_action_235(delta, tm2);
        }
    }
    fn record_action_236(&self, delta: &mut ModelDelta, tm2: TermListNode) {
        let existing_row = self.terms_should_be_epic_ok.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsShouldBeEpicOk(_)) => (),
            None => {
                delta
                    .new_terms_should_be_epic_ok
                    .push(TermsShouldBeEpicOk(tm2));
                ()
            }
        };
    }
    fn query_and_record_then_atom_epic_ok_pred(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for PredThenAtomNode(tm0, tm1, tm2) in self.pred_then_atom_node.iter_dirty() {
            self.record_action_236(delta, tm2);
        }
    }
    fn record_action_237(&self, delta: &mut ModelDelta, tm7: Morphism) {
        let existing_row = self.should_be_surjective.iter_all_0(tm7).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ShouldBeSurjective(_)) => (),
            None => {
                delta.new_should_be_surjective.push(ShouldBeSurjective(tm7));
                ()
            }
        };
    }
    fn query_and_record_then_stmt_surjective(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ThenStmtNode(tm0, tm1) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm2, _, tm3) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm4, tm5, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                    #[allow(unused_variables)]
                    for StmtListChain(_, tm6) in self.stmt_list_chain.iter_all_0(tm4) {
                        #[allow(unused_variables)]
                        for ChainHeadTransition(_, tm7) in
                            self.chain_head_transition.iter_all_0(tm6)
                        {
                            self.record_action_237(delta, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm2, tm0, tm3) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, tm5, _) in self.cons_stmt_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for StmtListChain(_, tm6) in self.stmt_list_chain.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for ChainHeadTransition(_, tm7) in self.chain_head_transition.iter_all_0(tm6) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_237(delta, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm5, tm2) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(_, tm6) in self.stmt_list_chain.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for ChainHeadTransition(_, tm7) in self.chain_head_transition.iter_all_0(tm6) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm3) in self.cons_stmt_list_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_237(delta, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ChainHeadTransition(tm6, tm7) in self.chain_head_transition.iter_dirty() {
            #[allow(unused_variables)]
            for StmtListChain(tm4, _) in self.stmt_list_chain.iter_all_1(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm5, tm2) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm3) in self.cons_stmt_list_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_237(delta, tm7);
                        }
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for StmtListChain(tm4, tm6) in self.stmt_list_chain.iter_dirty() {
            #[allow(unused_variables)]
            for ChainHeadTransition(_, tm7) in self.chain_head_transition.iter_all_0(tm6) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm5, tm2) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for ConsStmtListNode(_, tm0, tm3) in self.cons_stmt_list_node.iter_all_0(tm2) {
                        #[allow(unused_variables)]
                        for ThenStmtNode(_, tm1) in self.then_stmt_node.iter_all_0(tm0) {
                            self.record_action_237(delta, tm7);
                        }
                    }
                }
            }
        }
    }
    fn record_action_238(&self, delta: &mut ModelDelta, tm1: TermNode, tm2: TermListNode) {
        let existing_row = self.term_surjective_exempted.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_term_surjective_exempted
                    .push(TermSurjectiveExempted(tm1));
                ()
            }
        };
        let existing_row = self.terms_surjective_exempted.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_terms_surjective_exempted
                    .push(TermsSurjectiveExempted(tm2));
                ()
            }
        };
    }
    fn query_and_record_cons_head_tail_terms_surjective_exempted(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermsSurjectiveExempted(_) in self.terms_surjective_exempted.iter_all_0(tm0) {
                self.record_action_238(delta, tm1, tm2);
            }
        }
        #[allow(unused_variables)]
        for TermsSurjectiveExempted(tm0) in self.terms_surjective_exempted.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(_, tm1, tm2) in self.cons_term_list_node.iter_all_0(tm0) {
                self.record_action_238(delta, tm1, tm2);
            }
        }
    }
    fn record_action_239(&self, delta: &mut ModelDelta, tm0: TermListNode) {
        let existing_row = self.terms_surjective_exempted.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_terms_surjective_exempted
                    .push(TermsSurjectiveExempted(tm0));
                ()
            }
        };
    }
    fn query_and_record_head_tail_cons_terms_surjective_exempted(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ConsTermListNode(tm0, tm1, tm2) in self.cons_term_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermSurjectiveExempted(_) in self.term_surjective_exempted.iter_all_0(tm1) {
                #[allow(unused_variables)]
                for TermsSurjectiveExempted(_) in self.terms_surjective_exempted.iter_all_0(tm2) {
                    self.record_action_239(delta, tm0);
                }
            }
        }
        #[allow(unused_variables)]
        for TermSurjectiveExempted(tm1) in self.term_surjective_exempted.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, _, tm2) in self.cons_term_list_node.iter_all_1(tm1) {
                #[allow(unused_variables)]
                for TermsSurjectiveExempted(_) in self.terms_surjective_exempted.iter_all_0(tm2) {
                    self.record_action_239(delta, tm0);
                }
            }
        }
        #[allow(unused_variables)]
        for TermsSurjectiveExempted(tm2) in self.terms_surjective_exempted.iter_dirty() {
            #[allow(unused_variables)]
            for ConsTermListNode(tm0, tm1, _) in self.cons_term_list_node.iter_all_2(tm2) {
                #[allow(unused_variables)]
                for TermSurjectiveExempted(_) in self.term_surjective_exempted.iter_all_0(tm1) {
                    self.record_action_239(delta, tm0);
                }
            }
        }
    }
    fn record_action_240(&self, delta: &mut ModelDelta, tm2: TermListNode) {
        let existing_row = self.terms_surjective_exempted.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermsSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_terms_surjective_exempted
                    .push(TermsSurjectiveExempted(tm2));
                ()
            }
        };
    }
    fn query_and_record_subterms_surjective_exempted(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for AppTermNode(tm0, tm1, tm2) in self.app_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for TermSurjectiveExempted(_) in self.term_surjective_exempted.iter_all_0(tm0) {
                self.record_action_240(delta, tm2);
            }
        }
        #[allow(unused_variables)]
        for TermSurjectiveExempted(tm0) in self.term_surjective_exempted.iter_dirty() {
            #[allow(unused_variables)]
            for AppTermNode(_, tm1, tm2) in self.app_term_node.iter_all_0(tm0) {
                self.record_action_240(delta, tm2);
            }
        }
    }
    fn record_action_241(&self, delta: &mut ModelDelta, tm2: TermNode) {
        let existing_row = self.term_surjective_exempted.iter_all_0(tm2).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(TermSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_term_surjective_exempted
                    .push(TermSurjectiveExempted(tm2));
                ()
            }
        };
    }
    fn query_and_record_defined_atom_surjective_exempted(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for DefinedThenAtomNode(tm0, tm1, tm2) in self.defined_then_atom_node.iter_dirty() {
            self.record_action_241(delta, tm2);
        }
    }
    fn record_action_242(&self, delta: &mut ModelDelta, tm1: El) {
        let existing_row = self.el_surjective_exempted.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElSurjectiveExempted(_)) => (),
            None => {
                delta
                    .new_el_surjective_exempted
                    .push(ElSurjectiveExempted(tm1));
                ()
            }
        };
    }
    fn query_and_record_semantic_el_exempted(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for TermSurjectiveExempted(tm0) in self.term_surjective_exempted.iter_dirty() {
            #[allow(unused_variables)]
            for SemanticEl(_, tm1) in self.semantic_el.iter_all_0(tm0) {
                self.record_action_242(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for SemanticEl(tm0, tm1) in self.semantic_el.iter_dirty() {
            #[allow(unused_variables)]
            for TermSurjectiveExempted(_) in self.term_surjective_exempted.iter_all_0(tm0) {
                self.record_action_242(delta, tm1);
            }
        }
    }
    fn record_action_243(&self, delta: &mut ModelDelta, tm1: El) {
        let existing_row = self.el_should_be_surjective_ok.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElShouldBeSurjectiveOk(_)) => (),
            None => {
                delta
                    .new_el_should_be_surjective_ok
                    .push(ElShouldBeSurjectiveOk(tm1));
                ()
            }
        };
    }
    fn query_and_record_surjective_codomain_should_be_ok(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ShouldBeSurjective(tm0) in self.should_be_surjective.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(_, tm2) in self.cod.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                    self.record_action_243(delta, tm1);
                }
            }
        }
        #[allow(unused_variables)]
        for ElStructure(tm1, tm2) in self.el_structure.iter_dirty() {
            #[allow(unused_variables)]
            for Cod(tm0, _) in self.cod.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ShouldBeSurjective(_) in self.should_be_surjective.iter_all_0(tm0) {
                    self.record_action_243(delta, tm1);
                }
            }
        }
        #[allow(unused_variables)]
        for Cod(tm0, tm2) in self.cod.iter_dirty() {
            #[allow(unused_variables)]
            for ElStructure(tm1, _) in self.el_structure.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ShouldBeSurjective(_) in self.should_be_surjective.iter_all_0(tm0) {
                    self.record_action_243(delta, tm1);
                }
            }
        }
    }
    fn record_action_244(&self, delta: &mut ModelDelta, tm0: El) {
        let existing_row = self.el_is_surjective_ok.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElIsSurjectiveOk(_)) => (),
            None => {
                delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm0));
                ()
            }
        };
    }
    fn query_and_record_surjective_exempted_el_is_ok(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElSurjectiveExempted(tm0) in self.el_surjective_exempted.iter_dirty() {
            self.record_action_244(delta, tm0);
        }
    }
    fn record_action_245(&self, delta: &mut ModelDelta, tm1: El) {
        let existing_row = self.el_is_surjective_ok.iter_all_0(tm1).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(ElIsSurjectiveOk(_)) => (),
            None => {
                delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm1));
                ()
            }
        };
    }
    fn query_and_record_surjective_img_el_is_ok(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for ElInImg(tm0, tm1) in self.el_in_img.iter_dirty() {
            #[allow(unused_variables)]
            for ShouldBeSurjective(_) in self.should_be_surjective.iter_all_0(tm0) {
                self.record_action_245(delta, tm1);
            }
        }
        #[allow(unused_variables)]
        for ShouldBeSurjective(tm0) in self.should_be_surjective.iter_dirty() {
            #[allow(unused_variables)]
            for ElInImg(_, tm1) in self.el_in_img.iter_all_0(tm0) {
                self.record_action_245(delta, tm1);
            }
        }
    }
    fn record_action_246(
        &self,
        delta: &mut ModelDelta,
        tm0: TermNode,
        tm1: Ident,
        tm3: RuleDeclNode,
    ) {
        let existing_row = self.var_term_in_rule.iter_all_0_1_2(tm0, tm1, tm3).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(VarTermInRule(_, _, _)) => (),
            None => {
                delta
                    .new_var_term_in_rule
                    .push(VarTermInRule(tm0, tm1, tm3));
                ()
            }
        };
    }
    fn query_and_record_var_term_in_rule_child(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for VarTermNode(tm0, tm1) in self.var_term_node.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(_, tm2) in self.rule_child_term.iter_all_0(tm0) {
                #[allow(unused_variables)]
                for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                    self.record_action_246(delta, tm0, tm1, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChild(tm2, tm3) in self.rule_child.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChildTerm(tm0, _) in self.rule_child_term.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    self.record_action_246(delta, tm0, tm1, tm3);
                }
            }
        }
        #[allow(unused_variables)]
        for RuleChildTerm(tm0, tm2) in self.rule_child_term.iter_dirty() {
            #[allow(unused_variables)]
            for RuleChild(_, tm3) in self.rule_child.iter_all_0(tm2) {
                #[allow(unused_variables)]
                for VarTermNode(_, tm1) in self.var_term_node.iter_all_0(tm0) {
                    self.record_action_246(delta, tm0, tm1, tm3);
                }
            }
        }
    }
    fn record_action_247(&self, delta: &mut ModelDelta, tm0: StmtNode) {
        let existing_row = self.if_after_then.iter_all_0(tm0).next();
        #[allow(unused_variables)]
        let () = match existing_row {
            Some(IfAfterThen(_)) => (),
            None => {
                delta.new_if_after_then.push(IfAfterThen(tm0));
                ()
            }
        };
    }
    fn query_and_record_after_then_should_be_if(&self, delta: &mut ModelDelta) {
        #[allow(unused_variables)]
        for IfStmtNode(tm0, tm1) in self.if_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm4, _, tm5) in self.cons_stmt_list_node.iter_all_1(tm0) {
                #[allow(unused_variables)]
                for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                    #[allow(unused_variables)]
                    for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                        self.record_action_247(delta, tm0);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ThenStmtNode(tm2, tm3) in self.then_stmt_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, _, tm4) in self.cons_stmt_list_node.iter_all_1(tm2) {
                #[allow(unused_variables)]
                for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                        self.record_action_247(delta, tm0);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm4, tm0, tm5) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(tm6, tm2, _) in self.cons_stmt_list_node.iter_all_2(tm4) {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                        self.record_action_247(delta, tm0);
                    }
                }
            }
        }
        #[allow(unused_variables)]
        for ConsStmtListNode(tm6, tm2, tm4) in self.cons_stmt_list_node.iter_dirty() {
            #[allow(unused_variables)]
            for ConsStmtListNode(_, tm0, tm5) in self.cons_stmt_list_node.iter_all_0(tm4) {
                #[allow(unused_variables)]
                for ThenStmtNode(_, tm3) in self.then_stmt_node.iter_all_0(tm2) {
                    #[allow(unused_variables)]
                    for IfStmtNode(_, tm1) in self.if_stmt_node.iter_all_0(tm0) {
                        self.record_action_247(delta, tm0);
                    }
                }
            }
        }
    }
    fn drop_dirt(&mut self) {
        self.empty_join_is_dirty = false;

        self.absurd.drop_dirt();
        self.type_decl.drop_dirt();
        self.arg_decl_node_name.drop_dirt();
        self.arg_decl_node_type.drop_dirt();
        self.nil_arg_decl_list_node.drop_dirt();
        self.cons_arg_decl_list_node.drop_dirt();
        self.pred_decl.drop_dirt();
        self.func_decl.drop_dirt();
        self.nil_term_list_node.drop_dirt();
        self.cons_term_list_node.drop_dirt();
        self.none_term_node.drop_dirt();
        self.some_term_node.drop_dirt();
        self.var_term_node.drop_dirt();
        self.wildcard_term_node.drop_dirt();
        self.app_term_node.drop_dirt();
        self.equal_if_atom_node.drop_dirt();
        self.defined_if_atom_node.drop_dirt();
        self.pred_if_atom_node.drop_dirt();
        self.var_if_atom_node.drop_dirt();
        self.equal_then_atom_node.drop_dirt();
        self.defined_then_atom_node.drop_dirt();
        self.pred_then_atom_node.drop_dirt();
        self.if_stmt_node.drop_dirt();
        self.then_stmt_node.drop_dirt();
        self.nil_stmt_list_node.drop_dirt();
        self.cons_stmt_list_node.drop_dirt();
        self.rule_decl.drop_dirt();
        self.decl_node_type.drop_dirt();
        self.decl_node_pred.drop_dirt();
        self.decl_node_func.drop_dirt();
        self.decl_node_rule.drop_dirt();
        self.nil_decl_list_node.drop_dirt();
        self.cons_decl_list_node.drop_dirt();
        self.decls_module_node.drop_dirt();
        self.rule_child.drop_dirt();
        self.pred_app.drop_dirt();
        self.el_type.drop_dirt();
        self.el_types.drop_dirt();
        self.constrained_el.drop_dirt();
        self.constrained_els.drop_dirt();
        self.in_ker.drop_dirt();
        self.el_in_img.drop_dirt();
        self.pred_tuple_in_img.drop_dirt();
        self.func_app_in_img.drop_dirt();
        self.defined_symbol.drop_dirt();
        self.should_be_symbol.drop_dirt();
        self.pred_arg_num_should_match.drop_dirt();
        self.func_arg_num_should_match.drop_dirt();
        self.var_before_term.drop_dirt();
        self.var_before_terms.drop_dirt();
        self.var_before_opt_term.drop_dirt();
        self.var_before_if_atom.drop_dirt();
        self.var_before_then_atom.drop_dirt();
        self.var_before_stmt.drop_dirt();
        self.var_before_stmts.drop_dirt();
        self.var_in_term.drop_dirt();
        self.var_in_terms.drop_dirt();
        self.var_in_opt_term.drop_dirt();
        self.var_in_if_atom.drop_dirt();
        self.var_in_then_atom.drop_dirt();
        self.var_in_stmt.drop_dirt();
        self.term_should_be_epic_ok.drop_dirt();
        self.terms_should_be_epic_ok.drop_dirt();
        self.should_be_surjective.drop_dirt();
        self.term_surjective_exempted.drop_dirt();
        self.terms_surjective_exempted.drop_dirt();
        self.el_surjective_exempted.drop_dirt();
        self.el_should_be_surjective_ok.drop_dirt();
        self.el_is_surjective_ok.drop_dirt();
        self.var_term_in_rule.drop_dirt();
        self.if_after_then.drop_dirt();
        self.real_virt_ident.drop_dirt();
        self.rule_name.drop_dirt();
        self.type_decl_node_loc.drop_dirt();
        self.arg_decl_node_loc.drop_dirt();
        self.arg_decl_list_node_loc.drop_dirt();
        self.pred_decl_node_loc.drop_dirt();
        self.func_decl_node_loc.drop_dirt();
        self.term_node_loc.drop_dirt();
        self.term_list_node_loc.drop_dirt();
        self.opt_term_node_loc.drop_dirt();
        self.if_atom_node_loc.drop_dirt();
        self.then_atom_node_loc.drop_dirt();
        self.stmt_node_loc.drop_dirt();
        self.stmt_list_node_loc.drop_dirt();
        self.rule_decl_node_loc.drop_dirt();
        self.decl_node_loc.drop_dirt();
        self.decl_list_node_loc.drop_dirt();
        self.module_node_loc.drop_dirt();
        self.rule_child_term.drop_dirt();
        self.rule_child_term_list.drop_dirt();
        self.rule_child_opt_term.drop_dirt();
        self.rule_child_if_atom.drop_dirt();
        self.rule_child_then_atom.drop_dirt();
        self.rule_child_stmt.drop_dirt();
        self.rule_child_stmt_list.drop_dirt();
        self.nil_type_list.drop_dirt();
        self.cons_type_list.drop_dirt();
        self.semantic_type.drop_dirt();
        self.semantic_arg_types.drop_dirt();
        self.semantic_pred.drop_dirt();
        self.arity.drop_dirt();
        self.semantic_func.drop_dirt();
        self.domain.drop_dirt();
        self.codomain.drop_dirt();
        self.nil_el_list.drop_dirt();
        self.cons_el_list.drop_dirt();
        self.func_app.drop_dirt();
        self.var.drop_dirt();
        self.el_structure.drop_dirt();
        self.els_structure.drop_dirt();
        self.dom.drop_dirt();
        self.cod.drop_dirt();
        self.map_el.drop_dirt();
        self.map_els.drop_dirt();
        self.initial_structure.drop_dirt();
        self.initiality_morphism.drop_dirt();
        self.nil_chain.drop_dirt();
        self.chain_tail.drop_dirt();
        self.chain_head_structure.drop_dirt();
        self.chain_head_transition.drop_dirt();
        self.type_symbol.drop_dirt();
        self.pred_symbol.drop_dirt();
        self.func_symbol.drop_dirt();
        self.rule_symbol.drop_dirt();
        self.zero.drop_dirt();
        self.succ.drop_dirt();
        self.type_list_len.drop_dirt();
        self.term_list_len.drop_dirt();
        self.rule_chain.drop_dirt();
        self.stmt_list_chain.drop_dirt();
        self.stmt_structure.drop_dirt();
        self.if_atom_structure.drop_dirt();
        self.then_atom_structure.drop_dirt();
        self.term_structure.drop_dirt();
        self.terms_structure.drop_dirt();
        self.opt_term_structure.drop_dirt();
        self.semantic_el.drop_dirt();
        self.semantic_els.drop_dirt();
        self.wildcard_virt_ident.drop_dirt();
        self.grouped_rule_chain.drop_dirt();
        self.grouped_stmt_list_chain.drop_dirt();

        self.ident_dirty.clear();
        self.virt_ident_dirty.clear();
        self.type_decl_node_dirty.clear();
        self.arg_decl_node_dirty.clear();
        self.arg_decl_list_node_dirty.clear();
        self.pred_decl_node_dirty.clear();
        self.func_decl_node_dirty.clear();
        self.term_node_dirty.clear();
        self.term_list_node_dirty.clear();
        self.opt_term_node_dirty.clear();
        self.if_atom_node_dirty.clear();
        self.then_atom_node_dirty.clear();
        self.stmt_node_dirty.clear();
        self.stmt_list_node_dirty.clear();
        self.rule_decl_node_dirty.clear();
        self.decl_node_dirty.clear();
        self.decl_list_node_dirty.clear();
        self.module_node_dirty.clear();
        self.loc_dirty.clear();
        self.rule_child_node_dirty.clear();
        self.type_dirty.clear();
        self.type_list_dirty.clear();
        self.pred_dirty.clear();
        self.func_dirty.clear();
        self.structure_dirty.clear();
        self.el_dirty.clear();
        self.el_list_dirty.clear();
        self.morphism_dirty.clear();
        self.chain_dirty.clear();
        self.symbol_kind_dirty.clear();
        self.nat_dirty.clear();
    }
    fn retire_dirt(&mut self) {
        self.empty_join_is_dirty = false;

        self.absurd.retire_dirt();
        self.type_decl.retire_dirt();
        self.arg_decl_node_name.retire_dirt();
        self.arg_decl_node_type.retire_dirt();
        self.nil_arg_decl_list_node.retire_dirt();
        self.cons_arg_decl_list_node.retire_dirt();
        self.pred_decl.retire_dirt();
        self.func_decl.retire_dirt();
        self.nil_term_list_node.retire_dirt();
        self.cons_term_list_node.retire_dirt();
        self.none_term_node.retire_dirt();
        self.some_term_node.retire_dirt();
        self.var_term_node.retire_dirt();
        self.wildcard_term_node.retire_dirt();
        self.app_term_node.retire_dirt();
        self.equal_if_atom_node.retire_dirt();
        self.defined_if_atom_node.retire_dirt();
        self.pred_if_atom_node.retire_dirt();
        self.var_if_atom_node.retire_dirt();
        self.equal_then_atom_node.retire_dirt();
        self.defined_then_atom_node.retire_dirt();
        self.pred_then_atom_node.retire_dirt();
        self.if_stmt_node.retire_dirt();
        self.then_stmt_node.retire_dirt();
        self.nil_stmt_list_node.retire_dirt();
        self.cons_stmt_list_node.retire_dirt();
        self.rule_decl.retire_dirt();
        self.decl_node_type.retire_dirt();
        self.decl_node_pred.retire_dirt();
        self.decl_node_func.retire_dirt();
        self.decl_node_rule.retire_dirt();
        self.nil_decl_list_node.retire_dirt();
        self.cons_decl_list_node.retire_dirt();
        self.decls_module_node.retire_dirt();
        self.rule_child.retire_dirt();
        self.pred_app.retire_dirt();
        self.el_type.retire_dirt();
        self.el_types.retire_dirt();
        self.constrained_el.retire_dirt();
        self.constrained_els.retire_dirt();
        self.in_ker.retire_dirt();
        self.el_in_img.retire_dirt();
        self.pred_tuple_in_img.retire_dirt();
        self.func_app_in_img.retire_dirt();
        self.defined_symbol.retire_dirt();
        self.should_be_symbol.retire_dirt();
        self.pred_arg_num_should_match.retire_dirt();
        self.func_arg_num_should_match.retire_dirt();
        self.var_before_term.retire_dirt();
        self.var_before_terms.retire_dirt();
        self.var_before_opt_term.retire_dirt();
        self.var_before_if_atom.retire_dirt();
        self.var_before_then_atom.retire_dirt();
        self.var_before_stmt.retire_dirt();
        self.var_before_stmts.retire_dirt();
        self.var_in_term.retire_dirt();
        self.var_in_terms.retire_dirt();
        self.var_in_opt_term.retire_dirt();
        self.var_in_if_atom.retire_dirt();
        self.var_in_then_atom.retire_dirt();
        self.var_in_stmt.retire_dirt();
        self.term_should_be_epic_ok.retire_dirt();
        self.terms_should_be_epic_ok.retire_dirt();
        self.should_be_surjective.retire_dirt();
        self.term_surjective_exempted.retire_dirt();
        self.terms_surjective_exempted.retire_dirt();
        self.el_surjective_exempted.retire_dirt();
        self.el_should_be_surjective_ok.retire_dirt();
        self.el_is_surjective_ok.retire_dirt();
        self.var_term_in_rule.retire_dirt();
        self.if_after_then.retire_dirt();
        self.real_virt_ident.retire_dirt();
        self.rule_name.retire_dirt();
        self.type_decl_node_loc.retire_dirt();
        self.arg_decl_node_loc.retire_dirt();
        self.arg_decl_list_node_loc.retire_dirt();
        self.pred_decl_node_loc.retire_dirt();
        self.func_decl_node_loc.retire_dirt();
        self.term_node_loc.retire_dirt();
        self.term_list_node_loc.retire_dirt();
        self.opt_term_node_loc.retire_dirt();
        self.if_atom_node_loc.retire_dirt();
        self.then_atom_node_loc.retire_dirt();
        self.stmt_node_loc.retire_dirt();
        self.stmt_list_node_loc.retire_dirt();
        self.rule_decl_node_loc.retire_dirt();
        self.decl_node_loc.retire_dirt();
        self.decl_list_node_loc.retire_dirt();
        self.module_node_loc.retire_dirt();
        self.rule_child_term.retire_dirt();
        self.rule_child_term_list.retire_dirt();
        self.rule_child_opt_term.retire_dirt();
        self.rule_child_if_atom.retire_dirt();
        self.rule_child_then_atom.retire_dirt();
        self.rule_child_stmt.retire_dirt();
        self.rule_child_stmt_list.retire_dirt();
        self.nil_type_list.retire_dirt();
        self.cons_type_list.retire_dirt();
        self.semantic_type.retire_dirt();
        self.semantic_arg_types.retire_dirt();
        self.semantic_pred.retire_dirt();
        self.arity.retire_dirt();
        self.semantic_func.retire_dirt();
        self.domain.retire_dirt();
        self.codomain.retire_dirt();
        self.nil_el_list.retire_dirt();
        self.cons_el_list.retire_dirt();
        self.func_app.retire_dirt();
        self.var.retire_dirt();
        self.el_structure.retire_dirt();
        self.els_structure.retire_dirt();
        self.dom.retire_dirt();
        self.cod.retire_dirt();
        self.map_el.retire_dirt();
        self.map_els.retire_dirt();
        self.initial_structure.retire_dirt();
        self.initiality_morphism.retire_dirt();
        self.nil_chain.retire_dirt();
        self.chain_tail.retire_dirt();
        self.chain_head_structure.retire_dirt();
        self.chain_head_transition.retire_dirt();
        self.type_symbol.retire_dirt();
        self.pred_symbol.retire_dirt();
        self.func_symbol.retire_dirt();
        self.rule_symbol.retire_dirt();
        self.zero.retire_dirt();
        self.succ.retire_dirt();
        self.type_list_len.retire_dirt();
        self.term_list_len.retire_dirt();
        self.rule_chain.retire_dirt();
        self.stmt_list_chain.retire_dirt();
        self.stmt_structure.retire_dirt();
        self.if_atom_structure.retire_dirt();
        self.then_atom_structure.retire_dirt();
        self.term_structure.retire_dirt();
        self.terms_structure.retire_dirt();
        self.opt_term_structure.retire_dirt();
        self.semantic_el.retire_dirt();
        self.semantic_els.retire_dirt();
        self.wildcard_virt_ident.retire_dirt();
        self.grouped_rule_chain.retire_dirt();
        self.grouped_stmt_list_chain.retire_dirt();

        let mut ident_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut ident_dirty_tmp, &mut self.ident_dirty);
        self.ident_dirty_prev.push(ident_dirty_tmp);

        let mut virt_ident_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut virt_ident_dirty_tmp, &mut self.virt_ident_dirty);
        self.virt_ident_dirty_prev.push(virt_ident_dirty_tmp);

        let mut type_decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut type_decl_node_dirty_tmp,
            &mut self.type_decl_node_dirty,
        );
        self.type_decl_node_dirty_prev
            .push(type_decl_node_dirty_tmp);

        let mut arg_decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut arg_decl_node_dirty_tmp, &mut self.arg_decl_node_dirty);
        self.arg_decl_node_dirty_prev.push(arg_decl_node_dirty_tmp);

        let mut arg_decl_list_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut arg_decl_list_node_dirty_tmp,
            &mut self.arg_decl_list_node_dirty,
        );
        self.arg_decl_list_node_dirty_prev
            .push(arg_decl_list_node_dirty_tmp);

        let mut pred_decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut pred_decl_node_dirty_tmp,
            &mut self.pred_decl_node_dirty,
        );
        self.pred_decl_node_dirty_prev
            .push(pred_decl_node_dirty_tmp);

        let mut func_decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut func_decl_node_dirty_tmp,
            &mut self.func_decl_node_dirty,
        );
        self.func_decl_node_dirty_prev
            .push(func_decl_node_dirty_tmp);

        let mut term_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut term_node_dirty_tmp, &mut self.term_node_dirty);
        self.term_node_dirty_prev.push(term_node_dirty_tmp);

        let mut term_list_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut term_list_node_dirty_tmp,
            &mut self.term_list_node_dirty,
        );
        self.term_list_node_dirty_prev
            .push(term_list_node_dirty_tmp);

        let mut opt_term_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut opt_term_node_dirty_tmp, &mut self.opt_term_node_dirty);
        self.opt_term_node_dirty_prev.push(opt_term_node_dirty_tmp);

        let mut if_atom_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut if_atom_node_dirty_tmp, &mut self.if_atom_node_dirty);
        self.if_atom_node_dirty_prev.push(if_atom_node_dirty_tmp);

        let mut then_atom_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut then_atom_node_dirty_tmp,
            &mut self.then_atom_node_dirty,
        );
        self.then_atom_node_dirty_prev
            .push(then_atom_node_dirty_tmp);

        let mut stmt_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut stmt_node_dirty_tmp, &mut self.stmt_node_dirty);
        self.stmt_node_dirty_prev.push(stmt_node_dirty_tmp);

        let mut stmt_list_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut stmt_list_node_dirty_tmp,
            &mut self.stmt_list_node_dirty,
        );
        self.stmt_list_node_dirty_prev
            .push(stmt_list_node_dirty_tmp);

        let mut rule_decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut rule_decl_node_dirty_tmp,
            &mut self.rule_decl_node_dirty,
        );
        self.rule_decl_node_dirty_prev
            .push(rule_decl_node_dirty_tmp);

        let mut decl_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut decl_node_dirty_tmp, &mut self.decl_node_dirty);
        self.decl_node_dirty_prev.push(decl_node_dirty_tmp);

        let mut decl_list_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut decl_list_node_dirty_tmp,
            &mut self.decl_list_node_dirty,
        );
        self.decl_list_node_dirty_prev
            .push(decl_list_node_dirty_tmp);

        let mut module_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut module_node_dirty_tmp, &mut self.module_node_dirty);
        self.module_node_dirty_prev.push(module_node_dirty_tmp);

        let mut loc_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut loc_dirty_tmp, &mut self.loc_dirty);
        self.loc_dirty_prev.push(loc_dirty_tmp);

        let mut rule_child_node_dirty_tmp = BTreeSet::new();
        std::mem::swap(
            &mut rule_child_node_dirty_tmp,
            &mut self.rule_child_node_dirty,
        );
        self.rule_child_node_dirty_prev
            .push(rule_child_node_dirty_tmp);

        let mut type_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut type_dirty_tmp, &mut self.type_dirty);
        self.type_dirty_prev.push(type_dirty_tmp);

        let mut type_list_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut type_list_dirty_tmp, &mut self.type_list_dirty);
        self.type_list_dirty_prev.push(type_list_dirty_tmp);

        let mut pred_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut pred_dirty_tmp, &mut self.pred_dirty);
        self.pred_dirty_prev.push(pred_dirty_tmp);

        let mut func_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut func_dirty_tmp, &mut self.func_dirty);
        self.func_dirty_prev.push(func_dirty_tmp);

        let mut structure_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut structure_dirty_tmp, &mut self.structure_dirty);
        self.structure_dirty_prev.push(structure_dirty_tmp);

        let mut el_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut el_dirty_tmp, &mut self.el_dirty);
        self.el_dirty_prev.push(el_dirty_tmp);

        let mut el_list_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut el_list_dirty_tmp, &mut self.el_list_dirty);
        self.el_list_dirty_prev.push(el_list_dirty_tmp);

        let mut morphism_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut morphism_dirty_tmp, &mut self.morphism_dirty);
        self.morphism_dirty_prev.push(morphism_dirty_tmp);

        let mut chain_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut chain_dirty_tmp, &mut self.chain_dirty);
        self.chain_dirty_prev.push(chain_dirty_tmp);

        let mut symbol_kind_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut symbol_kind_dirty_tmp, &mut self.symbol_kind_dirty);
        self.symbol_kind_dirty_prev.push(symbol_kind_dirty_tmp);

        let mut nat_dirty_tmp = BTreeSet::new();
        std::mem::swap(&mut nat_dirty_tmp, &mut self.nat_dirty);
        self.nat_dirty_prev.push(nat_dirty_tmp);
    }
    fn recall_previous_dirt(&mut self) {
        debug_assert!(!self.is_dirty());

        self.absurd.recall_previous_dirt();
        self.type_decl.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.type_decl_node_equalities,
        );
        self.arg_decl_node_name.recall_previous_dirt(
            &mut self.arg_decl_node_equalities,
            &mut self.ident_equalities,
        );
        self.arg_decl_node_type.recall_previous_dirt(
            &mut self.arg_decl_node_equalities,
            &mut self.ident_equalities,
        );
        self.nil_arg_decl_list_node
            .recall_previous_dirt(&mut self.arg_decl_list_node_equalities);
        self.cons_arg_decl_list_node.recall_previous_dirt(
            &mut self.arg_decl_list_node_equalities,
            &mut self.arg_decl_node_equalities,
        );
        self.pred_decl.recall_previous_dirt(
            &mut self.arg_decl_list_node_equalities,
            &mut self.ident_equalities,
            &mut self.pred_decl_node_equalities,
        );
        self.func_decl.recall_previous_dirt(
            &mut self.arg_decl_list_node_equalities,
            &mut self.func_decl_node_equalities,
            &mut self.ident_equalities,
        );
        self.nil_term_list_node
            .recall_previous_dirt(&mut self.term_list_node_equalities);
        self.cons_term_list_node.recall_previous_dirt(
            &mut self.term_list_node_equalities,
            &mut self.term_node_equalities,
        );
        self.none_term_node
            .recall_previous_dirt(&mut self.opt_term_node_equalities);
        self.some_term_node.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.term_node_equalities,
        );
        self.var_term_node
            .recall_previous_dirt(&mut self.ident_equalities, &mut self.term_node_equalities);
        self.wildcard_term_node
            .recall_previous_dirt(&mut self.term_node_equalities);
        self.app_term_node.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.term_list_node_equalities,
            &mut self.term_node_equalities,
        );
        self.equal_if_atom_node.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.term_node_equalities,
        );
        self.defined_if_atom_node.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.term_node_equalities,
        );
        self.pred_if_atom_node.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.if_atom_node_equalities,
            &mut self.term_list_node_equalities,
        );
        self.var_if_atom_node.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.if_atom_node_equalities,
            &mut self.term_node_equalities,
        );
        self.equal_then_atom_node.recall_previous_dirt(
            &mut self.term_node_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.defined_then_atom_node.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.term_node_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.pred_then_atom_node.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.term_list_node_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.if_stmt_node.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.stmt_node_equalities,
        );
        self.then_stmt_node.recall_previous_dirt(
            &mut self.stmt_node_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.nil_stmt_list_node
            .recall_previous_dirt(&mut self.stmt_list_node_equalities);
        self.cons_stmt_list_node.recall_previous_dirt(
            &mut self.stmt_list_node_equalities,
            &mut self.stmt_node_equalities,
        );
        self.rule_decl.recall_previous_dirt(
            &mut self.rule_decl_node_equalities,
            &mut self.stmt_list_node_equalities,
        );
        self.decl_node_type.recall_previous_dirt(
            &mut self.decl_node_equalities,
            &mut self.type_decl_node_equalities,
        );
        self.decl_node_pred.recall_previous_dirt(
            &mut self.decl_node_equalities,
            &mut self.pred_decl_node_equalities,
        );
        self.decl_node_func.recall_previous_dirt(
            &mut self.decl_node_equalities,
            &mut self.func_decl_node_equalities,
        );
        self.decl_node_rule.recall_previous_dirt(
            &mut self.decl_node_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.nil_decl_list_node
            .recall_previous_dirt(&mut self.decl_list_node_equalities);
        self.cons_decl_list_node.recall_previous_dirt(
            &mut self.decl_list_node_equalities,
            &mut self.decl_node_equalities,
        );
        self.decls_module_node.recall_previous_dirt(
            &mut self.decl_list_node_equalities,
            &mut self.module_node_equalities,
        );
        self.rule_child.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.pred_app
            .recall_previous_dirt(&mut self.el_list_equalities, &mut self.pred_equalities);
        self.el_type
            .recall_previous_dirt(&mut self.el_equalities, &mut self.type_equalities);
        self.el_types
            .recall_previous_dirt(&mut self.el_list_equalities, &mut self.type_list_equalities);
        self.constrained_el
            .recall_previous_dirt(&mut self.el_equalities);
        self.constrained_els
            .recall_previous_dirt(&mut self.el_list_equalities);
        self.in_ker
            .recall_previous_dirt(&mut self.el_equalities, &mut self.morphism_equalities);
        self.el_in_img
            .recall_previous_dirt(&mut self.el_equalities, &mut self.morphism_equalities);
        self.pred_tuple_in_img.recall_previous_dirt(
            &mut self.el_list_equalities,
            &mut self.morphism_equalities,
            &mut self.pred_equalities,
        );
        self.func_app_in_img.recall_previous_dirt(
            &mut self.el_list_equalities,
            &mut self.func_equalities,
            &mut self.morphism_equalities,
        );
        self.defined_symbol.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.loc_equalities,
            &mut self.symbol_kind_equalities,
        );
        self.should_be_symbol.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.loc_equalities,
            &mut self.symbol_kind_equalities,
        );
        self.pred_arg_num_should_match
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.nat_equalities);
        self.func_arg_num_should_match
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.nat_equalities);
        self.var_before_term.recall_previous_dirt(
            &mut self.term_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_terms.recall_previous_dirt(
            &mut self.term_list_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_opt_term.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_if_atom.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_then_atom.recall_previous_dirt(
            &mut self.then_atom_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_stmt.recall_previous_dirt(
            &mut self.stmt_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_before_stmts.recall_previous_dirt(
            &mut self.stmt_list_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_term.recall_previous_dirt(
            &mut self.term_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_terms.recall_previous_dirt(
            &mut self.term_list_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_opt_term.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_if_atom.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_then_atom.recall_previous_dirt(
            &mut self.then_atom_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.var_in_stmt.recall_previous_dirt(
            &mut self.stmt_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.term_should_be_epic_ok
            .recall_previous_dirt(&mut self.term_node_equalities);
        self.terms_should_be_epic_ok
            .recall_previous_dirt(&mut self.term_list_node_equalities);
        self.should_be_surjective
            .recall_previous_dirt(&mut self.morphism_equalities);
        self.term_surjective_exempted
            .recall_previous_dirt(&mut self.term_node_equalities);
        self.terms_surjective_exempted
            .recall_previous_dirt(&mut self.term_list_node_equalities);
        self.el_surjective_exempted
            .recall_previous_dirt(&mut self.el_equalities);
        self.el_should_be_surjective_ok
            .recall_previous_dirt(&mut self.el_equalities);
        self.el_is_surjective_ok
            .recall_previous_dirt(&mut self.el_equalities);
        self.var_term_in_rule.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.rule_decl_node_equalities,
            &mut self.term_node_equalities,
        );
        self.if_after_then
            .recall_previous_dirt(&mut self.stmt_node_equalities);
        self.real_virt_ident
            .recall_previous_dirt(&mut self.ident_equalities, &mut self.virt_ident_equalities);
        self.rule_name.recall_previous_dirt(
            &mut self.ident_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.type_decl_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.type_decl_node_equalities,
        );
        self.arg_decl_node_loc
            .recall_previous_dirt(&mut self.arg_decl_node_equalities, &mut self.loc_equalities);
        self.arg_decl_list_node_loc.recall_previous_dirt(
            &mut self.arg_decl_list_node_equalities,
            &mut self.loc_equalities,
        );
        self.pred_decl_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.pred_decl_node_equalities,
        );
        self.func_decl_node_loc.recall_previous_dirt(
            &mut self.func_decl_node_equalities,
            &mut self.loc_equalities,
        );
        self.term_node_loc
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.term_node_equalities);
        self.term_list_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.term_list_node_equalities,
        );
        self.opt_term_node_loc
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.opt_term_node_equalities);
        self.if_atom_node_loc
            .recall_previous_dirt(&mut self.if_atom_node_equalities, &mut self.loc_equalities);
        self.then_atom_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.stmt_node_loc
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.stmt_node_equalities);
        self.stmt_list_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.stmt_list_node_equalities,
        );
        self.rule_decl_node_loc.recall_previous_dirt(
            &mut self.loc_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.decl_node_loc
            .recall_previous_dirt(&mut self.decl_node_equalities, &mut self.loc_equalities);
        self.decl_list_node_loc.recall_previous_dirt(
            &mut self.decl_list_node_equalities,
            &mut self.loc_equalities,
        );
        self.module_node_loc
            .recall_previous_dirt(&mut self.loc_equalities, &mut self.module_node_equalities);
        self.rule_child_term.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.term_node_equalities,
        );
        self.rule_child_term_list.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.term_list_node_equalities,
        );
        self.rule_child_opt_term.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.rule_child_node_equalities,
        );
        self.rule_child_if_atom.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.rule_child_node_equalities,
        );
        self.rule_child_then_atom.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.rule_child_stmt.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.stmt_node_equalities,
        );
        self.rule_child_stmt_list.recall_previous_dirt(
            &mut self.rule_child_node_equalities,
            &mut self.stmt_list_node_equalities,
        );
        self.nil_type_list
            .recall_previous_dirt(&mut self.type_list_equalities);
        self.cons_type_list
            .recall_previous_dirt(&mut self.type_equalities, &mut self.type_list_equalities);
        self.semantic_type
            .recall_previous_dirt(&mut self.ident_equalities, &mut self.type_equalities);
        self.semantic_arg_types.recall_previous_dirt(
            &mut self.arg_decl_list_node_equalities,
            &mut self.type_list_equalities,
        );
        self.semantic_pred
            .recall_previous_dirt(&mut self.ident_equalities, &mut self.pred_equalities);
        self.arity
            .recall_previous_dirt(&mut self.pred_equalities, &mut self.type_list_equalities);
        self.semantic_func
            .recall_previous_dirt(&mut self.func_equalities, &mut self.ident_equalities);
        self.domain
            .recall_previous_dirt(&mut self.func_equalities, &mut self.type_list_equalities);
        self.codomain
            .recall_previous_dirt(&mut self.func_equalities, &mut self.type_equalities);
        self.nil_el_list
            .recall_previous_dirt(&mut self.el_list_equalities, &mut self.structure_equalities);
        self.cons_el_list
            .recall_previous_dirt(&mut self.el_equalities, &mut self.el_list_equalities);
        self.func_app.recall_previous_dirt(
            &mut self.el_equalities,
            &mut self.el_list_equalities,
            &mut self.func_equalities,
        );
        self.var.recall_previous_dirt(
            &mut self.el_equalities,
            &mut self.structure_equalities,
            &mut self.virt_ident_equalities,
        );
        self.el_structure
            .recall_previous_dirt(&mut self.el_equalities, &mut self.structure_equalities);
        self.els_structure
            .recall_previous_dirt(&mut self.el_list_equalities, &mut self.structure_equalities);
        self.dom.recall_previous_dirt(
            &mut self.morphism_equalities,
            &mut self.structure_equalities,
        );
        self.cod.recall_previous_dirt(
            &mut self.morphism_equalities,
            &mut self.structure_equalities,
        );
        self.map_el
            .recall_previous_dirt(&mut self.el_equalities, &mut self.morphism_equalities);
        self.map_els
            .recall_previous_dirt(&mut self.el_list_equalities, &mut self.morphism_equalities);
        self.initial_structure
            .recall_previous_dirt(&mut self.structure_equalities);
        self.initiality_morphism.recall_previous_dirt(
            &mut self.morphism_equalities,
            &mut self.structure_equalities,
        );
        self.nil_chain
            .recall_previous_dirt(&mut self.chain_equalities);
        self.chain_tail
            .recall_previous_dirt(&mut self.chain_equalities);
        self.chain_head_structure
            .recall_previous_dirt(&mut self.chain_equalities, &mut self.structure_equalities);
        self.chain_head_transition
            .recall_previous_dirt(&mut self.chain_equalities, &mut self.morphism_equalities);
        self.type_symbol
            .recall_previous_dirt(&mut self.symbol_kind_equalities);
        self.pred_symbol
            .recall_previous_dirt(&mut self.symbol_kind_equalities);
        self.func_symbol
            .recall_previous_dirt(&mut self.symbol_kind_equalities);
        self.rule_symbol
            .recall_previous_dirt(&mut self.symbol_kind_equalities);
        self.zero.recall_previous_dirt(&mut self.nat_equalities);
        self.succ.recall_previous_dirt(&mut self.nat_equalities);
        self.type_list_len
            .recall_previous_dirt(&mut self.nat_equalities, &mut self.type_list_equalities);
        self.term_list_len.recall_previous_dirt(
            &mut self.nat_equalities,
            &mut self.term_list_node_equalities,
        );
        self.rule_chain.recall_previous_dirt(
            &mut self.chain_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.stmt_list_chain.recall_previous_dirt(
            &mut self.chain_equalities,
            &mut self.stmt_list_node_equalities,
        );
        self.stmt_structure.recall_previous_dirt(
            &mut self.stmt_node_equalities,
            &mut self.structure_equalities,
        );
        self.if_atom_structure.recall_previous_dirt(
            &mut self.if_atom_node_equalities,
            &mut self.structure_equalities,
        );
        self.then_atom_structure.recall_previous_dirt(
            &mut self.structure_equalities,
            &mut self.then_atom_node_equalities,
        );
        self.term_structure.recall_previous_dirt(
            &mut self.structure_equalities,
            &mut self.term_node_equalities,
        );
        self.terms_structure.recall_previous_dirt(
            &mut self.structure_equalities,
            &mut self.term_list_node_equalities,
        );
        self.opt_term_structure.recall_previous_dirt(
            &mut self.opt_term_node_equalities,
            &mut self.structure_equalities,
        );
        self.semantic_el
            .recall_previous_dirt(&mut self.el_equalities, &mut self.term_node_equalities);
        self.semantic_els.recall_previous_dirt(
            &mut self.el_list_equalities,
            &mut self.term_list_node_equalities,
        );
        self.wildcard_virt_ident.recall_previous_dirt(
            &mut self.term_node_equalities,
            &mut self.virt_ident_equalities,
        );
        self.grouped_rule_chain.recall_previous_dirt(
            &mut self.chain_equalities,
            &mut self.rule_decl_node_equalities,
        );
        self.grouped_stmt_list_chain.recall_previous_dirt(
            &mut self.chain_equalities,
            &mut self.stmt_list_node_equalities,
        );

        let mut ident_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut ident_dirty_prev_tmp, &mut self.ident_dirty_prev);
        self.ident_dirty = ident_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.ident_equalities.root(*el) == *el)
            .collect();

        let mut virt_ident_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut virt_ident_dirty_prev_tmp,
            &mut self.virt_ident_dirty_prev,
        );
        self.virt_ident_dirty = virt_ident_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.virt_ident_equalities.root(*el) == *el)
            .collect();

        let mut type_decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut type_decl_node_dirty_prev_tmp,
            &mut self.type_decl_node_dirty_prev,
        );
        self.type_decl_node_dirty = type_decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.type_decl_node_equalities.root(*el) == *el)
            .collect();

        let mut arg_decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut arg_decl_node_dirty_prev_tmp,
            &mut self.arg_decl_node_dirty_prev,
        );
        self.arg_decl_node_dirty = arg_decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.arg_decl_node_equalities.root(*el) == *el)
            .collect();

        let mut arg_decl_list_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut arg_decl_list_node_dirty_prev_tmp,
            &mut self.arg_decl_list_node_dirty_prev,
        );
        self.arg_decl_list_node_dirty = arg_decl_list_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.arg_decl_list_node_equalities.root(*el) == *el)
            .collect();

        let mut pred_decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut pred_decl_node_dirty_prev_tmp,
            &mut self.pred_decl_node_dirty_prev,
        );
        self.pred_decl_node_dirty = pred_decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.pred_decl_node_equalities.root(*el) == *el)
            .collect();

        let mut func_decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut func_decl_node_dirty_prev_tmp,
            &mut self.func_decl_node_dirty_prev,
        );
        self.func_decl_node_dirty = func_decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.func_decl_node_equalities.root(*el) == *el)
            .collect();

        let mut term_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut term_node_dirty_prev_tmp,
            &mut self.term_node_dirty_prev,
        );
        self.term_node_dirty = term_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.term_node_equalities.root(*el) == *el)
            .collect();

        let mut term_list_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut term_list_node_dirty_prev_tmp,
            &mut self.term_list_node_dirty_prev,
        );
        self.term_list_node_dirty = term_list_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.term_list_node_equalities.root(*el) == *el)
            .collect();

        let mut opt_term_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut opt_term_node_dirty_prev_tmp,
            &mut self.opt_term_node_dirty_prev,
        );
        self.opt_term_node_dirty = opt_term_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.opt_term_node_equalities.root(*el) == *el)
            .collect();

        let mut if_atom_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut if_atom_node_dirty_prev_tmp,
            &mut self.if_atom_node_dirty_prev,
        );
        self.if_atom_node_dirty = if_atom_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.if_atom_node_equalities.root(*el) == *el)
            .collect();

        let mut then_atom_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut then_atom_node_dirty_prev_tmp,
            &mut self.then_atom_node_dirty_prev,
        );
        self.then_atom_node_dirty = then_atom_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.then_atom_node_equalities.root(*el) == *el)
            .collect();

        let mut stmt_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut stmt_node_dirty_prev_tmp,
            &mut self.stmt_node_dirty_prev,
        );
        self.stmt_node_dirty = stmt_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.stmt_node_equalities.root(*el) == *el)
            .collect();

        let mut stmt_list_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut stmt_list_node_dirty_prev_tmp,
            &mut self.stmt_list_node_dirty_prev,
        );
        self.stmt_list_node_dirty = stmt_list_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.stmt_list_node_equalities.root(*el) == *el)
            .collect();

        let mut rule_decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut rule_decl_node_dirty_prev_tmp,
            &mut self.rule_decl_node_dirty_prev,
        );
        self.rule_decl_node_dirty = rule_decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.rule_decl_node_equalities.root(*el) == *el)
            .collect();

        let mut decl_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut decl_node_dirty_prev_tmp,
            &mut self.decl_node_dirty_prev,
        );
        self.decl_node_dirty = decl_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.decl_node_equalities.root(*el) == *el)
            .collect();

        let mut decl_list_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut decl_list_node_dirty_prev_tmp,
            &mut self.decl_list_node_dirty_prev,
        );
        self.decl_list_node_dirty = decl_list_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.decl_list_node_equalities.root(*el) == *el)
            .collect();

        let mut module_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut module_node_dirty_prev_tmp,
            &mut self.module_node_dirty_prev,
        );
        self.module_node_dirty = module_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.module_node_equalities.root(*el) == *el)
            .collect();

        let mut loc_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut loc_dirty_prev_tmp, &mut self.loc_dirty_prev);
        self.loc_dirty = loc_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.loc_equalities.root(*el) == *el)
            .collect();

        let mut rule_child_node_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut rule_child_node_dirty_prev_tmp,
            &mut self.rule_child_node_dirty_prev,
        );
        self.rule_child_node_dirty = rule_child_node_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.rule_child_node_equalities.root(*el) == *el)
            .collect();

        let mut type_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut type_dirty_prev_tmp, &mut self.type_dirty_prev);
        self.type_dirty = type_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.type_equalities.root(*el) == *el)
            .collect();

        let mut type_list_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut type_list_dirty_prev_tmp,
            &mut self.type_list_dirty_prev,
        );
        self.type_list_dirty = type_list_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.type_list_equalities.root(*el) == *el)
            .collect();

        let mut pred_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut pred_dirty_prev_tmp, &mut self.pred_dirty_prev);
        self.pred_dirty = pred_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.pred_equalities.root(*el) == *el)
            .collect();

        let mut func_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut func_dirty_prev_tmp, &mut self.func_dirty_prev);
        self.func_dirty = func_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.func_equalities.root(*el) == *el)
            .collect();

        let mut structure_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut structure_dirty_prev_tmp,
            &mut self.structure_dirty_prev,
        );
        self.structure_dirty = structure_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.structure_equalities.root(*el) == *el)
            .collect();

        let mut el_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut el_dirty_prev_tmp, &mut self.el_dirty_prev);
        self.el_dirty = el_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.el_equalities.root(*el) == *el)
            .collect();

        let mut el_list_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut el_list_dirty_prev_tmp, &mut self.el_list_dirty_prev);
        self.el_list_dirty = el_list_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.el_list_equalities.root(*el) == *el)
            .collect();

        let mut morphism_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut morphism_dirty_prev_tmp, &mut self.morphism_dirty_prev);
        self.morphism_dirty = morphism_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.morphism_equalities.root(*el) == *el)
            .collect();

        let mut chain_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut chain_dirty_prev_tmp, &mut self.chain_dirty_prev);
        self.chain_dirty = chain_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.chain_equalities.root(*el) == *el)
            .collect();

        let mut symbol_kind_dirty_prev_tmp = Vec::new();
        std::mem::swap(
            &mut symbol_kind_dirty_prev_tmp,
            &mut self.symbol_kind_dirty_prev,
        );
        self.symbol_kind_dirty = symbol_kind_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.symbol_kind_equalities.root(*el) == *el)
            .collect();

        let mut nat_dirty_prev_tmp = Vec::new();
        std::mem::swap(&mut nat_dirty_prev_tmp, &mut self.nat_dirty_prev);
        self.nat_dirty = nat_dirty_prev_tmp
            .into_iter()
            .flatten()
            .filter(|el| self.nat_equalities.root(*el) == *el)
            .collect();

        self.empty_join_is_dirty = self.empty_join_is_dirty_prev;
        self.empty_join_is_dirty_prev = false;
    }
}
impl fmt::Display for Eqlog {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.ident_equalities
            .class_table()
            .with(Header("Ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.virt_ident_equalities
            .class_table()
            .with(Header("VirtIdent"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_decl_node_equalities
            .class_table()
            .with(Header("TypeDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.arg_decl_node_equalities
            .class_table()
            .with(Header("ArgDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.arg_decl_list_node_equalities
            .class_table()
            .with(Header("ArgDeclListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.pred_decl_node_equalities
            .class_table()
            .with(Header("PredDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.func_decl_node_equalities
            .class_table()
            .with(Header("FuncDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.term_node_equalities
            .class_table()
            .with(Header("TermNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.term_list_node_equalities
            .class_table()
            .with(Header("TermListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.opt_term_node_equalities
            .class_table()
            .with(Header("OptTermNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.if_atom_node_equalities
            .class_table()
            .with(Header("IfAtomNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.then_atom_node_equalities
            .class_table()
            .with(Header("ThenAtomNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.stmt_node_equalities
            .class_table()
            .with(Header("StmtNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.stmt_list_node_equalities
            .class_table()
            .with(Header("StmtListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.rule_decl_node_equalities
            .class_table()
            .with(Header("RuleDeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.decl_node_equalities
            .class_table()
            .with(Header("DeclNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.decl_list_node_equalities
            .class_table()
            .with(Header("DeclListNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.module_node_equalities
            .class_table()
            .with(Header("ModuleNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.loc_equalities
            .class_table()
            .with(Header("Loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.rule_child_node_equalities
            .class_table()
            .with(Header("RuleChildNode"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_equalities
            .class_table()
            .with(Header("Type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.type_list_equalities
            .class_table()
            .with(Header("TypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.pred_equalities
            .class_table()
            .with(Header("Pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.func_equalities
            .class_table()
            .with(Header("Func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.structure_equalities
            .class_table()
            .with(Header("Structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.el_equalities
            .class_table()
            .with(Header("El"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.el_list_equalities
            .class_table()
            .with(Header("ElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.morphism_equalities
            .class_table()
            .with(Header("Morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.chain_equalities
            .class_table()
            .with(Header("Chain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.symbol_kind_equalities
            .class_table()
            .with(Header("SymbolKind"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.nat_equalities
            .class_table()
            .with(Header("Nat"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬'),
            )
            .fmt(f)?;
        self.absurd.fmt(f)?;
        self.type_decl.fmt(f)?;
        self.arg_decl_node_name.fmt(f)?;
        self.arg_decl_node_type.fmt(f)?;
        self.nil_arg_decl_list_node.fmt(f)?;
        self.cons_arg_decl_list_node.fmt(f)?;
        self.pred_decl.fmt(f)?;
        self.func_decl.fmt(f)?;
        self.nil_term_list_node.fmt(f)?;
        self.cons_term_list_node.fmt(f)?;
        self.none_term_node.fmt(f)?;
        self.some_term_node.fmt(f)?;
        self.var_term_node.fmt(f)?;
        self.wildcard_term_node.fmt(f)?;
        self.app_term_node.fmt(f)?;
        self.equal_if_atom_node.fmt(f)?;
        self.defined_if_atom_node.fmt(f)?;
        self.pred_if_atom_node.fmt(f)?;
        self.var_if_atom_node.fmt(f)?;
        self.equal_then_atom_node.fmt(f)?;
        self.defined_then_atom_node.fmt(f)?;
        self.pred_then_atom_node.fmt(f)?;
        self.if_stmt_node.fmt(f)?;
        self.then_stmt_node.fmt(f)?;
        self.nil_stmt_list_node.fmt(f)?;
        self.cons_stmt_list_node.fmt(f)?;
        self.rule_decl.fmt(f)?;
        self.decl_node_type.fmt(f)?;
        self.decl_node_pred.fmt(f)?;
        self.decl_node_func.fmt(f)?;
        self.decl_node_rule.fmt(f)?;
        self.nil_decl_list_node.fmt(f)?;
        self.cons_decl_list_node.fmt(f)?;
        self.decls_module_node.fmt(f)?;
        self.rule_child.fmt(f)?;
        self.pred_app.fmt(f)?;
        self.el_type.fmt(f)?;
        self.el_types.fmt(f)?;
        self.constrained_el.fmt(f)?;
        self.constrained_els.fmt(f)?;
        self.in_ker.fmt(f)?;
        self.el_in_img.fmt(f)?;
        self.pred_tuple_in_img.fmt(f)?;
        self.func_app_in_img.fmt(f)?;
        self.defined_symbol.fmt(f)?;
        self.should_be_symbol.fmt(f)?;
        self.pred_arg_num_should_match.fmt(f)?;
        self.func_arg_num_should_match.fmt(f)?;
        self.var_before_term.fmt(f)?;
        self.var_before_terms.fmt(f)?;
        self.var_before_opt_term.fmt(f)?;
        self.var_before_if_atom.fmt(f)?;
        self.var_before_then_atom.fmt(f)?;
        self.var_before_stmt.fmt(f)?;
        self.var_before_stmts.fmt(f)?;
        self.var_in_term.fmt(f)?;
        self.var_in_terms.fmt(f)?;
        self.var_in_opt_term.fmt(f)?;
        self.var_in_if_atom.fmt(f)?;
        self.var_in_then_atom.fmt(f)?;
        self.var_in_stmt.fmt(f)?;
        self.term_should_be_epic_ok.fmt(f)?;
        self.terms_should_be_epic_ok.fmt(f)?;
        self.should_be_surjective.fmt(f)?;
        self.term_surjective_exempted.fmt(f)?;
        self.terms_surjective_exempted.fmt(f)?;
        self.el_surjective_exempted.fmt(f)?;
        self.el_should_be_surjective_ok.fmt(f)?;
        self.el_is_surjective_ok.fmt(f)?;
        self.var_term_in_rule.fmt(f)?;
        self.if_after_then.fmt(f)?;
        self.real_virt_ident.fmt(f)?;
        self.rule_name.fmt(f)?;
        self.type_decl_node_loc.fmt(f)?;
        self.arg_decl_node_loc.fmt(f)?;
        self.arg_decl_list_node_loc.fmt(f)?;
        self.pred_decl_node_loc.fmt(f)?;
        self.func_decl_node_loc.fmt(f)?;
        self.term_node_loc.fmt(f)?;
        self.term_list_node_loc.fmt(f)?;
        self.opt_term_node_loc.fmt(f)?;
        self.if_atom_node_loc.fmt(f)?;
        self.then_atom_node_loc.fmt(f)?;
        self.stmt_node_loc.fmt(f)?;
        self.stmt_list_node_loc.fmt(f)?;
        self.rule_decl_node_loc.fmt(f)?;
        self.decl_node_loc.fmt(f)?;
        self.decl_list_node_loc.fmt(f)?;
        self.module_node_loc.fmt(f)?;
        self.rule_child_term.fmt(f)?;
        self.rule_child_term_list.fmt(f)?;
        self.rule_child_opt_term.fmt(f)?;
        self.rule_child_if_atom.fmt(f)?;
        self.rule_child_then_atom.fmt(f)?;
        self.rule_child_stmt.fmt(f)?;
        self.rule_child_stmt_list.fmt(f)?;
        self.nil_type_list.fmt(f)?;
        self.cons_type_list.fmt(f)?;
        self.semantic_type.fmt(f)?;
        self.semantic_arg_types.fmt(f)?;
        self.semantic_pred.fmt(f)?;
        self.arity.fmt(f)?;
        self.semantic_func.fmt(f)?;
        self.domain.fmt(f)?;
        self.codomain.fmt(f)?;
        self.nil_el_list.fmt(f)?;
        self.cons_el_list.fmt(f)?;
        self.func_app.fmt(f)?;
        self.var.fmt(f)?;
        self.el_structure.fmt(f)?;
        self.els_structure.fmt(f)?;
        self.dom.fmt(f)?;
        self.cod.fmt(f)?;
        self.map_el.fmt(f)?;
        self.map_els.fmt(f)?;
        self.initial_structure.fmt(f)?;
        self.initiality_morphism.fmt(f)?;
        self.nil_chain.fmt(f)?;
        self.chain_tail.fmt(f)?;
        self.chain_head_structure.fmt(f)?;
        self.chain_head_transition.fmt(f)?;
        self.type_symbol.fmt(f)?;
        self.pred_symbol.fmt(f)?;
        self.func_symbol.fmt(f)?;
        self.rule_symbol.fmt(f)?;
        self.zero.fmt(f)?;
        self.succ.fmt(f)?;
        self.type_list_len.fmt(f)?;
        self.term_list_len.fmt(f)?;
        self.rule_chain.fmt(f)?;
        self.stmt_list_chain.fmt(f)?;
        self.stmt_structure.fmt(f)?;
        self.if_atom_structure.fmt(f)?;
        self.then_atom_structure.fmt(f)?;
        self.term_structure.fmt(f)?;
        self.terms_structure.fmt(f)?;
        self.opt_term_structure.fmt(f)?;
        self.semantic_el.fmt(f)?;
        self.semantic_els.fmt(f)?;
        self.wildcard_virt_ident.fmt(f)?;
        self.grouped_rule_chain.fmt(f)?;
        self.grouped_stmt_list_chain.fmt(f)?;
        Ok(())
    }
}
